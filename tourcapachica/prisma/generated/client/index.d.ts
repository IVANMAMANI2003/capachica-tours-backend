
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permiso
 * 
 */
export type Permiso = $Result.DefaultSelection<Prisma.$PermisoPayload>
/**
 * Model RolesPermisos
 * 
 */
export type RolesPermisos = $Result.DefaultSelection<Prisma.$RolesPermisosPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model Subdivision
 * 
 */
export type Subdivision = $Result.DefaultSelection<Prisma.$SubdivisionPayload>
/**
 * Model Persona
 * 
 */
export type Persona = $Result.DefaultSelection<Prisma.$PersonaPayload>
/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model UsuariosRoles
 * 
 */
export type UsuariosRoles = $Result.DefaultSelection<Prisma.$UsuariosRolesPayload>
/**
 * Model Emprendimiento
 * 
 */
export type Emprendimiento = $Result.DefaultSelection<Prisma.$EmprendimientoPayload>
/**
 * Model RegistroAcceso
 * 
 */
export type RegistroAcceso = $Result.DefaultSelection<Prisma.$RegistroAccesoPayload>
/**
 * Model TokenInvalidado
 * 
 */
export type TokenInvalidado = $Result.DefaultSelection<Prisma.$TokenInvalidadoPayload>
/**
 * Model Turista
 * 
 */
export type Turista = $Result.DefaultSelection<Prisma.$TuristaPayload>
/**
 * Model LugarTuristico
 * 
 */
export type LugarTuristico = $Result.DefaultSelection<Prisma.$LugarTuristicoPayload>
/**
 * Model ServicioEmprendedor
 * 
 */
export type ServicioEmprendedor = $Result.DefaultSelection<Prisma.$ServicioEmprendedorPayload>
/**
 * Model Servicio
 * 
 */
export type Servicio = $Result.DefaultSelection<Prisma.$ServicioPayload>
/**
 * Model PaqueteTuristicoServicio
 * 
 */
export type PaqueteTuristicoServicio = $Result.DefaultSelection<Prisma.$PaqueteTuristicoServicioPayload>
/**
 * Model PaqueteTuristico
 * 
 */
export type PaqueteTuristico = $Result.DefaultSelection<Prisma.$PaqueteTuristicoPayload>
/**
 * Model DisponibilidadPaquete
 * 
 */
export type DisponibilidadPaquete = $Result.DefaultSelection<Prisma.$DisponibilidadPaquetePayload>
/**
 * Model TipoServicio
 * 
 */
export type TipoServicio = $Result.DefaultSelection<Prisma.$TipoServicioPayload>
/**
 * Model ServicioDisponibilidad
 * 
 */
export type ServicioDisponibilidad = $Result.DefaultSelection<Prisma.$ServicioDisponibilidadPayload>
/**
 * Model Resena
 * 
 */
export type Resena = $Result.DefaultSelection<Prisma.$ResenaPayload>
/**
 * Model Favorito
 * 
 */
export type Favorito = $Result.DefaultSelection<Prisma.$FavoritoPayload>
/**
 * Model Reserva
 * 
 */
export type Reserva = $Result.DefaultSelection<Prisma.$ReservaPayload>
/**
 * Model ItinerarioReserva
 * 
 */
export type ItinerarioReserva = $Result.DefaultSelection<Prisma.$ItinerarioReservaPayload>
/**
 * Model ItinerarioLugar
 * 
 */
export type ItinerarioLugar = $Result.DefaultSelection<Prisma.$ItinerarioLugarPayload>
/**
 * Model Pago
 * 
 */
export type Pago = $Result.DefaultSelection<Prisma.$PagoPayload>
/**
 * Model PagoDetalle
 * 
 */
export type PagoDetalle = $Result.DefaultSelection<Prisma.$PagoDetallePayload>
/**
 * Model TipoPago
 * 
 */
export type TipoPago = $Result.DefaultSelection<Prisma.$TipoPagoPayload>
/**
 * Model Comprobante
 * 
 */
export type Comprobante = $Result.DefaultSelection<Prisma.$ComprobantePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.role.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permiso`: Exposes CRUD operations for the **Permiso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permisos
    * const permisos = await prisma.permiso.findMany()
    * ```
    */
  get permiso(): Prisma.PermisoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolesPermisos`: Exposes CRUD operations for the **RolesPermisos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolesPermisos
    * const rolesPermisos = await prisma.rolesPermisos.findMany()
    * ```
    */
  get rolesPermisos(): Prisma.RolesPermisosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subdivision`: Exposes CRUD operations for the **Subdivision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subdivisions
    * const subdivisions = await prisma.subdivision.findMany()
    * ```
    */
  get subdivision(): Prisma.SubdivisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.persona`: Exposes CRUD operations for the **Persona** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personas
    * const personas = await prisma.persona.findMany()
    * ```
    */
  get persona(): Prisma.PersonaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuariosRoles`: Exposes CRUD operations for the **UsuariosRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuariosRoles
    * const usuariosRoles = await prisma.usuariosRoles.findMany()
    * ```
    */
  get usuariosRoles(): Prisma.UsuariosRolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emprendimiento`: Exposes CRUD operations for the **Emprendimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emprendimientos
    * const emprendimientos = await prisma.emprendimiento.findMany()
    * ```
    */
  get emprendimiento(): Prisma.EmprendimientoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.registroAcceso`: Exposes CRUD operations for the **RegistroAcceso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegistroAccesos
    * const registroAccesos = await prisma.registroAcceso.findMany()
    * ```
    */
  get registroAcceso(): Prisma.RegistroAccesoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tokenInvalidado`: Exposes CRUD operations for the **TokenInvalidado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenInvalidados
    * const tokenInvalidados = await prisma.tokenInvalidado.findMany()
    * ```
    */
  get tokenInvalidado(): Prisma.TokenInvalidadoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.turista`: Exposes CRUD operations for the **Turista** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Turistas
    * const turistas = await prisma.turista.findMany()
    * ```
    */
  get turista(): Prisma.TuristaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lugarTuristico`: Exposes CRUD operations for the **LugarTuristico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LugarTuristicos
    * const lugarTuristicos = await prisma.lugarTuristico.findMany()
    * ```
    */
  get lugarTuristico(): Prisma.LugarTuristicoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicioEmprendedor`: Exposes CRUD operations for the **ServicioEmprendedor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicioEmprendedors
    * const servicioEmprendedors = await prisma.servicioEmprendedor.findMany()
    * ```
    */
  get servicioEmprendedor(): Prisma.ServicioEmprendedorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicio`: Exposes CRUD operations for the **Servicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servicios
    * const servicios = await prisma.servicio.findMany()
    * ```
    */
  get servicio(): Prisma.ServicioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paqueteTuristicoServicio`: Exposes CRUD operations for the **PaqueteTuristicoServicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaqueteTuristicoServicios
    * const paqueteTuristicoServicios = await prisma.paqueteTuristicoServicio.findMany()
    * ```
    */
  get paqueteTuristicoServicio(): Prisma.PaqueteTuristicoServicioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paqueteTuristico`: Exposes CRUD operations for the **PaqueteTuristico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaqueteTuristicos
    * const paqueteTuristicos = await prisma.paqueteTuristico.findMany()
    * ```
    */
  get paqueteTuristico(): Prisma.PaqueteTuristicoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disponibilidadPaquete`: Exposes CRUD operations for the **DisponibilidadPaquete** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisponibilidadPaquetes
    * const disponibilidadPaquetes = await prisma.disponibilidadPaquete.findMany()
    * ```
    */
  get disponibilidadPaquete(): Prisma.DisponibilidadPaqueteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoServicio`: Exposes CRUD operations for the **TipoServicio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoServicios
    * const tipoServicios = await prisma.tipoServicio.findMany()
    * ```
    */
  get tipoServicio(): Prisma.TipoServicioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicioDisponibilidad`: Exposes CRUD operations for the **ServicioDisponibilidad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicioDisponibilidads
    * const servicioDisponibilidads = await prisma.servicioDisponibilidad.findMany()
    * ```
    */
  get servicioDisponibilidad(): Prisma.ServicioDisponibilidadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resena`: Exposes CRUD operations for the **Resena** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resenas
    * const resenas = await prisma.resena.findMany()
    * ```
    */
  get resena(): Prisma.ResenaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorito`: Exposes CRUD operations for the **Favorito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favoritos
    * const favoritos = await prisma.favorito.findMany()
    * ```
    */
  get favorito(): Prisma.FavoritoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reserva`: Exposes CRUD operations for the **Reserva** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservas
    * const reservas = await prisma.reserva.findMany()
    * ```
    */
  get reserva(): Prisma.ReservaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itinerarioReserva`: Exposes CRUD operations for the **ItinerarioReserva** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItinerarioReservas
    * const itinerarioReservas = await prisma.itinerarioReserva.findMany()
    * ```
    */
  get itinerarioReserva(): Prisma.ItinerarioReservaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.itinerarioLugar`: Exposes CRUD operations for the **ItinerarioLugar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ItinerarioLugars
    * const itinerarioLugars = await prisma.itinerarioLugar.findMany()
    * ```
    */
  get itinerarioLugar(): Prisma.ItinerarioLugarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pago`: Exposes CRUD operations for the **Pago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagos
    * const pagos = await prisma.pago.findMany()
    * ```
    */
  get pago(): Prisma.PagoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pagoDetalle`: Exposes CRUD operations for the **PagoDetalle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PagoDetalles
    * const pagoDetalles = await prisma.pagoDetalle.findMany()
    * ```
    */
  get pagoDetalle(): Prisma.PagoDetalleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoPago`: Exposes CRUD operations for the **TipoPago** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoPagos
    * const tipoPagos = await prisma.tipoPago.findMany()
    * ```
    */
  get tipoPago(): Prisma.TipoPagoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comprobante`: Exposes CRUD operations for the **Comprobante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comprobantes
    * const comprobantes = await prisma.comprobante.findMany()
    * ```
    */
  get comprobante(): Prisma.ComprobanteDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Role: 'Role',
    Permiso: 'Permiso',
    RolesPermisos: 'RolesPermisos',
    Country: 'Country',
    Subdivision: 'Subdivision',
    Persona: 'Persona',
    Usuario: 'Usuario',
    UsuariosRoles: 'UsuariosRoles',
    Emprendimiento: 'Emprendimiento',
    RegistroAcceso: 'RegistroAcceso',
    TokenInvalidado: 'TokenInvalidado',
    Turista: 'Turista',
    LugarTuristico: 'LugarTuristico',
    ServicioEmprendedor: 'ServicioEmprendedor',
    Servicio: 'Servicio',
    PaqueteTuristicoServicio: 'PaqueteTuristicoServicio',
    PaqueteTuristico: 'PaqueteTuristico',
    DisponibilidadPaquete: 'DisponibilidadPaquete',
    TipoServicio: 'TipoServicio',
    ServicioDisponibilidad: 'ServicioDisponibilidad',
    Resena: 'Resena',
    Favorito: 'Favorito',
    Reserva: 'Reserva',
    ItinerarioReserva: 'ItinerarioReserva',
    ItinerarioLugar: 'ItinerarioLugar',
    Pago: 'Pago',
    PagoDetalle: 'PagoDetalle',
    TipoPago: 'TipoPago',
    Comprobante: 'Comprobante'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "role" | "permiso" | "rolesPermisos" | "country" | "subdivision" | "persona" | "usuario" | "usuariosRoles" | "emprendimiento" | "registroAcceso" | "tokenInvalidado" | "turista" | "lugarTuristico" | "servicioEmprendedor" | "servicio" | "paqueteTuristicoServicio" | "paqueteTuristico" | "disponibilidadPaquete" | "tipoServicio" | "servicioDisponibilidad" | "resena" | "favorito" | "reserva" | "itinerarioReserva" | "itinerarioLugar" | "pago" | "pagoDetalle" | "tipoPago" | "comprobante"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permiso: {
        payload: Prisma.$PermisoPayload<ExtArgs>
        fields: Prisma.PermisoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermisoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermisoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          findFirst: {
            args: Prisma.PermisoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermisoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          findMany: {
            args: Prisma.PermisoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>[]
          }
          create: {
            args: Prisma.PermisoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          createMany: {
            args: Prisma.PermisoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermisoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>[]
          }
          delete: {
            args: Prisma.PermisoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          update: {
            args: Prisma.PermisoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          deleteMany: {
            args: Prisma.PermisoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermisoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermisoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>[]
          }
          upsert: {
            args: Prisma.PermisoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          aggregate: {
            args: Prisma.PermisoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermiso>
          }
          groupBy: {
            args: Prisma.PermisoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermisoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermisoCountArgs<ExtArgs>
            result: $Utils.Optional<PermisoCountAggregateOutputType> | number
          }
        }
      }
      RolesPermisos: {
        payload: Prisma.$RolesPermisosPayload<ExtArgs>
        fields: Prisma.RolesPermisosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolesPermisosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPermisosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolesPermisosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPermisosPayload>
          }
          findFirst: {
            args: Prisma.RolesPermisosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPermisosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolesPermisosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPermisosPayload>
          }
          findMany: {
            args: Prisma.RolesPermisosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPermisosPayload>[]
          }
          create: {
            args: Prisma.RolesPermisosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPermisosPayload>
          }
          createMany: {
            args: Prisma.RolesPermisosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolesPermisosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPermisosPayload>[]
          }
          delete: {
            args: Prisma.RolesPermisosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPermisosPayload>
          }
          update: {
            args: Prisma.RolesPermisosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPermisosPayload>
          }
          deleteMany: {
            args: Prisma.RolesPermisosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolesPermisosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolesPermisosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPermisosPayload>[]
          }
          upsert: {
            args: Prisma.RolesPermisosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPermisosPayload>
          }
          aggregate: {
            args: Prisma.RolesPermisosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolesPermisos>
          }
          groupBy: {
            args: Prisma.RolesPermisosGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesPermisosGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolesPermisosCountArgs<ExtArgs>
            result: $Utils.Optional<RolesPermisosCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      Subdivision: {
        payload: Prisma.$SubdivisionPayload<ExtArgs>
        fields: Prisma.SubdivisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubdivisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdivisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubdivisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdivisionPayload>
          }
          findFirst: {
            args: Prisma.SubdivisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdivisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubdivisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdivisionPayload>
          }
          findMany: {
            args: Prisma.SubdivisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdivisionPayload>[]
          }
          create: {
            args: Prisma.SubdivisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdivisionPayload>
          }
          createMany: {
            args: Prisma.SubdivisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubdivisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdivisionPayload>[]
          }
          delete: {
            args: Prisma.SubdivisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdivisionPayload>
          }
          update: {
            args: Prisma.SubdivisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdivisionPayload>
          }
          deleteMany: {
            args: Prisma.SubdivisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubdivisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubdivisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdivisionPayload>[]
          }
          upsert: {
            args: Prisma.SubdivisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubdivisionPayload>
          }
          aggregate: {
            args: Prisma.SubdivisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubdivision>
          }
          groupBy: {
            args: Prisma.SubdivisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubdivisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubdivisionCountArgs<ExtArgs>
            result: $Utils.Optional<SubdivisionCountAggregateOutputType> | number
          }
        }
      }
      Persona: {
        payload: Prisma.$PersonaPayload<ExtArgs>
        fields: Prisma.PersonaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>
          }
          findFirst: {
            args: Prisma.PersonaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>
          }
          findMany: {
            args: Prisma.PersonaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>[]
          }
          create: {
            args: Prisma.PersonaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>
          }
          createMany: {
            args: Prisma.PersonaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>[]
          }
          delete: {
            args: Prisma.PersonaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>
          }
          update: {
            args: Prisma.PersonaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>
          }
          deleteMany: {
            args: Prisma.PersonaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>[]
          }
          upsert: {
            args: Prisma.PersonaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaPayload>
          }
          aggregate: {
            args: Prisma.PersonaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersona>
          }
          groupBy: {
            args: Prisma.PersonaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonaCountArgs<ExtArgs>
            result: $Utils.Optional<PersonaCountAggregateOutputType> | number
          }
        }
      }
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      UsuariosRoles: {
        payload: Prisma.$UsuariosRolesPayload<ExtArgs>
        fields: Prisma.UsuariosRolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuariosRolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosRolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuariosRolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosRolesPayload>
          }
          findFirst: {
            args: Prisma.UsuariosRolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosRolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuariosRolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosRolesPayload>
          }
          findMany: {
            args: Prisma.UsuariosRolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosRolesPayload>[]
          }
          create: {
            args: Prisma.UsuariosRolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosRolesPayload>
          }
          createMany: {
            args: Prisma.UsuariosRolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuariosRolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosRolesPayload>[]
          }
          delete: {
            args: Prisma.UsuariosRolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosRolesPayload>
          }
          update: {
            args: Prisma.UsuariosRolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosRolesPayload>
          }
          deleteMany: {
            args: Prisma.UsuariosRolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuariosRolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuariosRolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosRolesPayload>[]
          }
          upsert: {
            args: Prisma.UsuariosRolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosRolesPayload>
          }
          aggregate: {
            args: Prisma.UsuariosRolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuariosRoles>
          }
          groupBy: {
            args: Prisma.UsuariosRolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuariosRolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuariosRolesCountArgs<ExtArgs>
            result: $Utils.Optional<UsuariosRolesCountAggregateOutputType> | number
          }
        }
      }
      Emprendimiento: {
        payload: Prisma.$EmprendimientoPayload<ExtArgs>
        fields: Prisma.EmprendimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmprendimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmprendimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>
          }
          findFirst: {
            args: Prisma.EmprendimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmprendimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>
          }
          findMany: {
            args: Prisma.EmprendimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>[]
          }
          create: {
            args: Prisma.EmprendimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>
          }
          createMany: {
            args: Prisma.EmprendimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmprendimientoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>[]
          }
          delete: {
            args: Prisma.EmprendimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>
          }
          update: {
            args: Prisma.EmprendimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>
          }
          deleteMany: {
            args: Prisma.EmprendimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmprendimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmprendimientoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>[]
          }
          upsert: {
            args: Prisma.EmprendimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>
          }
          aggregate: {
            args: Prisma.EmprendimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmprendimiento>
          }
          groupBy: {
            args: Prisma.EmprendimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmprendimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmprendimientoCountArgs<ExtArgs>
            result: $Utils.Optional<EmprendimientoCountAggregateOutputType> | number
          }
        }
      }
      RegistroAcceso: {
        payload: Prisma.$RegistroAccesoPayload<ExtArgs>
        fields: Prisma.RegistroAccesoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegistroAccesoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAccesoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegistroAccesoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAccesoPayload>
          }
          findFirst: {
            args: Prisma.RegistroAccesoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAccesoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegistroAccesoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAccesoPayload>
          }
          findMany: {
            args: Prisma.RegistroAccesoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAccesoPayload>[]
          }
          create: {
            args: Prisma.RegistroAccesoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAccesoPayload>
          }
          createMany: {
            args: Prisma.RegistroAccesoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegistroAccesoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAccesoPayload>[]
          }
          delete: {
            args: Prisma.RegistroAccesoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAccesoPayload>
          }
          update: {
            args: Prisma.RegistroAccesoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAccesoPayload>
          }
          deleteMany: {
            args: Prisma.RegistroAccesoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegistroAccesoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegistroAccesoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAccesoPayload>[]
          }
          upsert: {
            args: Prisma.RegistroAccesoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroAccesoPayload>
          }
          aggregate: {
            args: Prisma.RegistroAccesoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegistroAcceso>
          }
          groupBy: {
            args: Prisma.RegistroAccesoGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegistroAccesoGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegistroAccesoCountArgs<ExtArgs>
            result: $Utils.Optional<RegistroAccesoCountAggregateOutputType> | number
          }
        }
      }
      TokenInvalidado: {
        payload: Prisma.$TokenInvalidadoPayload<ExtArgs>
        fields: Prisma.TokenInvalidadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenInvalidadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenInvalidadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenInvalidadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenInvalidadoPayload>
          }
          findFirst: {
            args: Prisma.TokenInvalidadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenInvalidadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenInvalidadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenInvalidadoPayload>
          }
          findMany: {
            args: Prisma.TokenInvalidadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenInvalidadoPayload>[]
          }
          create: {
            args: Prisma.TokenInvalidadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenInvalidadoPayload>
          }
          createMany: {
            args: Prisma.TokenInvalidadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenInvalidadoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenInvalidadoPayload>[]
          }
          delete: {
            args: Prisma.TokenInvalidadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenInvalidadoPayload>
          }
          update: {
            args: Prisma.TokenInvalidadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenInvalidadoPayload>
          }
          deleteMany: {
            args: Prisma.TokenInvalidadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenInvalidadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TokenInvalidadoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenInvalidadoPayload>[]
          }
          upsert: {
            args: Prisma.TokenInvalidadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenInvalidadoPayload>
          }
          aggregate: {
            args: Prisma.TokenInvalidadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokenInvalidado>
          }
          groupBy: {
            args: Prisma.TokenInvalidadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenInvalidadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenInvalidadoCountArgs<ExtArgs>
            result: $Utils.Optional<TokenInvalidadoCountAggregateOutputType> | number
          }
        }
      }
      Turista: {
        payload: Prisma.$TuristaPayload<ExtArgs>
        fields: Prisma.TuristaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TuristaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuristaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TuristaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuristaPayload>
          }
          findFirst: {
            args: Prisma.TuristaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuristaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TuristaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuristaPayload>
          }
          findMany: {
            args: Prisma.TuristaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuristaPayload>[]
          }
          create: {
            args: Prisma.TuristaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuristaPayload>
          }
          createMany: {
            args: Prisma.TuristaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TuristaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuristaPayload>[]
          }
          delete: {
            args: Prisma.TuristaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuristaPayload>
          }
          update: {
            args: Prisma.TuristaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuristaPayload>
          }
          deleteMany: {
            args: Prisma.TuristaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TuristaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TuristaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuristaPayload>[]
          }
          upsert: {
            args: Prisma.TuristaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TuristaPayload>
          }
          aggregate: {
            args: Prisma.TuristaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTurista>
          }
          groupBy: {
            args: Prisma.TuristaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TuristaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TuristaCountArgs<ExtArgs>
            result: $Utils.Optional<TuristaCountAggregateOutputType> | number
          }
        }
      }
      LugarTuristico: {
        payload: Prisma.$LugarTuristicoPayload<ExtArgs>
        fields: Prisma.LugarTuristicoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LugarTuristicoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LugarTuristicoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LugarTuristicoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LugarTuristicoPayload>
          }
          findFirst: {
            args: Prisma.LugarTuristicoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LugarTuristicoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LugarTuristicoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LugarTuristicoPayload>
          }
          findMany: {
            args: Prisma.LugarTuristicoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LugarTuristicoPayload>[]
          }
          create: {
            args: Prisma.LugarTuristicoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LugarTuristicoPayload>
          }
          createMany: {
            args: Prisma.LugarTuristicoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LugarTuristicoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LugarTuristicoPayload>[]
          }
          delete: {
            args: Prisma.LugarTuristicoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LugarTuristicoPayload>
          }
          update: {
            args: Prisma.LugarTuristicoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LugarTuristicoPayload>
          }
          deleteMany: {
            args: Prisma.LugarTuristicoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LugarTuristicoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LugarTuristicoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LugarTuristicoPayload>[]
          }
          upsert: {
            args: Prisma.LugarTuristicoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LugarTuristicoPayload>
          }
          aggregate: {
            args: Prisma.LugarTuristicoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLugarTuristico>
          }
          groupBy: {
            args: Prisma.LugarTuristicoGroupByArgs<ExtArgs>
            result: $Utils.Optional<LugarTuristicoGroupByOutputType>[]
          }
          count: {
            args: Prisma.LugarTuristicoCountArgs<ExtArgs>
            result: $Utils.Optional<LugarTuristicoCountAggregateOutputType> | number
          }
        }
      }
      ServicioEmprendedor: {
        payload: Prisma.$ServicioEmprendedorPayload<ExtArgs>
        fields: Prisma.ServicioEmprendedorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicioEmprendedorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioEmprendedorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicioEmprendedorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioEmprendedorPayload>
          }
          findFirst: {
            args: Prisma.ServicioEmprendedorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioEmprendedorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicioEmprendedorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioEmprendedorPayload>
          }
          findMany: {
            args: Prisma.ServicioEmprendedorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioEmprendedorPayload>[]
          }
          create: {
            args: Prisma.ServicioEmprendedorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioEmprendedorPayload>
          }
          createMany: {
            args: Prisma.ServicioEmprendedorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicioEmprendedorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioEmprendedorPayload>[]
          }
          delete: {
            args: Prisma.ServicioEmprendedorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioEmprendedorPayload>
          }
          update: {
            args: Prisma.ServicioEmprendedorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioEmprendedorPayload>
          }
          deleteMany: {
            args: Prisma.ServicioEmprendedorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicioEmprendedorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServicioEmprendedorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioEmprendedorPayload>[]
          }
          upsert: {
            args: Prisma.ServicioEmprendedorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioEmprendedorPayload>
          }
          aggregate: {
            args: Prisma.ServicioEmprendedorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicioEmprendedor>
          }
          groupBy: {
            args: Prisma.ServicioEmprendedorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicioEmprendedorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicioEmprendedorCountArgs<ExtArgs>
            result: $Utils.Optional<ServicioEmprendedorCountAggregateOutputType> | number
          }
        }
      }
      Servicio: {
        payload: Prisma.$ServicioPayload<ExtArgs>
        fields: Prisma.ServicioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          findFirst: {
            args: Prisma.ServicioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          findMany: {
            args: Prisma.ServicioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>[]
          }
          create: {
            args: Prisma.ServicioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          createMany: {
            args: Prisma.ServicioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>[]
          }
          delete: {
            args: Prisma.ServicioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          update: {
            args: Prisma.ServicioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          deleteMany: {
            args: Prisma.ServicioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServicioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>[]
          }
          upsert: {
            args: Prisma.ServicioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioPayload>
          }
          aggregate: {
            args: Prisma.ServicioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicio>
          }
          groupBy: {
            args: Prisma.ServicioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicioCountArgs<ExtArgs>
            result: $Utils.Optional<ServicioCountAggregateOutputType> | number
          }
        }
      }
      PaqueteTuristicoServicio: {
        payload: Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>
        fields: Prisma.PaqueteTuristicoServicioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaqueteTuristicoServicioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoServicioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaqueteTuristicoServicioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoServicioPayload>
          }
          findFirst: {
            args: Prisma.PaqueteTuristicoServicioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoServicioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaqueteTuristicoServicioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoServicioPayload>
          }
          findMany: {
            args: Prisma.PaqueteTuristicoServicioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoServicioPayload>[]
          }
          create: {
            args: Prisma.PaqueteTuristicoServicioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoServicioPayload>
          }
          createMany: {
            args: Prisma.PaqueteTuristicoServicioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaqueteTuristicoServicioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoServicioPayload>[]
          }
          delete: {
            args: Prisma.PaqueteTuristicoServicioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoServicioPayload>
          }
          update: {
            args: Prisma.PaqueteTuristicoServicioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoServicioPayload>
          }
          deleteMany: {
            args: Prisma.PaqueteTuristicoServicioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaqueteTuristicoServicioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaqueteTuristicoServicioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoServicioPayload>[]
          }
          upsert: {
            args: Prisma.PaqueteTuristicoServicioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoServicioPayload>
          }
          aggregate: {
            args: Prisma.PaqueteTuristicoServicioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaqueteTuristicoServicio>
          }
          groupBy: {
            args: Prisma.PaqueteTuristicoServicioGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaqueteTuristicoServicioGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaqueteTuristicoServicioCountArgs<ExtArgs>
            result: $Utils.Optional<PaqueteTuristicoServicioCountAggregateOutputType> | number
          }
        }
      }
      PaqueteTuristico: {
        payload: Prisma.$PaqueteTuristicoPayload<ExtArgs>
        fields: Prisma.PaqueteTuristicoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaqueteTuristicoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaqueteTuristicoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoPayload>
          }
          findFirst: {
            args: Prisma.PaqueteTuristicoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaqueteTuristicoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoPayload>
          }
          findMany: {
            args: Prisma.PaqueteTuristicoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoPayload>[]
          }
          create: {
            args: Prisma.PaqueteTuristicoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoPayload>
          }
          createMany: {
            args: Prisma.PaqueteTuristicoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaqueteTuristicoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoPayload>[]
          }
          delete: {
            args: Prisma.PaqueteTuristicoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoPayload>
          }
          update: {
            args: Prisma.PaqueteTuristicoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoPayload>
          }
          deleteMany: {
            args: Prisma.PaqueteTuristicoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaqueteTuristicoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaqueteTuristicoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoPayload>[]
          }
          upsert: {
            args: Prisma.PaqueteTuristicoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaqueteTuristicoPayload>
          }
          aggregate: {
            args: Prisma.PaqueteTuristicoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaqueteTuristico>
          }
          groupBy: {
            args: Prisma.PaqueteTuristicoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaqueteTuristicoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaqueteTuristicoCountArgs<ExtArgs>
            result: $Utils.Optional<PaqueteTuristicoCountAggregateOutputType> | number
          }
        }
      }
      DisponibilidadPaquete: {
        payload: Prisma.$DisponibilidadPaquetePayload<ExtArgs>
        fields: Prisma.DisponibilidadPaqueteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisponibilidadPaqueteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibilidadPaquetePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisponibilidadPaqueteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibilidadPaquetePayload>
          }
          findFirst: {
            args: Prisma.DisponibilidadPaqueteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibilidadPaquetePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisponibilidadPaqueteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibilidadPaquetePayload>
          }
          findMany: {
            args: Prisma.DisponibilidadPaqueteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibilidadPaquetePayload>[]
          }
          create: {
            args: Prisma.DisponibilidadPaqueteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibilidadPaquetePayload>
          }
          createMany: {
            args: Prisma.DisponibilidadPaqueteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisponibilidadPaqueteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibilidadPaquetePayload>[]
          }
          delete: {
            args: Prisma.DisponibilidadPaqueteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibilidadPaquetePayload>
          }
          update: {
            args: Prisma.DisponibilidadPaqueteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibilidadPaquetePayload>
          }
          deleteMany: {
            args: Prisma.DisponibilidadPaqueteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisponibilidadPaqueteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisponibilidadPaqueteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibilidadPaquetePayload>[]
          }
          upsert: {
            args: Prisma.DisponibilidadPaqueteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibilidadPaquetePayload>
          }
          aggregate: {
            args: Prisma.DisponibilidadPaqueteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisponibilidadPaquete>
          }
          groupBy: {
            args: Prisma.DisponibilidadPaqueteGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisponibilidadPaqueteGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisponibilidadPaqueteCountArgs<ExtArgs>
            result: $Utils.Optional<DisponibilidadPaqueteCountAggregateOutputType> | number
          }
        }
      }
      TipoServicio: {
        payload: Prisma.$TipoServicioPayload<ExtArgs>
        fields: Prisma.TipoServicioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoServicioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoServicioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoServicioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoServicioPayload>
          }
          findFirst: {
            args: Prisma.TipoServicioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoServicioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoServicioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoServicioPayload>
          }
          findMany: {
            args: Prisma.TipoServicioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoServicioPayload>[]
          }
          create: {
            args: Prisma.TipoServicioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoServicioPayload>
          }
          createMany: {
            args: Prisma.TipoServicioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoServicioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoServicioPayload>[]
          }
          delete: {
            args: Prisma.TipoServicioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoServicioPayload>
          }
          update: {
            args: Prisma.TipoServicioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoServicioPayload>
          }
          deleteMany: {
            args: Prisma.TipoServicioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoServicioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoServicioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoServicioPayload>[]
          }
          upsert: {
            args: Prisma.TipoServicioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoServicioPayload>
          }
          aggregate: {
            args: Prisma.TipoServicioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoServicio>
          }
          groupBy: {
            args: Prisma.TipoServicioGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoServicioGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoServicioCountArgs<ExtArgs>
            result: $Utils.Optional<TipoServicioCountAggregateOutputType> | number
          }
        }
      }
      ServicioDisponibilidad: {
        payload: Prisma.$ServicioDisponibilidadPayload<ExtArgs>
        fields: Prisma.ServicioDisponibilidadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicioDisponibilidadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioDisponibilidadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicioDisponibilidadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioDisponibilidadPayload>
          }
          findFirst: {
            args: Prisma.ServicioDisponibilidadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioDisponibilidadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicioDisponibilidadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioDisponibilidadPayload>
          }
          findMany: {
            args: Prisma.ServicioDisponibilidadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioDisponibilidadPayload>[]
          }
          create: {
            args: Prisma.ServicioDisponibilidadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioDisponibilidadPayload>
          }
          createMany: {
            args: Prisma.ServicioDisponibilidadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicioDisponibilidadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioDisponibilidadPayload>[]
          }
          delete: {
            args: Prisma.ServicioDisponibilidadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioDisponibilidadPayload>
          }
          update: {
            args: Prisma.ServicioDisponibilidadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioDisponibilidadPayload>
          }
          deleteMany: {
            args: Prisma.ServicioDisponibilidadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicioDisponibilidadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServicioDisponibilidadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioDisponibilidadPayload>[]
          }
          upsert: {
            args: Prisma.ServicioDisponibilidadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicioDisponibilidadPayload>
          }
          aggregate: {
            args: Prisma.ServicioDisponibilidadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicioDisponibilidad>
          }
          groupBy: {
            args: Prisma.ServicioDisponibilidadGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicioDisponibilidadGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicioDisponibilidadCountArgs<ExtArgs>
            result: $Utils.Optional<ServicioDisponibilidadCountAggregateOutputType> | number
          }
        }
      }
      Resena: {
        payload: Prisma.$ResenaPayload<ExtArgs>
        fields: Prisma.ResenaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResenaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResenaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          findFirst: {
            args: Prisma.ResenaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResenaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          findMany: {
            args: Prisma.ResenaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>[]
          }
          create: {
            args: Prisma.ResenaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          createMany: {
            args: Prisma.ResenaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResenaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>[]
          }
          delete: {
            args: Prisma.ResenaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          update: {
            args: Prisma.ResenaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          deleteMany: {
            args: Prisma.ResenaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResenaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResenaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>[]
          }
          upsert: {
            args: Prisma.ResenaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          aggregate: {
            args: Prisma.ResenaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResena>
          }
          groupBy: {
            args: Prisma.ResenaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResenaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResenaCountArgs<ExtArgs>
            result: $Utils.Optional<ResenaCountAggregateOutputType> | number
          }
        }
      }
      Favorito: {
        payload: Prisma.$FavoritoPayload<ExtArgs>
        fields: Prisma.FavoritoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoritoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoritoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>
          }
          findFirst: {
            args: Prisma.FavoritoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoritoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>
          }
          findMany: {
            args: Prisma.FavoritoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>[]
          }
          create: {
            args: Prisma.FavoritoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>
          }
          createMany: {
            args: Prisma.FavoritoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoritoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>[]
          }
          delete: {
            args: Prisma.FavoritoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>
          }
          update: {
            args: Prisma.FavoritoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>
          }
          deleteMany: {
            args: Prisma.FavoritoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoritoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavoritoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>[]
          }
          upsert: {
            args: Prisma.FavoritoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritoPayload>
          }
          aggregate: {
            args: Prisma.FavoritoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorito>
          }
          groupBy: {
            args: Prisma.FavoritoGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoritoGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoritoCountArgs<ExtArgs>
            result: $Utils.Optional<FavoritoCountAggregateOutputType> | number
          }
        }
      }
      Reserva: {
        payload: Prisma.$ReservaPayload<ExtArgs>
        fields: Prisma.ReservaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          findFirst: {
            args: Prisma.ReservaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          findMany: {
            args: Prisma.ReservaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>[]
          }
          create: {
            args: Prisma.ReservaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          createMany: {
            args: Prisma.ReservaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>[]
          }
          delete: {
            args: Prisma.ReservaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          update: {
            args: Prisma.ReservaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          deleteMany: {
            args: Prisma.ReservaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReservaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>[]
          }
          upsert: {
            args: Prisma.ReservaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          aggregate: {
            args: Prisma.ReservaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReserva>
          }
          groupBy: {
            args: Prisma.ReservaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservaCountArgs<ExtArgs>
            result: $Utils.Optional<ReservaCountAggregateOutputType> | number
          }
        }
      }
      ItinerarioReserva: {
        payload: Prisma.$ItinerarioReservaPayload<ExtArgs>
        fields: Prisma.ItinerarioReservaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItinerarioReservaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioReservaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItinerarioReservaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioReservaPayload>
          }
          findFirst: {
            args: Prisma.ItinerarioReservaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioReservaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItinerarioReservaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioReservaPayload>
          }
          findMany: {
            args: Prisma.ItinerarioReservaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioReservaPayload>[]
          }
          create: {
            args: Prisma.ItinerarioReservaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioReservaPayload>
          }
          createMany: {
            args: Prisma.ItinerarioReservaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItinerarioReservaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioReservaPayload>[]
          }
          delete: {
            args: Prisma.ItinerarioReservaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioReservaPayload>
          }
          update: {
            args: Prisma.ItinerarioReservaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioReservaPayload>
          }
          deleteMany: {
            args: Prisma.ItinerarioReservaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItinerarioReservaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItinerarioReservaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioReservaPayload>[]
          }
          upsert: {
            args: Prisma.ItinerarioReservaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioReservaPayload>
          }
          aggregate: {
            args: Prisma.ItinerarioReservaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItinerarioReserva>
          }
          groupBy: {
            args: Prisma.ItinerarioReservaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItinerarioReservaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItinerarioReservaCountArgs<ExtArgs>
            result: $Utils.Optional<ItinerarioReservaCountAggregateOutputType> | number
          }
        }
      }
      ItinerarioLugar: {
        payload: Prisma.$ItinerarioLugarPayload<ExtArgs>
        fields: Prisma.ItinerarioLugarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItinerarioLugarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioLugarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItinerarioLugarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioLugarPayload>
          }
          findFirst: {
            args: Prisma.ItinerarioLugarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioLugarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItinerarioLugarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioLugarPayload>
          }
          findMany: {
            args: Prisma.ItinerarioLugarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioLugarPayload>[]
          }
          create: {
            args: Prisma.ItinerarioLugarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioLugarPayload>
          }
          createMany: {
            args: Prisma.ItinerarioLugarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItinerarioLugarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioLugarPayload>[]
          }
          delete: {
            args: Prisma.ItinerarioLugarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioLugarPayload>
          }
          update: {
            args: Prisma.ItinerarioLugarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioLugarPayload>
          }
          deleteMany: {
            args: Prisma.ItinerarioLugarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItinerarioLugarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ItinerarioLugarUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioLugarPayload>[]
          }
          upsert: {
            args: Prisma.ItinerarioLugarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItinerarioLugarPayload>
          }
          aggregate: {
            args: Prisma.ItinerarioLugarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItinerarioLugar>
          }
          groupBy: {
            args: Prisma.ItinerarioLugarGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItinerarioLugarGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItinerarioLugarCountArgs<ExtArgs>
            result: $Utils.Optional<ItinerarioLugarCountAggregateOutputType> | number
          }
        }
      }
      Pago: {
        payload: Prisma.$PagoPayload<ExtArgs>
        fields: Prisma.PagoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          findFirst: {
            args: Prisma.PagoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          findMany: {
            args: Prisma.PagoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>[]
          }
          create: {
            args: Prisma.PagoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          createMany: {
            args: Prisma.PagoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PagoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>[]
          }
          delete: {
            args: Prisma.PagoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          update: {
            args: Prisma.PagoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          deleteMany: {
            args: Prisma.PagoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PagoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>[]
          }
          upsert: {
            args: Prisma.PagoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoPayload>
          }
          aggregate: {
            args: Prisma.PagoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePago>
          }
          groupBy: {
            args: Prisma.PagoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagoCountArgs<ExtArgs>
            result: $Utils.Optional<PagoCountAggregateOutputType> | number
          }
        }
      }
      PagoDetalle: {
        payload: Prisma.$PagoDetallePayload<ExtArgs>
        fields: Prisma.PagoDetalleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagoDetalleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDetallePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagoDetalleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDetallePayload>
          }
          findFirst: {
            args: Prisma.PagoDetalleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDetallePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagoDetalleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDetallePayload>
          }
          findMany: {
            args: Prisma.PagoDetalleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDetallePayload>[]
          }
          create: {
            args: Prisma.PagoDetalleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDetallePayload>
          }
          createMany: {
            args: Prisma.PagoDetalleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PagoDetalleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDetallePayload>[]
          }
          delete: {
            args: Prisma.PagoDetalleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDetallePayload>
          }
          update: {
            args: Prisma.PagoDetalleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDetallePayload>
          }
          deleteMany: {
            args: Prisma.PagoDetalleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagoDetalleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PagoDetalleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDetallePayload>[]
          }
          upsert: {
            args: Prisma.PagoDetalleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagoDetallePayload>
          }
          aggregate: {
            args: Prisma.PagoDetalleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagoDetalle>
          }
          groupBy: {
            args: Prisma.PagoDetalleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagoDetalleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagoDetalleCountArgs<ExtArgs>
            result: $Utils.Optional<PagoDetalleCountAggregateOutputType> | number
          }
        }
      }
      TipoPago: {
        payload: Prisma.$TipoPagoPayload<ExtArgs>
        fields: Prisma.TipoPagoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoPagoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoPagoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoPagoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoPagoPayload>
          }
          findFirst: {
            args: Prisma.TipoPagoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoPagoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoPagoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoPagoPayload>
          }
          findMany: {
            args: Prisma.TipoPagoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoPagoPayload>[]
          }
          create: {
            args: Prisma.TipoPagoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoPagoPayload>
          }
          createMany: {
            args: Prisma.TipoPagoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoPagoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoPagoPayload>[]
          }
          delete: {
            args: Prisma.TipoPagoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoPagoPayload>
          }
          update: {
            args: Prisma.TipoPagoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoPagoPayload>
          }
          deleteMany: {
            args: Prisma.TipoPagoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoPagoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoPagoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoPagoPayload>[]
          }
          upsert: {
            args: Prisma.TipoPagoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoPagoPayload>
          }
          aggregate: {
            args: Prisma.TipoPagoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoPago>
          }
          groupBy: {
            args: Prisma.TipoPagoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoPagoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoPagoCountArgs<ExtArgs>
            result: $Utils.Optional<TipoPagoCountAggregateOutputType> | number
          }
        }
      }
      Comprobante: {
        payload: Prisma.$ComprobantePayload<ExtArgs>
        fields: Prisma.ComprobanteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComprobanteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComprobanteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>
          }
          findFirst: {
            args: Prisma.ComprobanteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComprobanteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>
          }
          findMany: {
            args: Prisma.ComprobanteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>[]
          }
          create: {
            args: Prisma.ComprobanteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>
          }
          createMany: {
            args: Prisma.ComprobanteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComprobanteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>[]
          }
          delete: {
            args: Prisma.ComprobanteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>
          }
          update: {
            args: Prisma.ComprobanteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>
          }
          deleteMany: {
            args: Prisma.ComprobanteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComprobanteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComprobanteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>[]
          }
          upsert: {
            args: Prisma.ComprobanteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprobantePayload>
          }
          aggregate: {
            args: Prisma.ComprobanteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComprobante>
          }
          groupBy: {
            args: Prisma.ComprobanteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComprobanteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComprobanteCountArgs<ExtArgs>
            result: $Utils.Optional<ComprobanteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    role?: RoleOmit
    permiso?: PermisoOmit
    rolesPermisos?: RolesPermisosOmit
    country?: CountryOmit
    subdivision?: SubdivisionOmit
    persona?: PersonaOmit
    usuario?: UsuarioOmit
    usuariosRoles?: UsuariosRolesOmit
    emprendimiento?: EmprendimientoOmit
    registroAcceso?: RegistroAccesoOmit
    tokenInvalidado?: TokenInvalidadoOmit
    turista?: TuristaOmit
    lugarTuristico?: LugarTuristicoOmit
    servicioEmprendedor?: ServicioEmprendedorOmit
    servicio?: ServicioOmit
    paqueteTuristicoServicio?: PaqueteTuristicoServicioOmit
    paqueteTuristico?: PaqueteTuristicoOmit
    disponibilidadPaquete?: DisponibilidadPaqueteOmit
    tipoServicio?: TipoServicioOmit
    servicioDisponibilidad?: ServicioDisponibilidadOmit
    resena?: ResenaOmit
    favorito?: FavoritoOmit
    reserva?: ReservaOmit
    itinerarioReserva?: ItinerarioReservaOmit
    itinerarioLugar?: ItinerarioLugarOmit
    pago?: PagoOmit
    pagoDetalle?: PagoDetalleOmit
    tipoPago?: TipoPagoOmit
    comprobante?: ComprobanteOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    rolesPermisos: number
    usuariosRoles: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolesPermisos?: boolean | RoleCountOutputTypeCountRolesPermisosArgs
    usuariosRoles?: boolean | RoleCountOutputTypeCountUsuariosRolesArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountRolesPermisosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesPermisosWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsuariosRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuariosRolesWhereInput
  }


  /**
   * Count Type PermisoCountOutputType
   */

  export type PermisoCountOutputType = {
    rolesPermisos: number
  }

  export type PermisoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolesPermisos?: boolean | PermisoCountOutputTypeCountRolesPermisosArgs
  }

  // Custom InputTypes
  /**
   * PermisoCountOutputType without action
   */
  export type PermisoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermisoCountOutputType
     */
    select?: PermisoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermisoCountOutputType without action
   */
  export type PermisoCountOutputTypeCountRolesPermisosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesPermisosWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    subdivisions: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subdivisions?: boolean | CountryCountOutputTypeCountSubdivisionsArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountSubdivisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubdivisionWhereInput
  }


  /**
   * Count Type SubdivisionCountOutputType
   */

  export type SubdivisionCountOutputType = {
    emprendimientos: number
    personas: number
  }

  export type SubdivisionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimientos?: boolean | SubdivisionCountOutputTypeCountEmprendimientosArgs
    personas?: boolean | SubdivisionCountOutputTypeCountPersonasArgs
  }

  // Custom InputTypes
  /**
   * SubdivisionCountOutputType without action
   */
  export type SubdivisionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubdivisionCountOutputType
     */
    select?: SubdivisionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubdivisionCountOutputType without action
   */
  export type SubdivisionCountOutputTypeCountEmprendimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmprendimientoWhereInput
  }

  /**
   * SubdivisionCountOutputType without action
   */
  export type SubdivisionCountOutputTypeCountPersonasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonaWhereInput
  }


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    emprendimientos: number
    favoritos: number
    registroAccesos: number
    resenas: number
    tokensInvalidados: number
    usuariosRoles: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimientos?: boolean | UsuarioCountOutputTypeCountEmprendimientosArgs
    favoritos?: boolean | UsuarioCountOutputTypeCountFavoritosArgs
    registroAccesos?: boolean | UsuarioCountOutputTypeCountRegistroAccesosArgs
    resenas?: boolean | UsuarioCountOutputTypeCountResenasArgs
    tokensInvalidados?: boolean | UsuarioCountOutputTypeCountTokensInvalidadosArgs
    usuariosRoles?: boolean | UsuarioCountOutputTypeCountUsuariosRolesArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountEmprendimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmprendimientoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountFavoritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoritoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountRegistroAccesosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistroAccesoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountResenasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResenaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountTokensInvalidadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenInvalidadoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountUsuariosRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuariosRolesWhereInput
  }


  /**
   * Count Type EmprendimientoCountOutputType
   */

  export type EmprendimientoCountOutputType = {
    favoritos: number
    paquetesTuristicos: number
    servicios: number
  }

  export type EmprendimientoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    favoritos?: boolean | EmprendimientoCountOutputTypeCountFavoritosArgs
    paquetesTuristicos?: boolean | EmprendimientoCountOutputTypeCountPaquetesTuristicosArgs
    servicios?: boolean | EmprendimientoCountOutputTypeCountServiciosArgs
  }

  // Custom InputTypes
  /**
   * EmprendimientoCountOutputType without action
   */
  export type EmprendimientoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprendimientoCountOutputType
     */
    select?: EmprendimientoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmprendimientoCountOutputType without action
   */
  export type EmprendimientoCountOutputTypeCountFavoritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoritoWhereInput
  }

  /**
   * EmprendimientoCountOutputType without action
   */
  export type EmprendimientoCountOutputTypeCountPaquetesTuristicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaqueteTuristicoWhereInput
  }

  /**
   * EmprendimientoCountOutputType without action
   */
  export type EmprendimientoCountOutputTypeCountServiciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioEmprendedorWhereInput
  }


  /**
   * Count Type TuristaCountOutputType
   */

  export type TuristaCountOutputType = {
    reservas: number
  }

  export type TuristaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservas?: boolean | TuristaCountOutputTypeCountReservasArgs
  }

  // Custom InputTypes
  /**
   * TuristaCountOutputType without action
   */
  export type TuristaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TuristaCountOutputType
     */
    select?: TuristaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TuristaCountOutputType without action
   */
  export type TuristaCountOutputTypeCountReservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservaWhereInput
  }


  /**
   * Count Type LugarTuristicoCountOutputType
   */

  export type LugarTuristicoCountOutputType = {
    itinerarioLugares: number
  }

  export type LugarTuristicoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerarioLugares?: boolean | LugarTuristicoCountOutputTypeCountItinerarioLugaresArgs
  }

  // Custom InputTypes
  /**
   * LugarTuristicoCountOutputType without action
   */
  export type LugarTuristicoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LugarTuristicoCountOutputType
     */
    select?: LugarTuristicoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LugarTuristicoCountOutputType without action
   */
  export type LugarTuristicoCountOutputTypeCountItinerarioLugaresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItinerarioLugarWhereInput
  }


  /**
   * Count Type ServicioCountOutputType
   */

  export type ServicioCountOutputType = {
    itinerariosReserva: number
    paquetesServicios: number
    disponibilidad: number
    serviciosEmprendedores: number
  }

  export type ServicioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerariosReserva?: boolean | ServicioCountOutputTypeCountItinerariosReservaArgs
    paquetesServicios?: boolean | ServicioCountOutputTypeCountPaquetesServiciosArgs
    disponibilidad?: boolean | ServicioCountOutputTypeCountDisponibilidadArgs
    serviciosEmprendedores?: boolean | ServicioCountOutputTypeCountServiciosEmprendedoresArgs
  }

  // Custom InputTypes
  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioCountOutputType
     */
    select?: ServicioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeCountItinerariosReservaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItinerarioReservaWhereInput
  }

  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeCountPaquetesServiciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaqueteTuristicoServicioWhereInput
  }

  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeCountDisponibilidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioDisponibilidadWhereInput
  }

  /**
   * ServicioCountOutputType without action
   */
  export type ServicioCountOutputTypeCountServiciosEmprendedoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioEmprendedorWhereInput
  }


  /**
   * Count Type PaqueteTuristicoCountOutputType
   */

  export type PaqueteTuristicoCountOutputType = {
    disponibilidad: number
    servicios: number
  }

  export type PaqueteTuristicoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disponibilidad?: boolean | PaqueteTuristicoCountOutputTypeCountDisponibilidadArgs
    servicios?: boolean | PaqueteTuristicoCountOutputTypeCountServiciosArgs
  }

  // Custom InputTypes
  /**
   * PaqueteTuristicoCountOutputType without action
   */
  export type PaqueteTuristicoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoCountOutputType
     */
    select?: PaqueteTuristicoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaqueteTuristicoCountOutputType without action
   */
  export type PaqueteTuristicoCountOutputTypeCountDisponibilidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisponibilidadPaqueteWhereInput
  }

  /**
   * PaqueteTuristicoCountOutputType without action
   */
  export type PaqueteTuristicoCountOutputTypeCountServiciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaqueteTuristicoServicioWhereInput
  }


  /**
   * Count Type TipoServicioCountOutputType
   */

  export type TipoServicioCountOutputType = {
    servicios: number
  }

  export type TipoServicioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicios?: boolean | TipoServicioCountOutputTypeCountServiciosArgs
  }

  // Custom InputTypes
  /**
   * TipoServicioCountOutputType without action
   */
  export type TipoServicioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoServicioCountOutputType
     */
    select?: TipoServicioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoServicioCountOutputType without action
   */
  export type TipoServicioCountOutputTypeCountServiciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioWhereInput
  }


  /**
   * Count Type ReservaCountOutputType
   */

  export type ReservaCountOutputType = {
    itinerarios: number
    pagos: number
  }

  export type ReservaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerarios?: boolean | ReservaCountOutputTypeCountItinerariosArgs
    pagos?: boolean | ReservaCountOutputTypeCountPagosArgs
  }

  // Custom InputTypes
  /**
   * ReservaCountOutputType without action
   */
  export type ReservaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservaCountOutputType
     */
    select?: ReservaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReservaCountOutputType without action
   */
  export type ReservaCountOutputTypeCountItinerariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItinerarioReservaWhereInput
  }

  /**
   * ReservaCountOutputType without action
   */
  export type ReservaCountOutputTypeCountPagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoWhereInput
  }


  /**
   * Count Type ItinerarioReservaCountOutputType
   */

  export type ItinerarioReservaCountOutputType = {
    itinerarioLugares: number
  }

  export type ItinerarioReservaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerarioLugares?: boolean | ItinerarioReservaCountOutputTypeCountItinerarioLugaresArgs
  }

  // Custom InputTypes
  /**
   * ItinerarioReservaCountOutputType without action
   */
  export type ItinerarioReservaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReservaCountOutputType
     */
    select?: ItinerarioReservaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItinerarioReservaCountOutputType without action
   */
  export type ItinerarioReservaCountOutputTypeCountItinerarioLugaresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItinerarioLugarWhereInput
  }


  /**
   * Count Type PagoCountOutputType
   */

  export type PagoCountOutputType = {
    detalles: number
  }

  export type PagoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detalles?: boolean | PagoCountOutputTypeCountDetallesArgs
  }

  // Custom InputTypes
  /**
   * PagoCountOutputType without action
   */
  export type PagoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoCountOutputType
     */
    select?: PagoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PagoCountOutputType without action
   */
  export type PagoCountOutputTypeCountDetallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoDetalleWhereInput
  }


  /**
   * Count Type TipoPagoCountOutputType
   */

  export type TipoPagoCountOutputType = {
    pagoDetalles: number
  }

  export type TipoPagoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagoDetalles?: boolean | TipoPagoCountOutputTypeCountPagoDetallesArgs
  }

  // Custom InputTypes
  /**
   * TipoPagoCountOutputType without action
   */
  export type TipoPagoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPagoCountOutputType
     */
    select?: TipoPagoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoPagoCountOutputType without action
   */
  export type TipoPagoCountOutputTypeCountPagoDetallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoDetalleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rolesPermisos?: boolean | Role$rolesPermisosArgs<ExtArgs>
    usuariosRoles?: boolean | Role$usuariosRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolesPermisos?: boolean | Role$rolesPermisosArgs<ExtArgs>
    usuariosRoles?: boolean | Role$usuariosRolesArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      rolesPermisos: Prisma.$RolesPermisosPayload<ExtArgs>[]
      usuariosRoles: Prisma.$UsuariosRolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolesPermisos<T extends Role$rolesPermisosArgs<ExtArgs> = {}>(args?: Subset<T, Role$rolesPermisosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPermisosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuariosRoles<T extends Role$usuariosRolesArgs<ExtArgs> = {}>(args?: Subset<T, Role$usuariosRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly nombre: FieldRef<"Role", 'String'>
    readonly descripcion: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.rolesPermisos
   */
  export type Role$rolesPermisosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosInclude<ExtArgs> | null
    where?: RolesPermisosWhereInput
    orderBy?: RolesPermisosOrderByWithRelationInput | RolesPermisosOrderByWithRelationInput[]
    cursor?: RolesPermisosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolesPermisosScalarFieldEnum | RolesPermisosScalarFieldEnum[]
  }

  /**
   * Role.usuariosRoles
   */
  export type Role$usuariosRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesInclude<ExtArgs> | null
    where?: UsuariosRolesWhereInput
    orderBy?: UsuariosRolesOrderByWithRelationInput | UsuariosRolesOrderByWithRelationInput[]
    cursor?: UsuariosRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuariosRolesScalarFieldEnum | UsuariosRolesScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permiso
   */

  export type AggregatePermiso = {
    _count: PermisoCountAggregateOutputType | null
    _avg: PermisoAvgAggregateOutputType | null
    _sum: PermisoSumAggregateOutputType | null
    _min: PermisoMinAggregateOutputType | null
    _max: PermisoMaxAggregateOutputType | null
  }

  export type PermisoAvgAggregateOutputType = {
    id: number | null
  }

  export type PermisoSumAggregateOutputType = {
    id: number | null
  }

  export type PermisoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermisoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermisoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermisoAvgAggregateInputType = {
    id?: true
  }

  export type PermisoSumAggregateInputType = {
    id?: true
  }

  export type PermisoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermisoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermisoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermisoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permiso to aggregate.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permisos
    **/
    _count?: true | PermisoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermisoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermisoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermisoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermisoMaxAggregateInputType
  }

  export type GetPermisoAggregateType<T extends PermisoAggregateArgs> = {
        [P in keyof T & keyof AggregatePermiso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermiso[P]>
      : GetScalarType<T[P], AggregatePermiso[P]>
  }




  export type PermisoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermisoWhereInput
    orderBy?: PermisoOrderByWithAggregationInput | PermisoOrderByWithAggregationInput[]
    by: PermisoScalarFieldEnum[] | PermisoScalarFieldEnum
    having?: PermisoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermisoCountAggregateInputType | true
    _avg?: PermisoAvgAggregateInputType
    _sum?: PermisoSumAggregateInputType
    _min?: PermisoMinAggregateInputType
    _max?: PermisoMaxAggregateInputType
  }

  export type PermisoGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    createdAt: Date
    updatedAt: Date
    _count: PermisoCountAggregateOutputType | null
    _avg: PermisoAvgAggregateOutputType | null
    _sum: PermisoSumAggregateOutputType | null
    _min: PermisoMinAggregateOutputType | null
    _max: PermisoMaxAggregateOutputType | null
  }

  type GetPermisoGroupByPayload<T extends PermisoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermisoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermisoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermisoGroupByOutputType[P]>
            : GetScalarType<T[P], PermisoGroupByOutputType[P]>
        }
      >
    >


  export type PermisoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rolesPermisos?: boolean | Permiso$rolesPermisosArgs<ExtArgs>
    _count?: boolean | PermisoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permiso"]>

  export type PermisoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permiso"]>

  export type PermisoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["permiso"]>

  export type PermisoSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermisoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "createdAt" | "updatedAt", ExtArgs["result"]["permiso"]>
  export type PermisoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolesPermisos?: boolean | Permiso$rolesPermisosArgs<ExtArgs>
    _count?: boolean | PermisoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermisoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermisoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermisoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permiso"
    objects: {
      rolesPermisos: Prisma.$RolesPermisosPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permiso"]>
    composites: {}
  }

  type PermisoGetPayload<S extends boolean | null | undefined | PermisoDefaultArgs> = $Result.GetResult<Prisma.$PermisoPayload, S>

  type PermisoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermisoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermisoCountAggregateInputType | true
    }

  export interface PermisoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permiso'], meta: { name: 'Permiso' } }
    /**
     * Find zero or one Permiso that matches the filter.
     * @param {PermisoFindUniqueArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermisoFindUniqueArgs>(args: SelectSubset<T, PermisoFindUniqueArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permiso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermisoFindUniqueOrThrowArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermisoFindUniqueOrThrowArgs>(args: SelectSubset<T, PermisoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permiso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoFindFirstArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermisoFindFirstArgs>(args?: SelectSubset<T, PermisoFindFirstArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permiso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoFindFirstOrThrowArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermisoFindFirstOrThrowArgs>(args?: SelectSubset<T, PermisoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permisos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permisos
     * const permisos = await prisma.permiso.findMany()
     * 
     * // Get first 10 Permisos
     * const permisos = await prisma.permiso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permisoWithIdOnly = await prisma.permiso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermisoFindManyArgs>(args?: SelectSubset<T, PermisoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permiso.
     * @param {PermisoCreateArgs} args - Arguments to create a Permiso.
     * @example
     * // Create one Permiso
     * const Permiso = await prisma.permiso.create({
     *   data: {
     *     // ... data to create a Permiso
     *   }
     * })
     * 
     */
    create<T extends PermisoCreateArgs>(args: SelectSubset<T, PermisoCreateArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permisos.
     * @param {PermisoCreateManyArgs} args - Arguments to create many Permisos.
     * @example
     * // Create many Permisos
     * const permiso = await prisma.permiso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermisoCreateManyArgs>(args?: SelectSubset<T, PermisoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permisos and returns the data saved in the database.
     * @param {PermisoCreateManyAndReturnArgs} args - Arguments to create many Permisos.
     * @example
     * // Create many Permisos
     * const permiso = await prisma.permiso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permisos and only return the `id`
     * const permisoWithIdOnly = await prisma.permiso.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermisoCreateManyAndReturnArgs>(args?: SelectSubset<T, PermisoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permiso.
     * @param {PermisoDeleteArgs} args - Arguments to delete one Permiso.
     * @example
     * // Delete one Permiso
     * const Permiso = await prisma.permiso.delete({
     *   where: {
     *     // ... filter to delete one Permiso
     *   }
     * })
     * 
     */
    delete<T extends PermisoDeleteArgs>(args: SelectSubset<T, PermisoDeleteArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permiso.
     * @param {PermisoUpdateArgs} args - Arguments to update one Permiso.
     * @example
     * // Update one Permiso
     * const permiso = await prisma.permiso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermisoUpdateArgs>(args: SelectSubset<T, PermisoUpdateArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permisos.
     * @param {PermisoDeleteManyArgs} args - Arguments to filter Permisos to delete.
     * @example
     * // Delete a few Permisos
     * const { count } = await prisma.permiso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermisoDeleteManyArgs>(args?: SelectSubset<T, PermisoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permisos
     * const permiso = await prisma.permiso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermisoUpdateManyArgs>(args: SelectSubset<T, PermisoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permisos and returns the data updated in the database.
     * @param {PermisoUpdateManyAndReturnArgs} args - Arguments to update many Permisos.
     * @example
     * // Update many Permisos
     * const permiso = await prisma.permiso.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permisos and only return the `id`
     * const permisoWithIdOnly = await prisma.permiso.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermisoUpdateManyAndReturnArgs>(args: SelectSubset<T, PermisoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permiso.
     * @param {PermisoUpsertArgs} args - Arguments to update or create a Permiso.
     * @example
     * // Update or create a Permiso
     * const permiso = await prisma.permiso.upsert({
     *   create: {
     *     // ... data to create a Permiso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permiso we want to update
     *   }
     * })
     */
    upsert<T extends PermisoUpsertArgs>(args: SelectSubset<T, PermisoUpsertArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoCountArgs} args - Arguments to filter Permisos to count.
     * @example
     * // Count the number of Permisos
     * const count = await prisma.permiso.count({
     *   where: {
     *     // ... the filter for the Permisos we want to count
     *   }
     * })
    **/
    count<T extends PermisoCountArgs>(
      args?: Subset<T, PermisoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermisoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermisoAggregateArgs>(args: Subset<T, PermisoAggregateArgs>): Prisma.PrismaPromise<GetPermisoAggregateType<T>>

    /**
     * Group by Permiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermisoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermisoGroupByArgs['orderBy'] }
        : { orderBy?: PermisoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermisoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermisoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permiso model
   */
  readonly fields: PermisoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permiso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermisoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rolesPermisos<T extends Permiso$rolesPermisosArgs<ExtArgs> = {}>(args?: Subset<T, Permiso$rolesPermisosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPermisosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permiso model
   */
  interface PermisoFieldRefs {
    readonly id: FieldRef<"Permiso", 'Int'>
    readonly nombre: FieldRef<"Permiso", 'String'>
    readonly descripcion: FieldRef<"Permiso", 'String'>
    readonly createdAt: FieldRef<"Permiso", 'DateTime'>
    readonly updatedAt: FieldRef<"Permiso", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permiso findUnique
   */
  export type PermisoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where: PermisoWhereUniqueInput
  }

  /**
   * Permiso findUniqueOrThrow
   */
  export type PermisoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where: PermisoWhereUniqueInput
  }

  /**
   * Permiso findFirst
   */
  export type PermisoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permisos.
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permisos.
     */
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }

  /**
   * Permiso findFirstOrThrow
   */
  export type PermisoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permisos.
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permisos.
     */
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }

  /**
   * Permiso findMany
   */
  export type PermisoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter, which Permisos to fetch.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permisos.
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }

  /**
   * Permiso create
   */
  export type PermisoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * The data needed to create a Permiso.
     */
    data: XOR<PermisoCreateInput, PermisoUncheckedCreateInput>
  }

  /**
   * Permiso createMany
   */
  export type PermisoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permisos.
     */
    data: PermisoCreateManyInput | PermisoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permiso createManyAndReturn
   */
  export type PermisoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * The data used to create many Permisos.
     */
    data: PermisoCreateManyInput | PermisoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permiso update
   */
  export type PermisoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * The data needed to update a Permiso.
     */
    data: XOR<PermisoUpdateInput, PermisoUncheckedUpdateInput>
    /**
     * Choose, which Permiso to update.
     */
    where: PermisoWhereUniqueInput
  }

  /**
   * Permiso updateMany
   */
  export type PermisoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permisos.
     */
    data: XOR<PermisoUpdateManyMutationInput, PermisoUncheckedUpdateManyInput>
    /**
     * Filter which Permisos to update
     */
    where?: PermisoWhereInput
    /**
     * Limit how many Permisos to update.
     */
    limit?: number
  }

  /**
   * Permiso updateManyAndReturn
   */
  export type PermisoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * The data used to update Permisos.
     */
    data: XOR<PermisoUpdateManyMutationInput, PermisoUncheckedUpdateManyInput>
    /**
     * Filter which Permisos to update
     */
    where?: PermisoWhereInput
    /**
     * Limit how many Permisos to update.
     */
    limit?: number
  }

  /**
   * Permiso upsert
   */
  export type PermisoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * The filter to search for the Permiso to update in case it exists.
     */
    where: PermisoWhereUniqueInput
    /**
     * In case the Permiso found by the `where` argument doesn't exist, create a new Permiso with this data.
     */
    create: XOR<PermisoCreateInput, PermisoUncheckedCreateInput>
    /**
     * In case the Permiso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermisoUpdateInput, PermisoUncheckedUpdateInput>
  }

  /**
   * Permiso delete
   */
  export type PermisoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
    /**
     * Filter which Permiso to delete.
     */
    where: PermisoWhereUniqueInput
  }

  /**
   * Permiso deleteMany
   */
  export type PermisoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permisos to delete
     */
    where?: PermisoWhereInput
    /**
     * Limit how many Permisos to delete.
     */
    limit?: number
  }

  /**
   * Permiso.rolesPermisos
   */
  export type Permiso$rolesPermisosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosInclude<ExtArgs> | null
    where?: RolesPermisosWhereInput
    orderBy?: RolesPermisosOrderByWithRelationInput | RolesPermisosOrderByWithRelationInput[]
    cursor?: RolesPermisosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolesPermisosScalarFieldEnum | RolesPermisosScalarFieldEnum[]
  }

  /**
   * Permiso without action
   */
  export type PermisoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permiso
     */
    omit?: PermisoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermisoInclude<ExtArgs> | null
  }


  /**
   * Model RolesPermisos
   */

  export type AggregateRolesPermisos = {
    _count: RolesPermisosCountAggregateOutputType | null
    _avg: RolesPermisosAvgAggregateOutputType | null
    _sum: RolesPermisosSumAggregateOutputType | null
    _min: RolesPermisosMinAggregateOutputType | null
    _max: RolesPermisosMaxAggregateOutputType | null
  }

  export type RolesPermisosAvgAggregateOutputType = {
    id: number | null
    rolId: number | null
    permisoId: number | null
  }

  export type RolesPermisosSumAggregateOutputType = {
    id: number | null
    rolId: number | null
    permisoId: number | null
  }

  export type RolesPermisosMinAggregateOutputType = {
    id: number | null
    rolId: number | null
    permisoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolesPermisosMaxAggregateOutputType = {
    id: number | null
    rolId: number | null
    permisoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolesPermisosCountAggregateOutputType = {
    id: number
    rolId: number
    permisoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RolesPermisosAvgAggregateInputType = {
    id?: true
    rolId?: true
    permisoId?: true
  }

  export type RolesPermisosSumAggregateInputType = {
    id?: true
    rolId?: true
    permisoId?: true
  }

  export type RolesPermisosMinAggregateInputType = {
    id?: true
    rolId?: true
    permisoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolesPermisosMaxAggregateInputType = {
    id?: true
    rolId?: true
    permisoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolesPermisosCountAggregateInputType = {
    id?: true
    rolId?: true
    permisoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RolesPermisosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolesPermisos to aggregate.
     */
    where?: RolesPermisosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolesPermisos to fetch.
     */
    orderBy?: RolesPermisosOrderByWithRelationInput | RolesPermisosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesPermisosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolesPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolesPermisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolesPermisos
    **/
    _count?: true | RolesPermisosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesPermisosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesPermisosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesPermisosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesPermisosMaxAggregateInputType
  }

  export type GetRolesPermisosAggregateType<T extends RolesPermisosAggregateArgs> = {
        [P in keyof T & keyof AggregateRolesPermisos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolesPermisos[P]>
      : GetScalarType<T[P], AggregateRolesPermisos[P]>
  }




  export type RolesPermisosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesPermisosWhereInput
    orderBy?: RolesPermisosOrderByWithAggregationInput | RolesPermisosOrderByWithAggregationInput[]
    by: RolesPermisosScalarFieldEnum[] | RolesPermisosScalarFieldEnum
    having?: RolesPermisosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesPermisosCountAggregateInputType | true
    _avg?: RolesPermisosAvgAggregateInputType
    _sum?: RolesPermisosSumAggregateInputType
    _min?: RolesPermisosMinAggregateInputType
    _max?: RolesPermisosMaxAggregateInputType
  }

  export type RolesPermisosGroupByOutputType = {
    id: number
    rolId: number
    permisoId: number
    createdAt: Date
    updatedAt: Date
    _count: RolesPermisosCountAggregateOutputType | null
    _avg: RolesPermisosAvgAggregateOutputType | null
    _sum: RolesPermisosSumAggregateOutputType | null
    _min: RolesPermisosMinAggregateOutputType | null
    _max: RolesPermisosMaxAggregateOutputType | null
  }

  type GetRolesPermisosGroupByPayload<T extends RolesPermisosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesPermisosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesPermisosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesPermisosGroupByOutputType[P]>
            : GetScalarType<T[P], RolesPermisosGroupByOutputType[P]>
        }
      >
    >


  export type RolesPermisosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rolId?: boolean
    permisoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
    rol?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolesPermisos"]>

  export type RolesPermisosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rolId?: boolean
    permisoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
    rol?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolesPermisos"]>

  export type RolesPermisosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rolId?: boolean
    permisoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
    rol?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolesPermisos"]>

  export type RolesPermisosSelectScalar = {
    id?: boolean
    rolId?: boolean
    permisoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RolesPermisosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rolId" | "permisoId" | "createdAt" | "updatedAt", ExtArgs["result"]["rolesPermisos"]>
  export type RolesPermisosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
    rol?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type RolesPermisosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
    rol?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type RolesPermisosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permiso?: boolean | PermisoDefaultArgs<ExtArgs>
    rol?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $RolesPermisosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolesPermisos"
    objects: {
      permiso: Prisma.$PermisoPayload<ExtArgs>
      rol: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rolId: number
      permisoId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rolesPermisos"]>
    composites: {}
  }

  type RolesPermisosGetPayload<S extends boolean | null | undefined | RolesPermisosDefaultArgs> = $Result.GetResult<Prisma.$RolesPermisosPayload, S>

  type RolesPermisosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolesPermisosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesPermisosCountAggregateInputType | true
    }

  export interface RolesPermisosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolesPermisos'], meta: { name: 'RolesPermisos' } }
    /**
     * Find zero or one RolesPermisos that matches the filter.
     * @param {RolesPermisosFindUniqueArgs} args - Arguments to find a RolesPermisos
     * @example
     * // Get one RolesPermisos
     * const rolesPermisos = await prisma.rolesPermisos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolesPermisosFindUniqueArgs>(args: SelectSubset<T, RolesPermisosFindUniqueArgs<ExtArgs>>): Prisma__RolesPermisosClient<$Result.GetResult<Prisma.$RolesPermisosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolesPermisos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolesPermisosFindUniqueOrThrowArgs} args - Arguments to find a RolesPermisos
     * @example
     * // Get one RolesPermisos
     * const rolesPermisos = await prisma.rolesPermisos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolesPermisosFindUniqueOrThrowArgs>(args: SelectSubset<T, RolesPermisosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolesPermisosClient<$Result.GetResult<Prisma.$RolesPermisosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolesPermisos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesPermisosFindFirstArgs} args - Arguments to find a RolesPermisos
     * @example
     * // Get one RolesPermisos
     * const rolesPermisos = await prisma.rolesPermisos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolesPermisosFindFirstArgs>(args?: SelectSubset<T, RolesPermisosFindFirstArgs<ExtArgs>>): Prisma__RolesPermisosClient<$Result.GetResult<Prisma.$RolesPermisosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolesPermisos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesPermisosFindFirstOrThrowArgs} args - Arguments to find a RolesPermisos
     * @example
     * // Get one RolesPermisos
     * const rolesPermisos = await prisma.rolesPermisos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolesPermisosFindFirstOrThrowArgs>(args?: SelectSubset<T, RolesPermisosFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolesPermisosClient<$Result.GetResult<Prisma.$RolesPermisosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolesPermisos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesPermisosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolesPermisos
     * const rolesPermisos = await prisma.rolesPermisos.findMany()
     * 
     * // Get first 10 RolesPermisos
     * const rolesPermisos = await prisma.rolesPermisos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesPermisosWithIdOnly = await prisma.rolesPermisos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolesPermisosFindManyArgs>(args?: SelectSubset<T, RolesPermisosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPermisosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolesPermisos.
     * @param {RolesPermisosCreateArgs} args - Arguments to create a RolesPermisos.
     * @example
     * // Create one RolesPermisos
     * const RolesPermisos = await prisma.rolesPermisos.create({
     *   data: {
     *     // ... data to create a RolesPermisos
     *   }
     * })
     * 
     */
    create<T extends RolesPermisosCreateArgs>(args: SelectSubset<T, RolesPermisosCreateArgs<ExtArgs>>): Prisma__RolesPermisosClient<$Result.GetResult<Prisma.$RolesPermisosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolesPermisos.
     * @param {RolesPermisosCreateManyArgs} args - Arguments to create many RolesPermisos.
     * @example
     * // Create many RolesPermisos
     * const rolesPermisos = await prisma.rolesPermisos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolesPermisosCreateManyArgs>(args?: SelectSubset<T, RolesPermisosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RolesPermisos and returns the data saved in the database.
     * @param {RolesPermisosCreateManyAndReturnArgs} args - Arguments to create many RolesPermisos.
     * @example
     * // Create many RolesPermisos
     * const rolesPermisos = await prisma.rolesPermisos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RolesPermisos and only return the `id`
     * const rolesPermisosWithIdOnly = await prisma.rolesPermisos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolesPermisosCreateManyAndReturnArgs>(args?: SelectSubset<T, RolesPermisosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPermisosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RolesPermisos.
     * @param {RolesPermisosDeleteArgs} args - Arguments to delete one RolesPermisos.
     * @example
     * // Delete one RolesPermisos
     * const RolesPermisos = await prisma.rolesPermisos.delete({
     *   where: {
     *     // ... filter to delete one RolesPermisos
     *   }
     * })
     * 
     */
    delete<T extends RolesPermisosDeleteArgs>(args: SelectSubset<T, RolesPermisosDeleteArgs<ExtArgs>>): Prisma__RolesPermisosClient<$Result.GetResult<Prisma.$RolesPermisosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolesPermisos.
     * @param {RolesPermisosUpdateArgs} args - Arguments to update one RolesPermisos.
     * @example
     * // Update one RolesPermisos
     * const rolesPermisos = await prisma.rolesPermisos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolesPermisosUpdateArgs>(args: SelectSubset<T, RolesPermisosUpdateArgs<ExtArgs>>): Prisma__RolesPermisosClient<$Result.GetResult<Prisma.$RolesPermisosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolesPermisos.
     * @param {RolesPermisosDeleteManyArgs} args - Arguments to filter RolesPermisos to delete.
     * @example
     * // Delete a few RolesPermisos
     * const { count } = await prisma.rolesPermisos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolesPermisosDeleteManyArgs>(args?: SelectSubset<T, RolesPermisosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolesPermisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesPermisosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolesPermisos
     * const rolesPermisos = await prisma.rolesPermisos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolesPermisosUpdateManyArgs>(args: SelectSubset<T, RolesPermisosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolesPermisos and returns the data updated in the database.
     * @param {RolesPermisosUpdateManyAndReturnArgs} args - Arguments to update many RolesPermisos.
     * @example
     * // Update many RolesPermisos
     * const rolesPermisos = await prisma.rolesPermisos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RolesPermisos and only return the `id`
     * const rolesPermisosWithIdOnly = await prisma.rolesPermisos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolesPermisosUpdateManyAndReturnArgs>(args: SelectSubset<T, RolesPermisosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPermisosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RolesPermisos.
     * @param {RolesPermisosUpsertArgs} args - Arguments to update or create a RolesPermisos.
     * @example
     * // Update or create a RolesPermisos
     * const rolesPermisos = await prisma.rolesPermisos.upsert({
     *   create: {
     *     // ... data to create a RolesPermisos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolesPermisos we want to update
     *   }
     * })
     */
    upsert<T extends RolesPermisosUpsertArgs>(args: SelectSubset<T, RolesPermisosUpsertArgs<ExtArgs>>): Prisma__RolesPermisosClient<$Result.GetResult<Prisma.$RolesPermisosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolesPermisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesPermisosCountArgs} args - Arguments to filter RolesPermisos to count.
     * @example
     * // Count the number of RolesPermisos
     * const count = await prisma.rolesPermisos.count({
     *   where: {
     *     // ... the filter for the RolesPermisos we want to count
     *   }
     * })
    **/
    count<T extends RolesPermisosCountArgs>(
      args?: Subset<T, RolesPermisosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesPermisosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolesPermisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesPermisosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesPermisosAggregateArgs>(args: Subset<T, RolesPermisosAggregateArgs>): Prisma.PrismaPromise<GetRolesPermisosAggregateType<T>>

    /**
     * Group by RolesPermisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesPermisosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesPermisosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesPermisosGroupByArgs['orderBy'] }
        : { orderBy?: RolesPermisosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesPermisosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesPermisosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolesPermisos model
   */
  readonly fields: RolesPermisosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolesPermisos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolesPermisosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permiso<T extends PermisoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermisoDefaultArgs<ExtArgs>>): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rol<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolesPermisos model
   */
  interface RolesPermisosFieldRefs {
    readonly id: FieldRef<"RolesPermisos", 'Int'>
    readonly rolId: FieldRef<"RolesPermisos", 'Int'>
    readonly permisoId: FieldRef<"RolesPermisos", 'Int'>
    readonly createdAt: FieldRef<"RolesPermisos", 'DateTime'>
    readonly updatedAt: FieldRef<"RolesPermisos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolesPermisos findUnique
   */
  export type RolesPermisosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosInclude<ExtArgs> | null
    /**
     * Filter, which RolesPermisos to fetch.
     */
    where: RolesPermisosWhereUniqueInput
  }

  /**
   * RolesPermisos findUniqueOrThrow
   */
  export type RolesPermisosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosInclude<ExtArgs> | null
    /**
     * Filter, which RolesPermisos to fetch.
     */
    where: RolesPermisosWhereUniqueInput
  }

  /**
   * RolesPermisos findFirst
   */
  export type RolesPermisosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosInclude<ExtArgs> | null
    /**
     * Filter, which RolesPermisos to fetch.
     */
    where?: RolesPermisosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolesPermisos to fetch.
     */
    orderBy?: RolesPermisosOrderByWithRelationInput | RolesPermisosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolesPermisos.
     */
    cursor?: RolesPermisosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolesPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolesPermisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolesPermisos.
     */
    distinct?: RolesPermisosScalarFieldEnum | RolesPermisosScalarFieldEnum[]
  }

  /**
   * RolesPermisos findFirstOrThrow
   */
  export type RolesPermisosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosInclude<ExtArgs> | null
    /**
     * Filter, which RolesPermisos to fetch.
     */
    where?: RolesPermisosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolesPermisos to fetch.
     */
    orderBy?: RolesPermisosOrderByWithRelationInput | RolesPermisosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolesPermisos.
     */
    cursor?: RolesPermisosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolesPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolesPermisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolesPermisos.
     */
    distinct?: RolesPermisosScalarFieldEnum | RolesPermisosScalarFieldEnum[]
  }

  /**
   * RolesPermisos findMany
   */
  export type RolesPermisosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosInclude<ExtArgs> | null
    /**
     * Filter, which RolesPermisos to fetch.
     */
    where?: RolesPermisosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolesPermisos to fetch.
     */
    orderBy?: RolesPermisosOrderByWithRelationInput | RolesPermisosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolesPermisos.
     */
    cursor?: RolesPermisosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolesPermisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolesPermisos.
     */
    skip?: number
    distinct?: RolesPermisosScalarFieldEnum | RolesPermisosScalarFieldEnum[]
  }

  /**
   * RolesPermisos create
   */
  export type RolesPermisosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosInclude<ExtArgs> | null
    /**
     * The data needed to create a RolesPermisos.
     */
    data: XOR<RolesPermisosCreateInput, RolesPermisosUncheckedCreateInput>
  }

  /**
   * RolesPermisos createMany
   */
  export type RolesPermisosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolesPermisos.
     */
    data: RolesPermisosCreateManyInput | RolesPermisosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolesPermisos createManyAndReturn
   */
  export type RolesPermisosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * The data used to create many RolesPermisos.
     */
    data: RolesPermisosCreateManyInput | RolesPermisosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolesPermisos update
   */
  export type RolesPermisosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosInclude<ExtArgs> | null
    /**
     * The data needed to update a RolesPermisos.
     */
    data: XOR<RolesPermisosUpdateInput, RolesPermisosUncheckedUpdateInput>
    /**
     * Choose, which RolesPermisos to update.
     */
    where: RolesPermisosWhereUniqueInput
  }

  /**
   * RolesPermisos updateMany
   */
  export type RolesPermisosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolesPermisos.
     */
    data: XOR<RolesPermisosUpdateManyMutationInput, RolesPermisosUncheckedUpdateManyInput>
    /**
     * Filter which RolesPermisos to update
     */
    where?: RolesPermisosWhereInput
    /**
     * Limit how many RolesPermisos to update.
     */
    limit?: number
  }

  /**
   * RolesPermisos updateManyAndReturn
   */
  export type RolesPermisosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * The data used to update RolesPermisos.
     */
    data: XOR<RolesPermisosUpdateManyMutationInput, RolesPermisosUncheckedUpdateManyInput>
    /**
     * Filter which RolesPermisos to update
     */
    where?: RolesPermisosWhereInput
    /**
     * Limit how many RolesPermisos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RolesPermisos upsert
   */
  export type RolesPermisosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosInclude<ExtArgs> | null
    /**
     * The filter to search for the RolesPermisos to update in case it exists.
     */
    where: RolesPermisosWhereUniqueInput
    /**
     * In case the RolesPermisos found by the `where` argument doesn't exist, create a new RolesPermisos with this data.
     */
    create: XOR<RolesPermisosCreateInput, RolesPermisosUncheckedCreateInput>
    /**
     * In case the RolesPermisos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesPermisosUpdateInput, RolesPermisosUncheckedUpdateInput>
  }

  /**
   * RolesPermisos delete
   */
  export type RolesPermisosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosInclude<ExtArgs> | null
    /**
     * Filter which RolesPermisos to delete.
     */
    where: RolesPermisosWhereUniqueInput
  }

  /**
   * RolesPermisos deleteMany
   */
  export type RolesPermisosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolesPermisos to delete
     */
    where?: RolesPermisosWhereInput
    /**
     * Limit how many RolesPermisos to delete.
     */
    limit?: number
  }

  /**
   * RolesPermisos without action
   */
  export type RolesPermisosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesPermisos
     */
    select?: RolesPermisosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolesPermisos
     */
    omit?: RolesPermisosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesPermisosInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    id: number | null
  }

  export type CountrySumAggregateOutputType = {
    id: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: number | null
    name: string | null
    codeIso: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    codeIso: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    codeIso: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    id?: true
  }

  export type CountrySumAggregateInputType = {
    id?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    codeIso?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    codeIso?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    codeIso?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: number
    name: string
    codeIso: string
    createdAt: Date
    updatedAt: Date
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    codeIso?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subdivisions?: boolean | Country$subdivisionsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>

  export type CountrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    codeIso?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    codeIso?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["country"]>

  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    codeIso?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "codeIso" | "createdAt" | "updatedAt", ExtArgs["result"]["country"]>
  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subdivisions?: boolean | Country$subdivisionsArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CountryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CountryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      subdivisions: Prisma.$SubdivisionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      codeIso: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Countries and returns the data saved in the database.
     * @param {CountryCreateManyAndReturnArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries and returns the data updated in the database.
     * @param {CountryUpdateManyAndReturnArgs} args - Arguments to update many Countries.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Countries and only return the `id`
     * const countryWithIdOnly = await prisma.country.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subdivisions<T extends Country$subdivisionsArgs<ExtArgs> = {}>(args?: Subset<T, Country$subdivisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'Int'>
    readonly name: FieldRef<"Country", 'String'>
    readonly codeIso: FieldRef<"Country", 'String'>
    readonly createdAt: FieldRef<"Country", 'DateTime'>
    readonly updatedAt: FieldRef<"Country", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country createManyAndReturn
   */
  export type CountryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country updateManyAndReturn
   */
  export type CountryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to update.
     */
    limit?: number
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
    /**
     * Limit how many Countries to delete.
     */
    limit?: number
  }

  /**
   * Country.subdivisions
   */
  export type Country$subdivisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionInclude<ExtArgs> | null
    where?: SubdivisionWhereInput
    orderBy?: SubdivisionOrderByWithRelationInput | SubdivisionOrderByWithRelationInput[]
    cursor?: SubdivisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubdivisionScalarFieldEnum | SubdivisionScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Country
     */
    omit?: CountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model Subdivision
   */

  export type AggregateSubdivision = {
    _count: SubdivisionCountAggregateOutputType | null
    _avg: SubdivisionAvgAggregateOutputType | null
    _sum: SubdivisionSumAggregateOutputType | null
    _min: SubdivisionMinAggregateOutputType | null
    _max: SubdivisionMaxAggregateOutputType | null
  }

  export type SubdivisionAvgAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type SubdivisionSumAggregateOutputType = {
    id: number | null
    countryId: number | null
  }

  export type SubdivisionMinAggregateOutputType = {
    id: number | null
    countryId: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubdivisionMaxAggregateOutputType = {
    id: number | null
    countryId: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubdivisionCountAggregateOutputType = {
    id: number
    countryId: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubdivisionAvgAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type SubdivisionSumAggregateInputType = {
    id?: true
    countryId?: true
  }

  export type SubdivisionMinAggregateInputType = {
    id?: true
    countryId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubdivisionMaxAggregateInputType = {
    id?: true
    countryId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubdivisionCountAggregateInputType = {
    id?: true
    countryId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubdivisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subdivision to aggregate.
     */
    where?: SubdivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subdivisions to fetch.
     */
    orderBy?: SubdivisionOrderByWithRelationInput | SubdivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubdivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subdivisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subdivisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subdivisions
    **/
    _count?: true | SubdivisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubdivisionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubdivisionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubdivisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubdivisionMaxAggregateInputType
  }

  export type GetSubdivisionAggregateType<T extends SubdivisionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubdivision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubdivision[P]>
      : GetScalarType<T[P], AggregateSubdivision[P]>
  }




  export type SubdivisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubdivisionWhereInput
    orderBy?: SubdivisionOrderByWithAggregationInput | SubdivisionOrderByWithAggregationInput[]
    by: SubdivisionScalarFieldEnum[] | SubdivisionScalarFieldEnum
    having?: SubdivisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubdivisionCountAggregateInputType | true
    _avg?: SubdivisionAvgAggregateInputType
    _sum?: SubdivisionSumAggregateInputType
    _min?: SubdivisionMinAggregateInputType
    _max?: SubdivisionMaxAggregateInputType
  }

  export type SubdivisionGroupByOutputType = {
    id: number
    countryId: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: SubdivisionCountAggregateOutputType | null
    _avg: SubdivisionAvgAggregateOutputType | null
    _sum: SubdivisionSumAggregateOutputType | null
    _min: SubdivisionMinAggregateOutputType | null
    _max: SubdivisionMaxAggregateOutputType | null
  }

  type GetSubdivisionGroupByPayload<T extends SubdivisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubdivisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubdivisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubdivisionGroupByOutputType[P]>
            : GetScalarType<T[P], SubdivisionGroupByOutputType[P]>
        }
      >
    >


  export type SubdivisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emprendimientos?: boolean | Subdivision$emprendimientosArgs<ExtArgs>
    personas?: boolean | Subdivision$personasArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    _count?: boolean | SubdivisionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subdivision"]>

  export type SubdivisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subdivision"]>

  export type SubdivisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    countryId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subdivision"]>

  export type SubdivisionSelectScalar = {
    id?: boolean
    countryId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubdivisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "countryId" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["subdivision"]>
  export type SubdivisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimientos?: boolean | Subdivision$emprendimientosArgs<ExtArgs>
    personas?: boolean | Subdivision$personasArgs<ExtArgs>
    country?: boolean | CountryDefaultArgs<ExtArgs>
    _count?: boolean | SubdivisionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubdivisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }
  export type SubdivisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $SubdivisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subdivision"
    objects: {
      emprendimientos: Prisma.$EmprendimientoPayload<ExtArgs>[]
      personas: Prisma.$PersonaPayload<ExtArgs>[]
      country: Prisma.$CountryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      countryId: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subdivision"]>
    composites: {}
  }

  type SubdivisionGetPayload<S extends boolean | null | undefined | SubdivisionDefaultArgs> = $Result.GetResult<Prisma.$SubdivisionPayload, S>

  type SubdivisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubdivisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubdivisionCountAggregateInputType | true
    }

  export interface SubdivisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subdivision'], meta: { name: 'Subdivision' } }
    /**
     * Find zero or one Subdivision that matches the filter.
     * @param {SubdivisionFindUniqueArgs} args - Arguments to find a Subdivision
     * @example
     * // Get one Subdivision
     * const subdivision = await prisma.subdivision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubdivisionFindUniqueArgs>(args: SelectSubset<T, SubdivisionFindUniqueArgs<ExtArgs>>): Prisma__SubdivisionClient<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subdivision that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubdivisionFindUniqueOrThrowArgs} args - Arguments to find a Subdivision
     * @example
     * // Get one Subdivision
     * const subdivision = await prisma.subdivision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubdivisionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubdivisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubdivisionClient<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subdivision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdivisionFindFirstArgs} args - Arguments to find a Subdivision
     * @example
     * // Get one Subdivision
     * const subdivision = await prisma.subdivision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubdivisionFindFirstArgs>(args?: SelectSubset<T, SubdivisionFindFirstArgs<ExtArgs>>): Prisma__SubdivisionClient<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subdivision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdivisionFindFirstOrThrowArgs} args - Arguments to find a Subdivision
     * @example
     * // Get one Subdivision
     * const subdivision = await prisma.subdivision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubdivisionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubdivisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubdivisionClient<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subdivisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdivisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subdivisions
     * const subdivisions = await prisma.subdivision.findMany()
     * 
     * // Get first 10 Subdivisions
     * const subdivisions = await prisma.subdivision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subdivisionWithIdOnly = await prisma.subdivision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubdivisionFindManyArgs>(args?: SelectSubset<T, SubdivisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subdivision.
     * @param {SubdivisionCreateArgs} args - Arguments to create a Subdivision.
     * @example
     * // Create one Subdivision
     * const Subdivision = await prisma.subdivision.create({
     *   data: {
     *     // ... data to create a Subdivision
     *   }
     * })
     * 
     */
    create<T extends SubdivisionCreateArgs>(args: SelectSubset<T, SubdivisionCreateArgs<ExtArgs>>): Prisma__SubdivisionClient<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subdivisions.
     * @param {SubdivisionCreateManyArgs} args - Arguments to create many Subdivisions.
     * @example
     * // Create many Subdivisions
     * const subdivision = await prisma.subdivision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubdivisionCreateManyArgs>(args?: SelectSubset<T, SubdivisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subdivisions and returns the data saved in the database.
     * @param {SubdivisionCreateManyAndReturnArgs} args - Arguments to create many Subdivisions.
     * @example
     * // Create many Subdivisions
     * const subdivision = await prisma.subdivision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subdivisions and only return the `id`
     * const subdivisionWithIdOnly = await prisma.subdivision.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubdivisionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubdivisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subdivision.
     * @param {SubdivisionDeleteArgs} args - Arguments to delete one Subdivision.
     * @example
     * // Delete one Subdivision
     * const Subdivision = await prisma.subdivision.delete({
     *   where: {
     *     // ... filter to delete one Subdivision
     *   }
     * })
     * 
     */
    delete<T extends SubdivisionDeleteArgs>(args: SelectSubset<T, SubdivisionDeleteArgs<ExtArgs>>): Prisma__SubdivisionClient<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subdivision.
     * @param {SubdivisionUpdateArgs} args - Arguments to update one Subdivision.
     * @example
     * // Update one Subdivision
     * const subdivision = await prisma.subdivision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubdivisionUpdateArgs>(args: SelectSubset<T, SubdivisionUpdateArgs<ExtArgs>>): Prisma__SubdivisionClient<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subdivisions.
     * @param {SubdivisionDeleteManyArgs} args - Arguments to filter Subdivisions to delete.
     * @example
     * // Delete a few Subdivisions
     * const { count } = await prisma.subdivision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubdivisionDeleteManyArgs>(args?: SelectSubset<T, SubdivisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subdivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdivisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subdivisions
     * const subdivision = await prisma.subdivision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubdivisionUpdateManyArgs>(args: SelectSubset<T, SubdivisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subdivisions and returns the data updated in the database.
     * @param {SubdivisionUpdateManyAndReturnArgs} args - Arguments to update many Subdivisions.
     * @example
     * // Update many Subdivisions
     * const subdivision = await prisma.subdivision.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subdivisions and only return the `id`
     * const subdivisionWithIdOnly = await prisma.subdivision.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubdivisionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubdivisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subdivision.
     * @param {SubdivisionUpsertArgs} args - Arguments to update or create a Subdivision.
     * @example
     * // Update or create a Subdivision
     * const subdivision = await prisma.subdivision.upsert({
     *   create: {
     *     // ... data to create a Subdivision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subdivision we want to update
     *   }
     * })
     */
    upsert<T extends SubdivisionUpsertArgs>(args: SelectSubset<T, SubdivisionUpsertArgs<ExtArgs>>): Prisma__SubdivisionClient<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subdivisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdivisionCountArgs} args - Arguments to filter Subdivisions to count.
     * @example
     * // Count the number of Subdivisions
     * const count = await prisma.subdivision.count({
     *   where: {
     *     // ... the filter for the Subdivisions we want to count
     *   }
     * })
    **/
    count<T extends SubdivisionCountArgs>(
      args?: Subset<T, SubdivisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubdivisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subdivision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdivisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubdivisionAggregateArgs>(args: Subset<T, SubdivisionAggregateArgs>): Prisma.PrismaPromise<GetSubdivisionAggregateType<T>>

    /**
     * Group by Subdivision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdivisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubdivisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubdivisionGroupByArgs['orderBy'] }
        : { orderBy?: SubdivisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubdivisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubdivisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subdivision model
   */
  readonly fields: SubdivisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subdivision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubdivisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emprendimientos<T extends Subdivision$emprendimientosArgs<ExtArgs> = {}>(args?: Subset<T, Subdivision$emprendimientosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personas<T extends Subdivision$personasArgs<ExtArgs> = {}>(args?: Subset<T, Subdivision$personasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subdivision model
   */
  interface SubdivisionFieldRefs {
    readonly id: FieldRef<"Subdivision", 'Int'>
    readonly countryId: FieldRef<"Subdivision", 'Int'>
    readonly name: FieldRef<"Subdivision", 'String'>
    readonly createdAt: FieldRef<"Subdivision", 'DateTime'>
    readonly updatedAt: FieldRef<"Subdivision", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subdivision findUnique
   */
  export type SubdivisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionInclude<ExtArgs> | null
    /**
     * Filter, which Subdivision to fetch.
     */
    where: SubdivisionWhereUniqueInput
  }

  /**
   * Subdivision findUniqueOrThrow
   */
  export type SubdivisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionInclude<ExtArgs> | null
    /**
     * Filter, which Subdivision to fetch.
     */
    where: SubdivisionWhereUniqueInput
  }

  /**
   * Subdivision findFirst
   */
  export type SubdivisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionInclude<ExtArgs> | null
    /**
     * Filter, which Subdivision to fetch.
     */
    where?: SubdivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subdivisions to fetch.
     */
    orderBy?: SubdivisionOrderByWithRelationInput | SubdivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subdivisions.
     */
    cursor?: SubdivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subdivisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subdivisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subdivisions.
     */
    distinct?: SubdivisionScalarFieldEnum | SubdivisionScalarFieldEnum[]
  }

  /**
   * Subdivision findFirstOrThrow
   */
  export type SubdivisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionInclude<ExtArgs> | null
    /**
     * Filter, which Subdivision to fetch.
     */
    where?: SubdivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subdivisions to fetch.
     */
    orderBy?: SubdivisionOrderByWithRelationInput | SubdivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subdivisions.
     */
    cursor?: SubdivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subdivisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subdivisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subdivisions.
     */
    distinct?: SubdivisionScalarFieldEnum | SubdivisionScalarFieldEnum[]
  }

  /**
   * Subdivision findMany
   */
  export type SubdivisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionInclude<ExtArgs> | null
    /**
     * Filter, which Subdivisions to fetch.
     */
    where?: SubdivisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subdivisions to fetch.
     */
    orderBy?: SubdivisionOrderByWithRelationInput | SubdivisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subdivisions.
     */
    cursor?: SubdivisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subdivisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subdivisions.
     */
    skip?: number
    distinct?: SubdivisionScalarFieldEnum | SubdivisionScalarFieldEnum[]
  }

  /**
   * Subdivision create
   */
  export type SubdivisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subdivision.
     */
    data: XOR<SubdivisionCreateInput, SubdivisionUncheckedCreateInput>
  }

  /**
   * Subdivision createMany
   */
  export type SubdivisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subdivisions.
     */
    data: SubdivisionCreateManyInput | SubdivisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subdivision createManyAndReturn
   */
  export type SubdivisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * The data used to create many Subdivisions.
     */
    data: SubdivisionCreateManyInput | SubdivisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subdivision update
   */
  export type SubdivisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subdivision.
     */
    data: XOR<SubdivisionUpdateInput, SubdivisionUncheckedUpdateInput>
    /**
     * Choose, which Subdivision to update.
     */
    where: SubdivisionWhereUniqueInput
  }

  /**
   * Subdivision updateMany
   */
  export type SubdivisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subdivisions.
     */
    data: XOR<SubdivisionUpdateManyMutationInput, SubdivisionUncheckedUpdateManyInput>
    /**
     * Filter which Subdivisions to update
     */
    where?: SubdivisionWhereInput
    /**
     * Limit how many Subdivisions to update.
     */
    limit?: number
  }

  /**
   * Subdivision updateManyAndReturn
   */
  export type SubdivisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * The data used to update Subdivisions.
     */
    data: XOR<SubdivisionUpdateManyMutationInput, SubdivisionUncheckedUpdateManyInput>
    /**
     * Filter which Subdivisions to update
     */
    where?: SubdivisionWhereInput
    /**
     * Limit how many Subdivisions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subdivision upsert
   */
  export type SubdivisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subdivision to update in case it exists.
     */
    where: SubdivisionWhereUniqueInput
    /**
     * In case the Subdivision found by the `where` argument doesn't exist, create a new Subdivision with this data.
     */
    create: XOR<SubdivisionCreateInput, SubdivisionUncheckedCreateInput>
    /**
     * In case the Subdivision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubdivisionUpdateInput, SubdivisionUncheckedUpdateInput>
  }

  /**
   * Subdivision delete
   */
  export type SubdivisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionInclude<ExtArgs> | null
    /**
     * Filter which Subdivision to delete.
     */
    where: SubdivisionWhereUniqueInput
  }

  /**
   * Subdivision deleteMany
   */
  export type SubdivisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subdivisions to delete
     */
    where?: SubdivisionWhereInput
    /**
     * Limit how many Subdivisions to delete.
     */
    limit?: number
  }

  /**
   * Subdivision.emprendimientos
   */
  export type Subdivision$emprendimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    where?: EmprendimientoWhereInput
    orderBy?: EmprendimientoOrderByWithRelationInput | EmprendimientoOrderByWithRelationInput[]
    cursor?: EmprendimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmprendimientoScalarFieldEnum | EmprendimientoScalarFieldEnum[]
  }

  /**
   * Subdivision.personas
   */
  export type Subdivision$personasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Persona
     */
    omit?: PersonaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    where?: PersonaWhereInput
    orderBy?: PersonaOrderByWithRelationInput | PersonaOrderByWithRelationInput[]
    cursor?: PersonaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonaScalarFieldEnum | PersonaScalarFieldEnum[]
  }

  /**
   * Subdivision without action
   */
  export type SubdivisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionInclude<ExtArgs> | null
  }


  /**
   * Model Persona
   */

  export type AggregatePersona = {
    _count: PersonaCountAggregateOutputType | null
    _avg: PersonaAvgAggregateOutputType | null
    _sum: PersonaSumAggregateOutputType | null
    _min: PersonaMinAggregateOutputType | null
    _max: PersonaMaxAggregateOutputType | null
  }

  export type PersonaAvgAggregateOutputType = {
    id: number | null
    subdivisionId: number | null
  }

  export type PersonaSumAggregateOutputType = {
    id: number | null
    subdivisionId: number | null
  }

  export type PersonaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellidos: string | null
    telefono: string | null
    direccion: string | null
    fotoPerfilUrl: string | null
    fechaNacimiento: Date | null
    subdivisionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellidos: string | null
    telefono: string | null
    direccion: string | null
    fotoPerfilUrl: string | null
    fechaNacimiento: Date | null
    subdivisionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonaCountAggregateOutputType = {
    id: number
    nombre: number
    apellidos: number
    telefono: number
    direccion: number
    fotoPerfilUrl: number
    fechaNacimiento: number
    subdivisionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PersonaAvgAggregateInputType = {
    id?: true
    subdivisionId?: true
  }

  export type PersonaSumAggregateInputType = {
    id?: true
    subdivisionId?: true
  }

  export type PersonaMinAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    telefono?: true
    direccion?: true
    fotoPerfilUrl?: true
    fechaNacimiento?: true
    subdivisionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonaMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    telefono?: true
    direccion?: true
    fotoPerfilUrl?: true
    fechaNacimiento?: true
    subdivisionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonaCountAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    telefono?: true
    direccion?: true
    fotoPerfilUrl?: true
    fechaNacimiento?: true
    subdivisionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PersonaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Persona to aggregate.
     */
    where?: PersonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personas to fetch.
     */
    orderBy?: PersonaOrderByWithRelationInput | PersonaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Personas
    **/
    _count?: true | PersonaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonaMaxAggregateInputType
  }

  export type GetPersonaAggregateType<T extends PersonaAggregateArgs> = {
        [P in keyof T & keyof AggregatePersona]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersona[P]>
      : GetScalarType<T[P], AggregatePersona[P]>
  }




  export type PersonaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonaWhereInput
    orderBy?: PersonaOrderByWithAggregationInput | PersonaOrderByWithAggregationInput[]
    by: PersonaScalarFieldEnum[] | PersonaScalarFieldEnum
    having?: PersonaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonaCountAggregateInputType | true
    _avg?: PersonaAvgAggregateInputType
    _sum?: PersonaSumAggregateInputType
    _min?: PersonaMinAggregateInputType
    _max?: PersonaMaxAggregateInputType
  }

  export type PersonaGroupByOutputType = {
    id: number
    nombre: string
    apellidos: string
    telefono: string | null
    direccion: string | null
    fotoPerfilUrl: string | null
    fechaNacimiento: Date | null
    subdivisionId: number
    createdAt: Date
    updatedAt: Date
    _count: PersonaCountAggregateOutputType | null
    _avg: PersonaAvgAggregateOutputType | null
    _sum: PersonaSumAggregateOutputType | null
    _min: PersonaMinAggregateOutputType | null
    _max: PersonaMaxAggregateOutputType | null
  }

  type GetPersonaGroupByPayload<T extends PersonaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonaGroupByOutputType[P]>
            : GetScalarType<T[P], PersonaGroupByOutputType[P]>
        }
      >
    >


  export type PersonaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    telefono?: boolean
    direccion?: boolean
    fotoPerfilUrl?: boolean
    fechaNacimiento?: boolean
    subdivisionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subdivision?: boolean | SubdivisionDefaultArgs<ExtArgs>
    usuario?: boolean | Persona$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["persona"]>

  export type PersonaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    telefono?: boolean
    direccion?: boolean
    fotoPerfilUrl?: boolean
    fechaNacimiento?: boolean
    subdivisionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subdivision?: boolean | SubdivisionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persona"]>

  export type PersonaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    telefono?: boolean
    direccion?: boolean
    fotoPerfilUrl?: boolean
    fechaNacimiento?: boolean
    subdivisionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subdivision?: boolean | SubdivisionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["persona"]>

  export type PersonaSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    telefono?: boolean
    direccion?: boolean
    fotoPerfilUrl?: boolean
    fechaNacimiento?: boolean
    subdivisionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PersonaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "apellidos" | "telefono" | "direccion" | "fotoPerfilUrl" | "fechaNacimiento" | "subdivisionId" | "createdAt" | "updatedAt", ExtArgs["result"]["persona"]>
  export type PersonaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subdivision?: boolean | SubdivisionDefaultArgs<ExtArgs>
    usuario?: boolean | Persona$usuarioArgs<ExtArgs>
  }
  export type PersonaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subdivision?: boolean | SubdivisionDefaultArgs<ExtArgs>
  }
  export type PersonaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subdivision?: boolean | SubdivisionDefaultArgs<ExtArgs>
  }

  export type $PersonaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Persona"
    objects: {
      subdivision: Prisma.$SubdivisionPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      apellidos: string
      telefono: string | null
      direccion: string | null
      fotoPerfilUrl: string | null
      fechaNacimiento: Date | null
      subdivisionId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["persona"]>
    composites: {}
  }

  type PersonaGetPayload<S extends boolean | null | undefined | PersonaDefaultArgs> = $Result.GetResult<Prisma.$PersonaPayload, S>

  type PersonaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonaCountAggregateInputType | true
    }

  export interface PersonaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Persona'], meta: { name: 'Persona' } }
    /**
     * Find zero or one Persona that matches the filter.
     * @param {PersonaFindUniqueArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonaFindUniqueArgs>(args: SelectSubset<T, PersonaFindUniqueArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Persona that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonaFindUniqueOrThrowArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonaFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Persona that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaFindFirstArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonaFindFirstArgs>(args?: SelectSubset<T, PersonaFindFirstArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Persona that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaFindFirstOrThrowArgs} args - Arguments to find a Persona
     * @example
     * // Get one Persona
     * const persona = await prisma.persona.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonaFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonaFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Personas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personas
     * const personas = await prisma.persona.findMany()
     * 
     * // Get first 10 Personas
     * const personas = await prisma.persona.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personaWithIdOnly = await prisma.persona.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonaFindManyArgs>(args?: SelectSubset<T, PersonaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Persona.
     * @param {PersonaCreateArgs} args - Arguments to create a Persona.
     * @example
     * // Create one Persona
     * const Persona = await prisma.persona.create({
     *   data: {
     *     // ... data to create a Persona
     *   }
     * })
     * 
     */
    create<T extends PersonaCreateArgs>(args: SelectSubset<T, PersonaCreateArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Personas.
     * @param {PersonaCreateManyArgs} args - Arguments to create many Personas.
     * @example
     * // Create many Personas
     * const persona = await prisma.persona.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonaCreateManyArgs>(args?: SelectSubset<T, PersonaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Personas and returns the data saved in the database.
     * @param {PersonaCreateManyAndReturnArgs} args - Arguments to create many Personas.
     * @example
     * // Create many Personas
     * const persona = await prisma.persona.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Personas and only return the `id`
     * const personaWithIdOnly = await prisma.persona.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonaCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Persona.
     * @param {PersonaDeleteArgs} args - Arguments to delete one Persona.
     * @example
     * // Delete one Persona
     * const Persona = await prisma.persona.delete({
     *   where: {
     *     // ... filter to delete one Persona
     *   }
     * })
     * 
     */
    delete<T extends PersonaDeleteArgs>(args: SelectSubset<T, PersonaDeleteArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Persona.
     * @param {PersonaUpdateArgs} args - Arguments to update one Persona.
     * @example
     * // Update one Persona
     * const persona = await prisma.persona.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonaUpdateArgs>(args: SelectSubset<T, PersonaUpdateArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Personas.
     * @param {PersonaDeleteManyArgs} args - Arguments to filter Personas to delete.
     * @example
     * // Delete a few Personas
     * const { count } = await prisma.persona.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonaDeleteManyArgs>(args?: SelectSubset<T, PersonaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personas
     * const persona = await prisma.persona.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonaUpdateManyArgs>(args: SelectSubset<T, PersonaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personas and returns the data updated in the database.
     * @param {PersonaUpdateManyAndReturnArgs} args - Arguments to update many Personas.
     * @example
     * // Update many Personas
     * const persona = await prisma.persona.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Personas and only return the `id`
     * const personaWithIdOnly = await prisma.persona.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonaUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Persona.
     * @param {PersonaUpsertArgs} args - Arguments to update or create a Persona.
     * @example
     * // Update or create a Persona
     * const persona = await prisma.persona.upsert({
     *   create: {
     *     // ... data to create a Persona
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Persona we want to update
     *   }
     * })
     */
    upsert<T extends PersonaUpsertArgs>(args: SelectSubset<T, PersonaUpsertArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Personas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaCountArgs} args - Arguments to filter Personas to count.
     * @example
     * // Count the number of Personas
     * const count = await prisma.persona.count({
     *   where: {
     *     // ... the filter for the Personas we want to count
     *   }
     * })
    **/
    count<T extends PersonaCountArgs>(
      args?: Subset<T, PersonaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Persona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonaAggregateArgs>(args: Subset<T, PersonaAggregateArgs>): Prisma.PrismaPromise<GetPersonaAggregateType<T>>

    /**
     * Group by Persona.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonaGroupByArgs['orderBy'] }
        : { orderBy?: PersonaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Persona model
   */
  readonly fields: PersonaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Persona.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subdivision<T extends SubdivisionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubdivisionDefaultArgs<ExtArgs>>): Prisma__SubdivisionClient<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuario<T extends Persona$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, Persona$usuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Persona model
   */
  interface PersonaFieldRefs {
    readonly id: FieldRef<"Persona", 'Int'>
    readonly nombre: FieldRef<"Persona", 'String'>
    readonly apellidos: FieldRef<"Persona", 'String'>
    readonly telefono: FieldRef<"Persona", 'String'>
    readonly direccion: FieldRef<"Persona", 'String'>
    readonly fotoPerfilUrl: FieldRef<"Persona", 'String'>
    readonly fechaNacimiento: FieldRef<"Persona", 'DateTime'>
    readonly subdivisionId: FieldRef<"Persona", 'Int'>
    readonly createdAt: FieldRef<"Persona", 'DateTime'>
    readonly updatedAt: FieldRef<"Persona", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Persona findUnique
   */
  export type PersonaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Persona
     */
    omit?: PersonaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * Filter, which Persona to fetch.
     */
    where: PersonaWhereUniqueInput
  }

  /**
   * Persona findUniqueOrThrow
   */
  export type PersonaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Persona
     */
    omit?: PersonaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * Filter, which Persona to fetch.
     */
    where: PersonaWhereUniqueInput
  }

  /**
   * Persona findFirst
   */
  export type PersonaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Persona
     */
    omit?: PersonaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * Filter, which Persona to fetch.
     */
    where?: PersonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personas to fetch.
     */
    orderBy?: PersonaOrderByWithRelationInput | PersonaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personas.
     */
    cursor?: PersonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personas.
     */
    distinct?: PersonaScalarFieldEnum | PersonaScalarFieldEnum[]
  }

  /**
   * Persona findFirstOrThrow
   */
  export type PersonaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Persona
     */
    omit?: PersonaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * Filter, which Persona to fetch.
     */
    where?: PersonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personas to fetch.
     */
    orderBy?: PersonaOrderByWithRelationInput | PersonaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personas.
     */
    cursor?: PersonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personas.
     */
    distinct?: PersonaScalarFieldEnum | PersonaScalarFieldEnum[]
  }

  /**
   * Persona findMany
   */
  export type PersonaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Persona
     */
    omit?: PersonaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * Filter, which Personas to fetch.
     */
    where?: PersonaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personas to fetch.
     */
    orderBy?: PersonaOrderByWithRelationInput | PersonaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Personas.
     */
    cursor?: PersonaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personas.
     */
    skip?: number
    distinct?: PersonaScalarFieldEnum | PersonaScalarFieldEnum[]
  }

  /**
   * Persona create
   */
  export type PersonaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Persona
     */
    omit?: PersonaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * The data needed to create a Persona.
     */
    data: XOR<PersonaCreateInput, PersonaUncheckedCreateInput>
  }

  /**
   * Persona createMany
   */
  export type PersonaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Personas.
     */
    data: PersonaCreateManyInput | PersonaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Persona createManyAndReturn
   */
  export type PersonaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Persona
     */
    omit?: PersonaOmit<ExtArgs> | null
    /**
     * The data used to create many Personas.
     */
    data: PersonaCreateManyInput | PersonaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Persona update
   */
  export type PersonaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Persona
     */
    omit?: PersonaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * The data needed to update a Persona.
     */
    data: XOR<PersonaUpdateInput, PersonaUncheckedUpdateInput>
    /**
     * Choose, which Persona to update.
     */
    where: PersonaWhereUniqueInput
  }

  /**
   * Persona updateMany
   */
  export type PersonaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Personas.
     */
    data: XOR<PersonaUpdateManyMutationInput, PersonaUncheckedUpdateManyInput>
    /**
     * Filter which Personas to update
     */
    where?: PersonaWhereInput
    /**
     * Limit how many Personas to update.
     */
    limit?: number
  }

  /**
   * Persona updateManyAndReturn
   */
  export type PersonaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Persona
     */
    omit?: PersonaOmit<ExtArgs> | null
    /**
     * The data used to update Personas.
     */
    data: XOR<PersonaUpdateManyMutationInput, PersonaUncheckedUpdateManyInput>
    /**
     * Filter which Personas to update
     */
    where?: PersonaWhereInput
    /**
     * Limit how many Personas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Persona upsert
   */
  export type PersonaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Persona
     */
    omit?: PersonaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * The filter to search for the Persona to update in case it exists.
     */
    where: PersonaWhereUniqueInput
    /**
     * In case the Persona found by the `where` argument doesn't exist, create a new Persona with this data.
     */
    create: XOR<PersonaCreateInput, PersonaUncheckedCreateInput>
    /**
     * In case the Persona was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonaUpdateInput, PersonaUncheckedUpdateInput>
  }

  /**
   * Persona delete
   */
  export type PersonaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Persona
     */
    omit?: PersonaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
    /**
     * Filter which Persona to delete.
     */
    where: PersonaWhereUniqueInput
  }

  /**
   * Persona deleteMany
   */
  export type PersonaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Personas to delete
     */
    where?: PersonaWhereInput
    /**
     * Limit how many Personas to delete.
     */
    limit?: number
  }

  /**
   * Persona.usuario
   */
  export type Persona$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * Persona without action
   */
  export type PersonaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Persona
     */
    select?: PersonaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Persona
     */
    omit?: PersonaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaInclude<ExtArgs> | null
  }


  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
    personaId: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
    personaId: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    personaId: number | null
    email: string | null
    passwordHash: string | null
    recoveryToken: string | null
    recoveryTokenExpiresAt: Date | null
    emailVerificationToken: string | null
    emailVerified: boolean | null
    estaActivo: boolean | null
    ultimoAcceso: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    personaId: number | null
    email: string | null
    passwordHash: string | null
    recoveryToken: string | null
    recoveryTokenExpiresAt: Date | null
    emailVerificationToken: string | null
    emailVerified: boolean | null
    estaActivo: boolean | null
    ultimoAcceso: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    personaId: number
    email: number
    passwordHash: number
    recoveryToken: number
    recoveryTokenExpiresAt: number
    emailVerificationToken: number
    emailVerified: number
    estaActivo: number
    ultimoAcceso: number
    preferencias: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
    personaId?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
    personaId?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    personaId?: true
    email?: true
    passwordHash?: true
    recoveryToken?: true
    recoveryTokenExpiresAt?: true
    emailVerificationToken?: true
    emailVerified?: true
    estaActivo?: true
    ultimoAcceso?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    personaId?: true
    email?: true
    passwordHash?: true
    recoveryToken?: true
    recoveryTokenExpiresAt?: true
    emailVerificationToken?: true
    emailVerified?: true
    estaActivo?: true
    ultimoAcceso?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    personaId?: true
    email?: true
    passwordHash?: true
    recoveryToken?: true
    recoveryTokenExpiresAt?: true
    emailVerificationToken?: true
    emailVerified?: true
    estaActivo?: true
    ultimoAcceso?: true
    preferencias?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    personaId: number
    email: string
    passwordHash: string
    recoveryToken: string | null
    recoveryTokenExpiresAt: Date | null
    emailVerificationToken: string | null
    emailVerified: boolean
    estaActivo: boolean
    ultimoAcceso: Date | null
    preferencias: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personaId?: boolean
    email?: boolean
    passwordHash?: boolean
    recoveryToken?: boolean
    recoveryTokenExpiresAt?: boolean
    emailVerificationToken?: boolean
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: boolean
    preferencias?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emprendimientos?: boolean | Usuario$emprendimientosArgs<ExtArgs>
    favoritos?: boolean | Usuario$favoritosArgs<ExtArgs>
    registroAccesos?: boolean | Usuario$registroAccesosArgs<ExtArgs>
    resenas?: boolean | Usuario$resenasArgs<ExtArgs>
    tokensInvalidados?: boolean | Usuario$tokensInvalidadosArgs<ExtArgs>
    persona?: boolean | PersonaDefaultArgs<ExtArgs>
    usuariosRoles?: boolean | Usuario$usuariosRolesArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personaId?: boolean
    email?: boolean
    passwordHash?: boolean
    recoveryToken?: boolean
    recoveryTokenExpiresAt?: boolean
    emailVerificationToken?: boolean
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: boolean
    preferencias?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    persona?: boolean | PersonaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personaId?: boolean
    email?: boolean
    passwordHash?: boolean
    recoveryToken?: boolean
    recoveryTokenExpiresAt?: boolean
    emailVerificationToken?: boolean
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: boolean
    preferencias?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    persona?: boolean | PersonaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    personaId?: boolean
    email?: boolean
    passwordHash?: boolean
    recoveryToken?: boolean
    recoveryTokenExpiresAt?: boolean
    emailVerificationToken?: boolean
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: boolean
    preferencias?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personaId" | "email" | "passwordHash" | "recoveryToken" | "recoveryTokenExpiresAt" | "emailVerificationToken" | "emailVerified" | "estaActivo" | "ultimoAcceso" | "preferencias" | "createdAt" | "updatedAt", ExtArgs["result"]["usuario"]>
  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimientos?: boolean | Usuario$emprendimientosArgs<ExtArgs>
    favoritos?: boolean | Usuario$favoritosArgs<ExtArgs>
    registroAccesos?: boolean | Usuario$registroAccesosArgs<ExtArgs>
    resenas?: boolean | Usuario$resenasArgs<ExtArgs>
    tokensInvalidados?: boolean | Usuario$tokensInvalidadosArgs<ExtArgs>
    persona?: boolean | PersonaDefaultArgs<ExtArgs>
    usuariosRoles?: boolean | Usuario$usuariosRolesArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    persona?: boolean | PersonaDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    persona?: boolean | PersonaDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      emprendimientos: Prisma.$EmprendimientoPayload<ExtArgs>[]
      favoritos: Prisma.$FavoritoPayload<ExtArgs>[]
      registroAccesos: Prisma.$RegistroAccesoPayload<ExtArgs>[]
      resenas: Prisma.$ResenaPayload<ExtArgs>[]
      tokensInvalidados: Prisma.$TokenInvalidadoPayload<ExtArgs>[]
      persona: Prisma.$PersonaPayload<ExtArgs>
      usuariosRoles: Prisma.$UsuariosRolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      personaId: number
      email: string
      passwordHash: string
      recoveryToken: string | null
      recoveryTokenExpiresAt: Date | null
      emailVerificationToken: string | null
      emailVerified: boolean
      estaActivo: boolean
      ultimoAcceso: Date | null
      preferencias: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {UsuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emprendimientos<T extends Usuario$emprendimientosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$emprendimientosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favoritos<T extends Usuario$favoritosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$favoritosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    registroAccesos<T extends Usuario$registroAccesosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$registroAccesosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroAccesoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resenas<T extends Usuario$resenasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$resenasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tokensInvalidados<T extends Usuario$tokensInvalidadosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$tokensInvalidadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenInvalidadoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    persona<T extends PersonaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonaDefaultArgs<ExtArgs>>): Prisma__PersonaClient<$Result.GetResult<Prisma.$PersonaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuariosRoles<T extends Usuario$usuariosRolesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$usuariosRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly personaId: FieldRef<"Usuario", 'Int'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly passwordHash: FieldRef<"Usuario", 'String'>
    readonly recoveryToken: FieldRef<"Usuario", 'String'>
    readonly recoveryTokenExpiresAt: FieldRef<"Usuario", 'DateTime'>
    readonly emailVerificationToken: FieldRef<"Usuario", 'String'>
    readonly emailVerified: FieldRef<"Usuario", 'Boolean'>
    readonly estaActivo: FieldRef<"Usuario", 'Boolean'>
    readonly ultimoAcceso: FieldRef<"Usuario", 'DateTime'>
    readonly preferencias: FieldRef<"Usuario", 'Json'>
    readonly createdAt: FieldRef<"Usuario", 'DateTime'>
    readonly updatedAt: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario updateManyAndReturn
   */
  export type UsuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuario.emprendimientos
   */
  export type Usuario$emprendimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    where?: EmprendimientoWhereInput
    orderBy?: EmprendimientoOrderByWithRelationInput | EmprendimientoOrderByWithRelationInput[]
    cursor?: EmprendimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmprendimientoScalarFieldEnum | EmprendimientoScalarFieldEnum[]
  }

  /**
   * Usuario.favoritos
   */
  export type Usuario$favoritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    where?: FavoritoWhereInput
    orderBy?: FavoritoOrderByWithRelationInput | FavoritoOrderByWithRelationInput[]
    cursor?: FavoritoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[]
  }

  /**
   * Usuario.registroAccesos
   */
  export type Usuario$registroAccesosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAcceso
     */
    select?: RegistroAccesoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroAcceso
     */
    omit?: RegistroAccesoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAccesoInclude<ExtArgs> | null
    where?: RegistroAccesoWhereInput
    orderBy?: RegistroAccesoOrderByWithRelationInput | RegistroAccesoOrderByWithRelationInput[]
    cursor?: RegistroAccesoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegistroAccesoScalarFieldEnum | RegistroAccesoScalarFieldEnum[]
  }

  /**
   * Usuario.resenas
   */
  export type Usuario$resenasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    where?: ResenaWhereInput
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    cursor?: ResenaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Usuario.tokensInvalidados
   */
  export type Usuario$tokensInvalidadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenInvalidado
     */
    select?: TokenInvalidadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenInvalidado
     */
    omit?: TokenInvalidadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInvalidadoInclude<ExtArgs> | null
    where?: TokenInvalidadoWhereInput
    orderBy?: TokenInvalidadoOrderByWithRelationInput | TokenInvalidadoOrderByWithRelationInput[]
    cursor?: TokenInvalidadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenInvalidadoScalarFieldEnum | TokenInvalidadoScalarFieldEnum[]
  }

  /**
   * Usuario.usuariosRoles
   */
  export type Usuario$usuariosRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesInclude<ExtArgs> | null
    where?: UsuariosRolesWhereInput
    orderBy?: UsuariosRolesOrderByWithRelationInput | UsuariosRolesOrderByWithRelationInput[]
    cursor?: UsuariosRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuariosRolesScalarFieldEnum | UsuariosRolesScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model UsuariosRoles
   */

  export type AggregateUsuariosRoles = {
    _count: UsuariosRolesCountAggregateOutputType | null
    _avg: UsuariosRolesAvgAggregateOutputType | null
    _sum: UsuariosRolesSumAggregateOutputType | null
    _min: UsuariosRolesMinAggregateOutputType | null
    _max: UsuariosRolesMaxAggregateOutputType | null
  }

  export type UsuariosRolesAvgAggregateOutputType = {
    id: number | null
    rolId: number | null
    usuarioId: number | null
  }

  export type UsuariosRolesSumAggregateOutputType = {
    id: number | null
    rolId: number | null
    usuarioId: number | null
  }

  export type UsuariosRolesMinAggregateOutputType = {
    id: number | null
    rolId: number | null
    usuarioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuariosRolesMaxAggregateOutputType = {
    id: number | null
    rolId: number | null
    usuarioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuariosRolesCountAggregateOutputType = {
    id: number
    rolId: number
    usuarioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsuariosRolesAvgAggregateInputType = {
    id?: true
    rolId?: true
    usuarioId?: true
  }

  export type UsuariosRolesSumAggregateInputType = {
    id?: true
    rolId?: true
    usuarioId?: true
  }

  export type UsuariosRolesMinAggregateInputType = {
    id?: true
    rolId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuariosRolesMaxAggregateInputType = {
    id?: true
    rolId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuariosRolesCountAggregateInputType = {
    id?: true
    rolId?: true
    usuarioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuariosRolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuariosRoles to aggregate.
     */
    where?: UsuariosRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuariosRoles to fetch.
     */
    orderBy?: UsuariosRolesOrderByWithRelationInput | UsuariosRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuariosRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuariosRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuariosRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsuariosRoles
    **/
    _count?: true | UsuariosRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuariosRolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuariosRolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosRolesMaxAggregateInputType
  }

  export type GetUsuariosRolesAggregateType<T extends UsuariosRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuariosRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuariosRoles[P]>
      : GetScalarType<T[P], AggregateUsuariosRoles[P]>
  }




  export type UsuariosRolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuariosRolesWhereInput
    orderBy?: UsuariosRolesOrderByWithAggregationInput | UsuariosRolesOrderByWithAggregationInput[]
    by: UsuariosRolesScalarFieldEnum[] | UsuariosRolesScalarFieldEnum
    having?: UsuariosRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosRolesCountAggregateInputType | true
    _avg?: UsuariosRolesAvgAggregateInputType
    _sum?: UsuariosRolesSumAggregateInputType
    _min?: UsuariosRolesMinAggregateInputType
    _max?: UsuariosRolesMaxAggregateInputType
  }

  export type UsuariosRolesGroupByOutputType = {
    id: number
    rolId: number
    usuarioId: number
    createdAt: Date
    updatedAt: Date
    _count: UsuariosRolesCountAggregateOutputType | null
    _avg: UsuariosRolesAvgAggregateOutputType | null
    _sum: UsuariosRolesSumAggregateOutputType | null
    _min: UsuariosRolesMinAggregateOutputType | null
    _max: UsuariosRolesMaxAggregateOutputType | null
  }

  type GetUsuariosRolesGroupByPayload<T extends UsuariosRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosRolesGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosRolesGroupByOutputType[P]>
        }
      >
    >


  export type UsuariosRolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rolId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rol?: boolean | RoleDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuariosRoles"]>

  export type UsuariosRolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rolId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rol?: boolean | RoleDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuariosRoles"]>

  export type UsuariosRolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rolId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rol?: boolean | RoleDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuariosRoles"]>

  export type UsuariosRolesSelectScalar = {
    id?: boolean
    rolId?: boolean
    usuarioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsuariosRolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rolId" | "usuarioId" | "createdAt" | "updatedAt", ExtArgs["result"]["usuariosRoles"]>
  export type UsuariosRolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rol?: boolean | RoleDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type UsuariosRolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rol?: boolean | RoleDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type UsuariosRolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rol?: boolean | RoleDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $UsuariosRolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsuariosRoles"
    objects: {
      rol: Prisma.$RolePayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rolId: number
      usuarioId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usuariosRoles"]>
    composites: {}
  }

  type UsuariosRolesGetPayload<S extends boolean | null | undefined | UsuariosRolesDefaultArgs> = $Result.GetResult<Prisma.$UsuariosRolesPayload, S>

  type UsuariosRolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuariosRolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuariosRolesCountAggregateInputType | true
    }

  export interface UsuariosRolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsuariosRoles'], meta: { name: 'UsuariosRoles' } }
    /**
     * Find zero or one UsuariosRoles that matches the filter.
     * @param {UsuariosRolesFindUniqueArgs} args - Arguments to find a UsuariosRoles
     * @example
     * // Get one UsuariosRoles
     * const usuariosRoles = await prisma.usuariosRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuariosRolesFindUniqueArgs>(args: SelectSubset<T, UsuariosRolesFindUniqueArgs<ExtArgs>>): Prisma__UsuariosRolesClient<$Result.GetResult<Prisma.$UsuariosRolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsuariosRoles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuariosRolesFindUniqueOrThrowArgs} args - Arguments to find a UsuariosRoles
     * @example
     * // Get one UsuariosRoles
     * const usuariosRoles = await prisma.usuariosRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuariosRolesFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuariosRolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuariosRolesClient<$Result.GetResult<Prisma.$UsuariosRolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuariosRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosRolesFindFirstArgs} args - Arguments to find a UsuariosRoles
     * @example
     * // Get one UsuariosRoles
     * const usuariosRoles = await prisma.usuariosRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuariosRolesFindFirstArgs>(args?: SelectSubset<T, UsuariosRolesFindFirstArgs<ExtArgs>>): Prisma__UsuariosRolesClient<$Result.GetResult<Prisma.$UsuariosRolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuariosRoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosRolesFindFirstOrThrowArgs} args - Arguments to find a UsuariosRoles
     * @example
     * // Get one UsuariosRoles
     * const usuariosRoles = await prisma.usuariosRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuariosRolesFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuariosRolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuariosRolesClient<$Result.GetResult<Prisma.$UsuariosRolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsuariosRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosRolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuariosRoles
     * const usuariosRoles = await prisma.usuariosRoles.findMany()
     * 
     * // Get first 10 UsuariosRoles
     * const usuariosRoles = await prisma.usuariosRoles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuariosRolesWithIdOnly = await prisma.usuariosRoles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuariosRolesFindManyArgs>(args?: SelectSubset<T, UsuariosRolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsuariosRoles.
     * @param {UsuariosRolesCreateArgs} args - Arguments to create a UsuariosRoles.
     * @example
     * // Create one UsuariosRoles
     * const UsuariosRoles = await prisma.usuariosRoles.create({
     *   data: {
     *     // ... data to create a UsuariosRoles
     *   }
     * })
     * 
     */
    create<T extends UsuariosRolesCreateArgs>(args: SelectSubset<T, UsuariosRolesCreateArgs<ExtArgs>>): Prisma__UsuariosRolesClient<$Result.GetResult<Prisma.$UsuariosRolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsuariosRoles.
     * @param {UsuariosRolesCreateManyArgs} args - Arguments to create many UsuariosRoles.
     * @example
     * // Create many UsuariosRoles
     * const usuariosRoles = await prisma.usuariosRoles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuariosRolesCreateManyArgs>(args?: SelectSubset<T, UsuariosRolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsuariosRoles and returns the data saved in the database.
     * @param {UsuariosRolesCreateManyAndReturnArgs} args - Arguments to create many UsuariosRoles.
     * @example
     * // Create many UsuariosRoles
     * const usuariosRoles = await prisma.usuariosRoles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsuariosRoles and only return the `id`
     * const usuariosRolesWithIdOnly = await prisma.usuariosRoles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuariosRolesCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuariosRolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosRolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsuariosRoles.
     * @param {UsuariosRolesDeleteArgs} args - Arguments to delete one UsuariosRoles.
     * @example
     * // Delete one UsuariosRoles
     * const UsuariosRoles = await prisma.usuariosRoles.delete({
     *   where: {
     *     // ... filter to delete one UsuariosRoles
     *   }
     * })
     * 
     */
    delete<T extends UsuariosRolesDeleteArgs>(args: SelectSubset<T, UsuariosRolesDeleteArgs<ExtArgs>>): Prisma__UsuariosRolesClient<$Result.GetResult<Prisma.$UsuariosRolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsuariosRoles.
     * @param {UsuariosRolesUpdateArgs} args - Arguments to update one UsuariosRoles.
     * @example
     * // Update one UsuariosRoles
     * const usuariosRoles = await prisma.usuariosRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuariosRolesUpdateArgs>(args: SelectSubset<T, UsuariosRolesUpdateArgs<ExtArgs>>): Prisma__UsuariosRolesClient<$Result.GetResult<Prisma.$UsuariosRolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsuariosRoles.
     * @param {UsuariosRolesDeleteManyArgs} args - Arguments to filter UsuariosRoles to delete.
     * @example
     * // Delete a few UsuariosRoles
     * const { count } = await prisma.usuariosRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuariosRolesDeleteManyArgs>(args?: SelectSubset<T, UsuariosRolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuariosRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuariosRoles
     * const usuariosRoles = await prisma.usuariosRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuariosRolesUpdateManyArgs>(args: SelectSubset<T, UsuariosRolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuariosRoles and returns the data updated in the database.
     * @param {UsuariosRolesUpdateManyAndReturnArgs} args - Arguments to update many UsuariosRoles.
     * @example
     * // Update many UsuariosRoles
     * const usuariosRoles = await prisma.usuariosRoles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsuariosRoles and only return the `id`
     * const usuariosRolesWithIdOnly = await prisma.usuariosRoles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuariosRolesUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuariosRolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosRolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsuariosRoles.
     * @param {UsuariosRolesUpsertArgs} args - Arguments to update or create a UsuariosRoles.
     * @example
     * // Update or create a UsuariosRoles
     * const usuariosRoles = await prisma.usuariosRoles.upsert({
     *   create: {
     *     // ... data to create a UsuariosRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuariosRoles we want to update
     *   }
     * })
     */
    upsert<T extends UsuariosRolesUpsertArgs>(args: SelectSubset<T, UsuariosRolesUpsertArgs<ExtArgs>>): Prisma__UsuariosRolesClient<$Result.GetResult<Prisma.$UsuariosRolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsuariosRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosRolesCountArgs} args - Arguments to filter UsuariosRoles to count.
     * @example
     * // Count the number of UsuariosRoles
     * const count = await prisma.usuariosRoles.count({
     *   where: {
     *     // ... the filter for the UsuariosRoles we want to count
     *   }
     * })
    **/
    count<T extends UsuariosRolesCountArgs>(
      args?: Subset<T, UsuariosRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuariosRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosRolesAggregateArgs>(args: Subset<T, UsuariosRolesAggregateArgs>): Prisma.PrismaPromise<GetUsuariosRolesAggregateType<T>>

    /**
     * Group by UsuariosRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuariosRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuariosRolesGroupByArgs['orderBy'] }
        : { orderBy?: UsuariosRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuariosRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsuariosRoles model
   */
  readonly fields: UsuariosRolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsuariosRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuariosRolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rol<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsuariosRoles model
   */
  interface UsuariosRolesFieldRefs {
    readonly id: FieldRef<"UsuariosRoles", 'Int'>
    readonly rolId: FieldRef<"UsuariosRoles", 'Int'>
    readonly usuarioId: FieldRef<"UsuariosRoles", 'Int'>
    readonly createdAt: FieldRef<"UsuariosRoles", 'DateTime'>
    readonly updatedAt: FieldRef<"UsuariosRoles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsuariosRoles findUnique
   */
  export type UsuariosRolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesInclude<ExtArgs> | null
    /**
     * Filter, which UsuariosRoles to fetch.
     */
    where: UsuariosRolesWhereUniqueInput
  }

  /**
   * UsuariosRoles findUniqueOrThrow
   */
  export type UsuariosRolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesInclude<ExtArgs> | null
    /**
     * Filter, which UsuariosRoles to fetch.
     */
    where: UsuariosRolesWhereUniqueInput
  }

  /**
   * UsuariosRoles findFirst
   */
  export type UsuariosRolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesInclude<ExtArgs> | null
    /**
     * Filter, which UsuariosRoles to fetch.
     */
    where?: UsuariosRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuariosRoles to fetch.
     */
    orderBy?: UsuariosRolesOrderByWithRelationInput | UsuariosRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuariosRoles.
     */
    cursor?: UsuariosRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuariosRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuariosRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuariosRoles.
     */
    distinct?: UsuariosRolesScalarFieldEnum | UsuariosRolesScalarFieldEnum[]
  }

  /**
   * UsuariosRoles findFirstOrThrow
   */
  export type UsuariosRolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesInclude<ExtArgs> | null
    /**
     * Filter, which UsuariosRoles to fetch.
     */
    where?: UsuariosRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuariosRoles to fetch.
     */
    orderBy?: UsuariosRolesOrderByWithRelationInput | UsuariosRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuariosRoles.
     */
    cursor?: UsuariosRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuariosRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuariosRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuariosRoles.
     */
    distinct?: UsuariosRolesScalarFieldEnum | UsuariosRolesScalarFieldEnum[]
  }

  /**
   * UsuariosRoles findMany
   */
  export type UsuariosRolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesInclude<ExtArgs> | null
    /**
     * Filter, which UsuariosRoles to fetch.
     */
    where?: UsuariosRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuariosRoles to fetch.
     */
    orderBy?: UsuariosRolesOrderByWithRelationInput | UsuariosRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsuariosRoles.
     */
    cursor?: UsuariosRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuariosRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuariosRoles.
     */
    skip?: number
    distinct?: UsuariosRolesScalarFieldEnum | UsuariosRolesScalarFieldEnum[]
  }

  /**
   * UsuariosRoles create
   */
  export type UsuariosRolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesInclude<ExtArgs> | null
    /**
     * The data needed to create a UsuariosRoles.
     */
    data: XOR<UsuariosRolesCreateInput, UsuariosRolesUncheckedCreateInput>
  }

  /**
   * UsuariosRoles createMany
   */
  export type UsuariosRolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsuariosRoles.
     */
    data: UsuariosRolesCreateManyInput | UsuariosRolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsuariosRoles createManyAndReturn
   */
  export type UsuariosRolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * The data used to create many UsuariosRoles.
     */
    data: UsuariosRolesCreateManyInput | UsuariosRolesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsuariosRoles update
   */
  export type UsuariosRolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesInclude<ExtArgs> | null
    /**
     * The data needed to update a UsuariosRoles.
     */
    data: XOR<UsuariosRolesUpdateInput, UsuariosRolesUncheckedUpdateInput>
    /**
     * Choose, which UsuariosRoles to update.
     */
    where: UsuariosRolesWhereUniqueInput
  }

  /**
   * UsuariosRoles updateMany
   */
  export type UsuariosRolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsuariosRoles.
     */
    data: XOR<UsuariosRolesUpdateManyMutationInput, UsuariosRolesUncheckedUpdateManyInput>
    /**
     * Filter which UsuariosRoles to update
     */
    where?: UsuariosRolesWhereInput
    /**
     * Limit how many UsuariosRoles to update.
     */
    limit?: number
  }

  /**
   * UsuariosRoles updateManyAndReturn
   */
  export type UsuariosRolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * The data used to update UsuariosRoles.
     */
    data: XOR<UsuariosRolesUpdateManyMutationInput, UsuariosRolesUncheckedUpdateManyInput>
    /**
     * Filter which UsuariosRoles to update
     */
    where?: UsuariosRolesWhereInput
    /**
     * Limit how many UsuariosRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsuariosRoles upsert
   */
  export type UsuariosRolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesInclude<ExtArgs> | null
    /**
     * The filter to search for the UsuariosRoles to update in case it exists.
     */
    where: UsuariosRolesWhereUniqueInput
    /**
     * In case the UsuariosRoles found by the `where` argument doesn't exist, create a new UsuariosRoles with this data.
     */
    create: XOR<UsuariosRolesCreateInput, UsuariosRolesUncheckedCreateInput>
    /**
     * In case the UsuariosRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuariosRolesUpdateInput, UsuariosRolesUncheckedUpdateInput>
  }

  /**
   * UsuariosRoles delete
   */
  export type UsuariosRolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesInclude<ExtArgs> | null
    /**
     * Filter which UsuariosRoles to delete.
     */
    where: UsuariosRolesWhereUniqueInput
  }

  /**
   * UsuariosRoles deleteMany
   */
  export type UsuariosRolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuariosRoles to delete
     */
    where?: UsuariosRolesWhereInput
    /**
     * Limit how many UsuariosRoles to delete.
     */
    limit?: number
  }

  /**
   * UsuariosRoles without action
   */
  export type UsuariosRolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosRoles
     */
    select?: UsuariosRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuariosRoles
     */
    omit?: UsuariosRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosRolesInclude<ExtArgs> | null
  }


  /**
   * Model Emprendimiento
   */

  export type AggregateEmprendimiento = {
    _count: EmprendimientoCountAggregateOutputType | null
    _avg: EmprendimientoAvgAggregateOutputType | null
    _sum: EmprendimientoSumAggregateOutputType | null
    _min: EmprendimientoMinAggregateOutputType | null
    _max: EmprendimientoMaxAggregateOutputType | null
  }

  export type EmprendimientoAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    subdivisionId: number | null
  }

  export type EmprendimientoSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    subdivisionId: number | null
  }

  export type EmprendimientoMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    nombre: string | null
    descripcion: string | null
    tipo: string | null
    direccion: string | null
    subdivisionId: number | null
    coordenadas: string | null
    contactoTelefono: string | null
    contactoEmail: string | null
    sitioWeb: string | null
    estado: string | null
    fechaAprobacion: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmprendimientoMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    nombre: string | null
    descripcion: string | null
    tipo: string | null
    direccion: string | null
    subdivisionId: number | null
    coordenadas: string | null
    contactoTelefono: string | null
    contactoEmail: string | null
    sitioWeb: string | null
    estado: string | null
    fechaAprobacion: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmprendimientoCountAggregateOutputType = {
    id: number
    usuarioId: number
    nombre: number
    descripcion: number
    tipo: number
    direccion: number
    subdivisionId: number
    coordenadas: number
    contactoTelefono: number
    contactoEmail: number
    sitioWeb: number
    redesSociales: number
    estado: number
    fechaAprobacion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmprendimientoAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    subdivisionId?: true
  }

  export type EmprendimientoSumAggregateInputType = {
    id?: true
    usuarioId?: true
    subdivisionId?: true
  }

  export type EmprendimientoMinAggregateInputType = {
    id?: true
    usuarioId?: true
    nombre?: true
    descripcion?: true
    tipo?: true
    direccion?: true
    subdivisionId?: true
    coordenadas?: true
    contactoTelefono?: true
    contactoEmail?: true
    sitioWeb?: true
    estado?: true
    fechaAprobacion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmprendimientoMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    nombre?: true
    descripcion?: true
    tipo?: true
    direccion?: true
    subdivisionId?: true
    coordenadas?: true
    contactoTelefono?: true
    contactoEmail?: true
    sitioWeb?: true
    estado?: true
    fechaAprobacion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmprendimientoCountAggregateInputType = {
    id?: true
    usuarioId?: true
    nombre?: true
    descripcion?: true
    tipo?: true
    direccion?: true
    subdivisionId?: true
    coordenadas?: true
    contactoTelefono?: true
    contactoEmail?: true
    sitioWeb?: true
    redesSociales?: true
    estado?: true
    fechaAprobacion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmprendimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emprendimiento to aggregate.
     */
    where?: EmprendimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emprendimientos to fetch.
     */
    orderBy?: EmprendimientoOrderByWithRelationInput | EmprendimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmprendimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emprendimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emprendimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emprendimientos
    **/
    _count?: true | EmprendimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmprendimientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmprendimientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmprendimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmprendimientoMaxAggregateInputType
  }

  export type GetEmprendimientoAggregateType<T extends EmprendimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateEmprendimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmprendimiento[P]>
      : GetScalarType<T[P], AggregateEmprendimiento[P]>
  }




  export type EmprendimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmprendimientoWhereInput
    orderBy?: EmprendimientoOrderByWithAggregationInput | EmprendimientoOrderByWithAggregationInput[]
    by: EmprendimientoScalarFieldEnum[] | EmprendimientoScalarFieldEnum
    having?: EmprendimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmprendimientoCountAggregateInputType | true
    _avg?: EmprendimientoAvgAggregateInputType
    _sum?: EmprendimientoSumAggregateInputType
    _min?: EmprendimientoMinAggregateInputType
    _max?: EmprendimientoMaxAggregateInputType
  }

  export type EmprendimientoGroupByOutputType = {
    id: number
    usuarioId: number
    nombre: string
    descripcion: string | null
    tipo: string
    direccion: string | null
    subdivisionId: number | null
    coordenadas: string | null
    contactoTelefono: string | null
    contactoEmail: string | null
    sitioWeb: string | null
    redesSociales: JsonValue | null
    estado: string
    fechaAprobacion: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EmprendimientoCountAggregateOutputType | null
    _avg: EmprendimientoAvgAggregateOutputType | null
    _sum: EmprendimientoSumAggregateOutputType | null
    _min: EmprendimientoMinAggregateOutputType | null
    _max: EmprendimientoMaxAggregateOutputType | null
  }

  type GetEmprendimientoGroupByPayload<T extends EmprendimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmprendimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmprendimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmprendimientoGroupByOutputType[P]>
            : GetScalarType<T[P], EmprendimientoGroupByOutputType[P]>
        }
      >
    >


  export type EmprendimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nombre?: boolean
    descripcion?: boolean
    tipo?: boolean
    direccion?: boolean
    subdivisionId?: boolean
    coordenadas?: boolean
    contactoTelefono?: boolean
    contactoEmail?: boolean
    sitioWeb?: boolean
    redesSociales?: boolean
    estado?: boolean
    fechaAprobacion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subdivision?: boolean | Emprendimiento$subdivisionArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    favoritos?: boolean | Emprendimiento$favoritosArgs<ExtArgs>
    paquetesTuristicos?: boolean | Emprendimiento$paquetesTuristicosArgs<ExtArgs>
    servicios?: boolean | Emprendimiento$serviciosArgs<ExtArgs>
    _count?: boolean | EmprendimientoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emprendimiento"]>

  export type EmprendimientoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nombre?: boolean
    descripcion?: boolean
    tipo?: boolean
    direccion?: boolean
    subdivisionId?: boolean
    coordenadas?: boolean
    contactoTelefono?: boolean
    contactoEmail?: boolean
    sitioWeb?: boolean
    redesSociales?: boolean
    estado?: boolean
    fechaAprobacion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subdivision?: boolean | Emprendimiento$subdivisionArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emprendimiento"]>

  export type EmprendimientoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nombre?: boolean
    descripcion?: boolean
    tipo?: boolean
    direccion?: boolean
    subdivisionId?: boolean
    coordenadas?: boolean
    contactoTelefono?: boolean
    contactoEmail?: boolean
    sitioWeb?: boolean
    redesSociales?: boolean
    estado?: boolean
    fechaAprobacion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subdivision?: boolean | Emprendimiento$subdivisionArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emprendimiento"]>

  export type EmprendimientoSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    nombre?: boolean
    descripcion?: boolean
    tipo?: boolean
    direccion?: boolean
    subdivisionId?: boolean
    coordenadas?: boolean
    contactoTelefono?: boolean
    contactoEmail?: boolean
    sitioWeb?: boolean
    redesSociales?: boolean
    estado?: boolean
    fechaAprobacion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmprendimientoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "nombre" | "descripcion" | "tipo" | "direccion" | "subdivisionId" | "coordenadas" | "contactoTelefono" | "contactoEmail" | "sitioWeb" | "redesSociales" | "estado" | "fechaAprobacion" | "createdAt" | "updatedAt", ExtArgs["result"]["emprendimiento"]>
  export type EmprendimientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subdivision?: boolean | Emprendimiento$subdivisionArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    favoritos?: boolean | Emprendimiento$favoritosArgs<ExtArgs>
    paquetesTuristicos?: boolean | Emprendimiento$paquetesTuristicosArgs<ExtArgs>
    servicios?: boolean | Emprendimiento$serviciosArgs<ExtArgs>
    _count?: boolean | EmprendimientoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmprendimientoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subdivision?: boolean | Emprendimiento$subdivisionArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type EmprendimientoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subdivision?: boolean | Emprendimiento$subdivisionArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $EmprendimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Emprendimiento"
    objects: {
      subdivision: Prisma.$SubdivisionPayload<ExtArgs> | null
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      favoritos: Prisma.$FavoritoPayload<ExtArgs>[]
      paquetesTuristicos: Prisma.$PaqueteTuristicoPayload<ExtArgs>[]
      servicios: Prisma.$ServicioEmprendedorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      nombre: string
      descripcion: string | null
      tipo: string
      direccion: string | null
      subdivisionId: number | null
      coordenadas: string | null
      contactoTelefono: string | null
      contactoEmail: string | null
      sitioWeb: string | null
      redesSociales: Prisma.JsonValue | null
      estado: string
      fechaAprobacion: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emprendimiento"]>
    composites: {}
  }

  type EmprendimientoGetPayload<S extends boolean | null | undefined | EmprendimientoDefaultArgs> = $Result.GetResult<Prisma.$EmprendimientoPayload, S>

  type EmprendimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmprendimientoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmprendimientoCountAggregateInputType | true
    }

  export interface EmprendimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Emprendimiento'], meta: { name: 'Emprendimiento' } }
    /**
     * Find zero or one Emprendimiento that matches the filter.
     * @param {EmprendimientoFindUniqueArgs} args - Arguments to find a Emprendimiento
     * @example
     * // Get one Emprendimiento
     * const emprendimiento = await prisma.emprendimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmprendimientoFindUniqueArgs>(args: SelectSubset<T, EmprendimientoFindUniqueArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Emprendimiento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmprendimientoFindUniqueOrThrowArgs} args - Arguments to find a Emprendimiento
     * @example
     * // Get one Emprendimiento
     * const emprendimiento = await prisma.emprendimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmprendimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, EmprendimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emprendimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoFindFirstArgs} args - Arguments to find a Emprendimiento
     * @example
     * // Get one Emprendimiento
     * const emprendimiento = await prisma.emprendimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmprendimientoFindFirstArgs>(args?: SelectSubset<T, EmprendimientoFindFirstArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Emprendimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoFindFirstOrThrowArgs} args - Arguments to find a Emprendimiento
     * @example
     * // Get one Emprendimiento
     * const emprendimiento = await prisma.emprendimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmprendimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, EmprendimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Emprendimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emprendimientos
     * const emprendimientos = await prisma.emprendimiento.findMany()
     * 
     * // Get first 10 Emprendimientos
     * const emprendimientos = await prisma.emprendimiento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emprendimientoWithIdOnly = await prisma.emprendimiento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmprendimientoFindManyArgs>(args?: SelectSubset<T, EmprendimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Emprendimiento.
     * @param {EmprendimientoCreateArgs} args - Arguments to create a Emprendimiento.
     * @example
     * // Create one Emprendimiento
     * const Emprendimiento = await prisma.emprendimiento.create({
     *   data: {
     *     // ... data to create a Emprendimiento
     *   }
     * })
     * 
     */
    create<T extends EmprendimientoCreateArgs>(args: SelectSubset<T, EmprendimientoCreateArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Emprendimientos.
     * @param {EmprendimientoCreateManyArgs} args - Arguments to create many Emprendimientos.
     * @example
     * // Create many Emprendimientos
     * const emprendimiento = await prisma.emprendimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmprendimientoCreateManyArgs>(args?: SelectSubset<T, EmprendimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Emprendimientos and returns the data saved in the database.
     * @param {EmprendimientoCreateManyAndReturnArgs} args - Arguments to create many Emprendimientos.
     * @example
     * // Create many Emprendimientos
     * const emprendimiento = await prisma.emprendimiento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Emprendimientos and only return the `id`
     * const emprendimientoWithIdOnly = await prisma.emprendimiento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmprendimientoCreateManyAndReturnArgs>(args?: SelectSubset<T, EmprendimientoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Emprendimiento.
     * @param {EmprendimientoDeleteArgs} args - Arguments to delete one Emprendimiento.
     * @example
     * // Delete one Emprendimiento
     * const Emprendimiento = await prisma.emprendimiento.delete({
     *   where: {
     *     // ... filter to delete one Emprendimiento
     *   }
     * })
     * 
     */
    delete<T extends EmprendimientoDeleteArgs>(args: SelectSubset<T, EmprendimientoDeleteArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Emprendimiento.
     * @param {EmprendimientoUpdateArgs} args - Arguments to update one Emprendimiento.
     * @example
     * // Update one Emprendimiento
     * const emprendimiento = await prisma.emprendimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmprendimientoUpdateArgs>(args: SelectSubset<T, EmprendimientoUpdateArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Emprendimientos.
     * @param {EmprendimientoDeleteManyArgs} args - Arguments to filter Emprendimientos to delete.
     * @example
     * // Delete a few Emprendimientos
     * const { count } = await prisma.emprendimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmprendimientoDeleteManyArgs>(args?: SelectSubset<T, EmprendimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emprendimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emprendimientos
     * const emprendimiento = await prisma.emprendimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmprendimientoUpdateManyArgs>(args: SelectSubset<T, EmprendimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emprendimientos and returns the data updated in the database.
     * @param {EmprendimientoUpdateManyAndReturnArgs} args - Arguments to update many Emprendimientos.
     * @example
     * // Update many Emprendimientos
     * const emprendimiento = await prisma.emprendimiento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Emprendimientos and only return the `id`
     * const emprendimientoWithIdOnly = await prisma.emprendimiento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmprendimientoUpdateManyAndReturnArgs>(args: SelectSubset<T, EmprendimientoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Emprendimiento.
     * @param {EmprendimientoUpsertArgs} args - Arguments to update or create a Emprendimiento.
     * @example
     * // Update or create a Emprendimiento
     * const emprendimiento = await prisma.emprendimiento.upsert({
     *   create: {
     *     // ... data to create a Emprendimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emprendimiento we want to update
     *   }
     * })
     */
    upsert<T extends EmprendimientoUpsertArgs>(args: SelectSubset<T, EmprendimientoUpsertArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Emprendimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoCountArgs} args - Arguments to filter Emprendimientos to count.
     * @example
     * // Count the number of Emprendimientos
     * const count = await prisma.emprendimiento.count({
     *   where: {
     *     // ... the filter for the Emprendimientos we want to count
     *   }
     * })
    **/
    count<T extends EmprendimientoCountArgs>(
      args?: Subset<T, EmprendimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmprendimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emprendimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmprendimientoAggregateArgs>(args: Subset<T, EmprendimientoAggregateArgs>): Prisma.PrismaPromise<GetEmprendimientoAggregateType<T>>

    /**
     * Group by Emprendimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmprendimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmprendimientoGroupByArgs['orderBy'] }
        : { orderBy?: EmprendimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmprendimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmprendimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Emprendimiento model
   */
  readonly fields: EmprendimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Emprendimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmprendimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subdivision<T extends Emprendimiento$subdivisionArgs<ExtArgs> = {}>(args?: Subset<T, Emprendimiento$subdivisionArgs<ExtArgs>>): Prisma__SubdivisionClient<$Result.GetResult<Prisma.$SubdivisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    favoritos<T extends Emprendimiento$favoritosArgs<ExtArgs> = {}>(args?: Subset<T, Emprendimiento$favoritosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paquetesTuristicos<T extends Emprendimiento$paquetesTuristicosArgs<ExtArgs> = {}>(args?: Subset<T, Emprendimiento$paquetesTuristicosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    servicios<T extends Emprendimiento$serviciosArgs<ExtArgs> = {}>(args?: Subset<T, Emprendimiento$serviciosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioEmprendedorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Emprendimiento model
   */
  interface EmprendimientoFieldRefs {
    readonly id: FieldRef<"Emprendimiento", 'Int'>
    readonly usuarioId: FieldRef<"Emprendimiento", 'Int'>
    readonly nombre: FieldRef<"Emprendimiento", 'String'>
    readonly descripcion: FieldRef<"Emprendimiento", 'String'>
    readonly tipo: FieldRef<"Emprendimiento", 'String'>
    readonly direccion: FieldRef<"Emprendimiento", 'String'>
    readonly subdivisionId: FieldRef<"Emprendimiento", 'Int'>
    readonly coordenadas: FieldRef<"Emprendimiento", 'String'>
    readonly contactoTelefono: FieldRef<"Emprendimiento", 'String'>
    readonly contactoEmail: FieldRef<"Emprendimiento", 'String'>
    readonly sitioWeb: FieldRef<"Emprendimiento", 'String'>
    readonly redesSociales: FieldRef<"Emprendimiento", 'Json'>
    readonly estado: FieldRef<"Emprendimiento", 'String'>
    readonly fechaAprobacion: FieldRef<"Emprendimiento", 'DateTime'>
    readonly createdAt: FieldRef<"Emprendimiento", 'DateTime'>
    readonly updatedAt: FieldRef<"Emprendimiento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Emprendimiento findUnique
   */
  export type EmprendimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * Filter, which Emprendimiento to fetch.
     */
    where: EmprendimientoWhereUniqueInput
  }

  /**
   * Emprendimiento findUniqueOrThrow
   */
  export type EmprendimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * Filter, which Emprendimiento to fetch.
     */
    where: EmprendimientoWhereUniqueInput
  }

  /**
   * Emprendimiento findFirst
   */
  export type EmprendimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * Filter, which Emprendimiento to fetch.
     */
    where?: EmprendimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emprendimientos to fetch.
     */
    orderBy?: EmprendimientoOrderByWithRelationInput | EmprendimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emprendimientos.
     */
    cursor?: EmprendimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emprendimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emprendimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emprendimientos.
     */
    distinct?: EmprendimientoScalarFieldEnum | EmprendimientoScalarFieldEnum[]
  }

  /**
   * Emprendimiento findFirstOrThrow
   */
  export type EmprendimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * Filter, which Emprendimiento to fetch.
     */
    where?: EmprendimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emprendimientos to fetch.
     */
    orderBy?: EmprendimientoOrderByWithRelationInput | EmprendimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emprendimientos.
     */
    cursor?: EmprendimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emprendimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emprendimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emprendimientos.
     */
    distinct?: EmprendimientoScalarFieldEnum | EmprendimientoScalarFieldEnum[]
  }

  /**
   * Emprendimiento findMany
   */
  export type EmprendimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * Filter, which Emprendimientos to fetch.
     */
    where?: EmprendimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emprendimientos to fetch.
     */
    orderBy?: EmprendimientoOrderByWithRelationInput | EmprendimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emprendimientos.
     */
    cursor?: EmprendimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emprendimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emprendimientos.
     */
    skip?: number
    distinct?: EmprendimientoScalarFieldEnum | EmprendimientoScalarFieldEnum[]
  }

  /**
   * Emprendimiento create
   */
  export type EmprendimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * The data needed to create a Emprendimiento.
     */
    data: XOR<EmprendimientoCreateInput, EmprendimientoUncheckedCreateInput>
  }

  /**
   * Emprendimiento createMany
   */
  export type EmprendimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emprendimientos.
     */
    data: EmprendimientoCreateManyInput | EmprendimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Emprendimiento createManyAndReturn
   */
  export type EmprendimientoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * The data used to create many Emprendimientos.
     */
    data: EmprendimientoCreateManyInput | EmprendimientoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Emprendimiento update
   */
  export type EmprendimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * The data needed to update a Emprendimiento.
     */
    data: XOR<EmprendimientoUpdateInput, EmprendimientoUncheckedUpdateInput>
    /**
     * Choose, which Emprendimiento to update.
     */
    where: EmprendimientoWhereUniqueInput
  }

  /**
   * Emprendimiento updateMany
   */
  export type EmprendimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emprendimientos.
     */
    data: XOR<EmprendimientoUpdateManyMutationInput, EmprendimientoUncheckedUpdateManyInput>
    /**
     * Filter which Emprendimientos to update
     */
    where?: EmprendimientoWhereInput
    /**
     * Limit how many Emprendimientos to update.
     */
    limit?: number
  }

  /**
   * Emprendimiento updateManyAndReturn
   */
  export type EmprendimientoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * The data used to update Emprendimientos.
     */
    data: XOR<EmprendimientoUpdateManyMutationInput, EmprendimientoUncheckedUpdateManyInput>
    /**
     * Filter which Emprendimientos to update
     */
    where?: EmprendimientoWhereInput
    /**
     * Limit how many Emprendimientos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Emprendimiento upsert
   */
  export type EmprendimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * The filter to search for the Emprendimiento to update in case it exists.
     */
    where: EmprendimientoWhereUniqueInput
    /**
     * In case the Emprendimiento found by the `where` argument doesn't exist, create a new Emprendimiento with this data.
     */
    create: XOR<EmprendimientoCreateInput, EmprendimientoUncheckedCreateInput>
    /**
     * In case the Emprendimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmprendimientoUpdateInput, EmprendimientoUncheckedUpdateInput>
  }

  /**
   * Emprendimiento delete
   */
  export type EmprendimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * Filter which Emprendimiento to delete.
     */
    where: EmprendimientoWhereUniqueInput
  }

  /**
   * Emprendimiento deleteMany
   */
  export type EmprendimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emprendimientos to delete
     */
    where?: EmprendimientoWhereInput
    /**
     * Limit how many Emprendimientos to delete.
     */
    limit?: number
  }

  /**
   * Emprendimiento.subdivision
   */
  export type Emprendimiento$subdivisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subdivision
     */
    select?: SubdivisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subdivision
     */
    omit?: SubdivisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubdivisionInclude<ExtArgs> | null
    where?: SubdivisionWhereInput
  }

  /**
   * Emprendimiento.favoritos
   */
  export type Emprendimiento$favoritosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    where?: FavoritoWhereInput
    orderBy?: FavoritoOrderByWithRelationInput | FavoritoOrderByWithRelationInput[]
    cursor?: FavoritoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[]
  }

  /**
   * Emprendimiento.paquetesTuristicos
   */
  export type Emprendimiento$paquetesTuristicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristico
     */
    select?: PaqueteTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristico
     */
    omit?: PaqueteTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoInclude<ExtArgs> | null
    where?: PaqueteTuristicoWhereInput
    orderBy?: PaqueteTuristicoOrderByWithRelationInput | PaqueteTuristicoOrderByWithRelationInput[]
    cursor?: PaqueteTuristicoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaqueteTuristicoScalarFieldEnum | PaqueteTuristicoScalarFieldEnum[]
  }

  /**
   * Emprendimiento.servicios
   */
  export type Emprendimiento$serviciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorInclude<ExtArgs> | null
    where?: ServicioEmprendedorWhereInput
    orderBy?: ServicioEmprendedorOrderByWithRelationInput | ServicioEmprendedorOrderByWithRelationInput[]
    cursor?: ServicioEmprendedorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicioEmprendedorScalarFieldEnum | ServicioEmprendedorScalarFieldEnum[]
  }

  /**
   * Emprendimiento without action
   */
  export type EmprendimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
  }


  /**
   * Model RegistroAcceso
   */

  export type AggregateRegistroAcceso = {
    _count: RegistroAccesoCountAggregateOutputType | null
    _avg: RegistroAccesoAvgAggregateOutputType | null
    _sum: RegistroAccesoSumAggregateOutputType | null
    _min: RegistroAccesoMinAggregateOutputType | null
    _max: RegistroAccesoMaxAggregateOutputType | null
  }

  export type RegistroAccesoAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type RegistroAccesoSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type RegistroAccesoMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    ipAddress: string | null
    userAgent: string | null
    tipoEvento: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegistroAccesoMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    ipAddress: string | null
    userAgent: string | null
    tipoEvento: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegistroAccesoCountAggregateOutputType = {
    id: number
    usuarioId: number
    ipAddress: number
    userAgent: number
    tipoEvento: number
    detalles: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RegistroAccesoAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type RegistroAccesoSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type RegistroAccesoMinAggregateInputType = {
    id?: true
    usuarioId?: true
    ipAddress?: true
    userAgent?: true
    tipoEvento?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegistroAccesoMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    ipAddress?: true
    userAgent?: true
    tipoEvento?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegistroAccesoCountAggregateInputType = {
    id?: true
    usuarioId?: true
    ipAddress?: true
    userAgent?: true
    tipoEvento?: true
    detalles?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RegistroAccesoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegistroAcceso to aggregate.
     */
    where?: RegistroAccesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroAccesos to fetch.
     */
    orderBy?: RegistroAccesoOrderByWithRelationInput | RegistroAccesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegistroAccesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroAccesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroAccesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegistroAccesos
    **/
    _count?: true | RegistroAccesoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegistroAccesoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegistroAccesoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegistroAccesoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegistroAccesoMaxAggregateInputType
  }

  export type GetRegistroAccesoAggregateType<T extends RegistroAccesoAggregateArgs> = {
        [P in keyof T & keyof AggregateRegistroAcceso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegistroAcceso[P]>
      : GetScalarType<T[P], AggregateRegistroAcceso[P]>
  }




  export type RegistroAccesoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistroAccesoWhereInput
    orderBy?: RegistroAccesoOrderByWithAggregationInput | RegistroAccesoOrderByWithAggregationInput[]
    by: RegistroAccesoScalarFieldEnum[] | RegistroAccesoScalarFieldEnum
    having?: RegistroAccesoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegistroAccesoCountAggregateInputType | true
    _avg?: RegistroAccesoAvgAggregateInputType
    _sum?: RegistroAccesoSumAggregateInputType
    _min?: RegistroAccesoMinAggregateInputType
    _max?: RegistroAccesoMaxAggregateInputType
  }

  export type RegistroAccesoGroupByOutputType = {
    id: number
    usuarioId: number
    ipAddress: string
    userAgent: string
    tipoEvento: string
    detalles: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: RegistroAccesoCountAggregateOutputType | null
    _avg: RegistroAccesoAvgAggregateOutputType | null
    _sum: RegistroAccesoSumAggregateOutputType | null
    _min: RegistroAccesoMinAggregateOutputType | null
    _max: RegistroAccesoMaxAggregateOutputType | null
  }

  type GetRegistroAccesoGroupByPayload<T extends RegistroAccesoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegistroAccesoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegistroAccesoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegistroAccesoGroupByOutputType[P]>
            : GetScalarType<T[P], RegistroAccesoGroupByOutputType[P]>
        }
      >
    >


  export type RegistroAccesoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tipoEvento?: boolean
    detalles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registroAcceso"]>

  export type RegistroAccesoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tipoEvento?: boolean
    detalles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registroAcceso"]>

  export type RegistroAccesoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tipoEvento?: boolean
    detalles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registroAcceso"]>

  export type RegistroAccesoSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    tipoEvento?: boolean
    detalles?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RegistroAccesoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "ipAddress" | "userAgent" | "tipoEvento" | "detalles" | "createdAt" | "updatedAt", ExtArgs["result"]["registroAcceso"]>
  export type RegistroAccesoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type RegistroAccesoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type RegistroAccesoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $RegistroAccesoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegistroAcceso"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      ipAddress: string
      userAgent: string
      tipoEvento: string
      detalles: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["registroAcceso"]>
    composites: {}
  }

  type RegistroAccesoGetPayload<S extends boolean | null | undefined | RegistroAccesoDefaultArgs> = $Result.GetResult<Prisma.$RegistroAccesoPayload, S>

  type RegistroAccesoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegistroAccesoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegistroAccesoCountAggregateInputType | true
    }

  export interface RegistroAccesoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegistroAcceso'], meta: { name: 'RegistroAcceso' } }
    /**
     * Find zero or one RegistroAcceso that matches the filter.
     * @param {RegistroAccesoFindUniqueArgs} args - Arguments to find a RegistroAcceso
     * @example
     * // Get one RegistroAcceso
     * const registroAcceso = await prisma.registroAcceso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegistroAccesoFindUniqueArgs>(args: SelectSubset<T, RegistroAccesoFindUniqueArgs<ExtArgs>>): Prisma__RegistroAccesoClient<$Result.GetResult<Prisma.$RegistroAccesoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegistroAcceso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegistroAccesoFindUniqueOrThrowArgs} args - Arguments to find a RegistroAcceso
     * @example
     * // Get one RegistroAcceso
     * const registroAcceso = await prisma.registroAcceso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegistroAccesoFindUniqueOrThrowArgs>(args: SelectSubset<T, RegistroAccesoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegistroAccesoClient<$Result.GetResult<Prisma.$RegistroAccesoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegistroAcceso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAccesoFindFirstArgs} args - Arguments to find a RegistroAcceso
     * @example
     * // Get one RegistroAcceso
     * const registroAcceso = await prisma.registroAcceso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegistroAccesoFindFirstArgs>(args?: SelectSubset<T, RegistroAccesoFindFirstArgs<ExtArgs>>): Prisma__RegistroAccesoClient<$Result.GetResult<Prisma.$RegistroAccesoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegistroAcceso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAccesoFindFirstOrThrowArgs} args - Arguments to find a RegistroAcceso
     * @example
     * // Get one RegistroAcceso
     * const registroAcceso = await prisma.registroAcceso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegistroAccesoFindFirstOrThrowArgs>(args?: SelectSubset<T, RegistroAccesoFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegistroAccesoClient<$Result.GetResult<Prisma.$RegistroAccesoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegistroAccesos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAccesoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegistroAccesos
     * const registroAccesos = await prisma.registroAcceso.findMany()
     * 
     * // Get first 10 RegistroAccesos
     * const registroAccesos = await prisma.registroAcceso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const registroAccesoWithIdOnly = await prisma.registroAcceso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegistroAccesoFindManyArgs>(args?: SelectSubset<T, RegistroAccesoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroAccesoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegistroAcceso.
     * @param {RegistroAccesoCreateArgs} args - Arguments to create a RegistroAcceso.
     * @example
     * // Create one RegistroAcceso
     * const RegistroAcceso = await prisma.registroAcceso.create({
     *   data: {
     *     // ... data to create a RegistroAcceso
     *   }
     * })
     * 
     */
    create<T extends RegistroAccesoCreateArgs>(args: SelectSubset<T, RegistroAccesoCreateArgs<ExtArgs>>): Prisma__RegistroAccesoClient<$Result.GetResult<Prisma.$RegistroAccesoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegistroAccesos.
     * @param {RegistroAccesoCreateManyArgs} args - Arguments to create many RegistroAccesos.
     * @example
     * // Create many RegistroAccesos
     * const registroAcceso = await prisma.registroAcceso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegistroAccesoCreateManyArgs>(args?: SelectSubset<T, RegistroAccesoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RegistroAccesos and returns the data saved in the database.
     * @param {RegistroAccesoCreateManyAndReturnArgs} args - Arguments to create many RegistroAccesos.
     * @example
     * // Create many RegistroAccesos
     * const registroAcceso = await prisma.registroAcceso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RegistroAccesos and only return the `id`
     * const registroAccesoWithIdOnly = await prisma.registroAcceso.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegistroAccesoCreateManyAndReturnArgs>(args?: SelectSubset<T, RegistroAccesoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroAccesoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RegistroAcceso.
     * @param {RegistroAccesoDeleteArgs} args - Arguments to delete one RegistroAcceso.
     * @example
     * // Delete one RegistroAcceso
     * const RegistroAcceso = await prisma.registroAcceso.delete({
     *   where: {
     *     // ... filter to delete one RegistroAcceso
     *   }
     * })
     * 
     */
    delete<T extends RegistroAccesoDeleteArgs>(args: SelectSubset<T, RegistroAccesoDeleteArgs<ExtArgs>>): Prisma__RegistroAccesoClient<$Result.GetResult<Prisma.$RegistroAccesoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegistroAcceso.
     * @param {RegistroAccesoUpdateArgs} args - Arguments to update one RegistroAcceso.
     * @example
     * // Update one RegistroAcceso
     * const registroAcceso = await prisma.registroAcceso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegistroAccesoUpdateArgs>(args: SelectSubset<T, RegistroAccesoUpdateArgs<ExtArgs>>): Prisma__RegistroAccesoClient<$Result.GetResult<Prisma.$RegistroAccesoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegistroAccesos.
     * @param {RegistroAccesoDeleteManyArgs} args - Arguments to filter RegistroAccesos to delete.
     * @example
     * // Delete a few RegistroAccesos
     * const { count } = await prisma.registroAcceso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegistroAccesoDeleteManyArgs>(args?: SelectSubset<T, RegistroAccesoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegistroAccesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAccesoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegistroAccesos
     * const registroAcceso = await prisma.registroAcceso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegistroAccesoUpdateManyArgs>(args: SelectSubset<T, RegistroAccesoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegistroAccesos and returns the data updated in the database.
     * @param {RegistroAccesoUpdateManyAndReturnArgs} args - Arguments to update many RegistroAccesos.
     * @example
     * // Update many RegistroAccesos
     * const registroAcceso = await prisma.registroAcceso.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RegistroAccesos and only return the `id`
     * const registroAccesoWithIdOnly = await prisma.registroAcceso.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegistroAccesoUpdateManyAndReturnArgs>(args: SelectSubset<T, RegistroAccesoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroAccesoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RegistroAcceso.
     * @param {RegistroAccesoUpsertArgs} args - Arguments to update or create a RegistroAcceso.
     * @example
     * // Update or create a RegistroAcceso
     * const registroAcceso = await prisma.registroAcceso.upsert({
     *   create: {
     *     // ... data to create a RegistroAcceso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegistroAcceso we want to update
     *   }
     * })
     */
    upsert<T extends RegistroAccesoUpsertArgs>(args: SelectSubset<T, RegistroAccesoUpsertArgs<ExtArgs>>): Prisma__RegistroAccesoClient<$Result.GetResult<Prisma.$RegistroAccesoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RegistroAccesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAccesoCountArgs} args - Arguments to filter RegistroAccesos to count.
     * @example
     * // Count the number of RegistroAccesos
     * const count = await prisma.registroAcceso.count({
     *   where: {
     *     // ... the filter for the RegistroAccesos we want to count
     *   }
     * })
    **/
    count<T extends RegistroAccesoCountArgs>(
      args?: Subset<T, RegistroAccesoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegistroAccesoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegistroAcceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAccesoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegistroAccesoAggregateArgs>(args: Subset<T, RegistroAccesoAggregateArgs>): Prisma.PrismaPromise<GetRegistroAccesoAggregateType<T>>

    /**
     * Group by RegistroAcceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroAccesoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegistroAccesoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegistroAccesoGroupByArgs['orderBy'] }
        : { orderBy?: RegistroAccesoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegistroAccesoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegistroAccesoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegistroAcceso model
   */
  readonly fields: RegistroAccesoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegistroAcceso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegistroAccesoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegistroAcceso model
   */
  interface RegistroAccesoFieldRefs {
    readonly id: FieldRef<"RegistroAcceso", 'Int'>
    readonly usuarioId: FieldRef<"RegistroAcceso", 'Int'>
    readonly ipAddress: FieldRef<"RegistroAcceso", 'String'>
    readonly userAgent: FieldRef<"RegistroAcceso", 'String'>
    readonly tipoEvento: FieldRef<"RegistroAcceso", 'String'>
    readonly detalles: FieldRef<"RegistroAcceso", 'Json'>
    readonly createdAt: FieldRef<"RegistroAcceso", 'DateTime'>
    readonly updatedAt: FieldRef<"RegistroAcceso", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RegistroAcceso findUnique
   */
  export type RegistroAccesoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAcceso
     */
    select?: RegistroAccesoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroAcceso
     */
    omit?: RegistroAccesoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAccesoInclude<ExtArgs> | null
    /**
     * Filter, which RegistroAcceso to fetch.
     */
    where: RegistroAccesoWhereUniqueInput
  }

  /**
   * RegistroAcceso findUniqueOrThrow
   */
  export type RegistroAccesoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAcceso
     */
    select?: RegistroAccesoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroAcceso
     */
    omit?: RegistroAccesoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAccesoInclude<ExtArgs> | null
    /**
     * Filter, which RegistroAcceso to fetch.
     */
    where: RegistroAccesoWhereUniqueInput
  }

  /**
   * RegistroAcceso findFirst
   */
  export type RegistroAccesoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAcceso
     */
    select?: RegistroAccesoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroAcceso
     */
    omit?: RegistroAccesoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAccesoInclude<ExtArgs> | null
    /**
     * Filter, which RegistroAcceso to fetch.
     */
    where?: RegistroAccesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroAccesos to fetch.
     */
    orderBy?: RegistroAccesoOrderByWithRelationInput | RegistroAccesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegistroAccesos.
     */
    cursor?: RegistroAccesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroAccesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroAccesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegistroAccesos.
     */
    distinct?: RegistroAccesoScalarFieldEnum | RegistroAccesoScalarFieldEnum[]
  }

  /**
   * RegistroAcceso findFirstOrThrow
   */
  export type RegistroAccesoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAcceso
     */
    select?: RegistroAccesoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroAcceso
     */
    omit?: RegistroAccesoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAccesoInclude<ExtArgs> | null
    /**
     * Filter, which RegistroAcceso to fetch.
     */
    where?: RegistroAccesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroAccesos to fetch.
     */
    orderBy?: RegistroAccesoOrderByWithRelationInput | RegistroAccesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegistroAccesos.
     */
    cursor?: RegistroAccesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroAccesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroAccesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegistroAccesos.
     */
    distinct?: RegistroAccesoScalarFieldEnum | RegistroAccesoScalarFieldEnum[]
  }

  /**
   * RegistroAcceso findMany
   */
  export type RegistroAccesoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAcceso
     */
    select?: RegistroAccesoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroAcceso
     */
    omit?: RegistroAccesoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAccesoInclude<ExtArgs> | null
    /**
     * Filter, which RegistroAccesos to fetch.
     */
    where?: RegistroAccesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroAccesos to fetch.
     */
    orderBy?: RegistroAccesoOrderByWithRelationInput | RegistroAccesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegistroAccesos.
     */
    cursor?: RegistroAccesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroAccesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroAccesos.
     */
    skip?: number
    distinct?: RegistroAccesoScalarFieldEnum | RegistroAccesoScalarFieldEnum[]
  }

  /**
   * RegistroAcceso create
   */
  export type RegistroAccesoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAcceso
     */
    select?: RegistroAccesoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroAcceso
     */
    omit?: RegistroAccesoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAccesoInclude<ExtArgs> | null
    /**
     * The data needed to create a RegistroAcceso.
     */
    data: XOR<RegistroAccesoCreateInput, RegistroAccesoUncheckedCreateInput>
  }

  /**
   * RegistroAcceso createMany
   */
  export type RegistroAccesoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegistroAccesos.
     */
    data: RegistroAccesoCreateManyInput | RegistroAccesoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegistroAcceso createManyAndReturn
   */
  export type RegistroAccesoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAcceso
     */
    select?: RegistroAccesoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroAcceso
     */
    omit?: RegistroAccesoOmit<ExtArgs> | null
    /**
     * The data used to create many RegistroAccesos.
     */
    data: RegistroAccesoCreateManyInput | RegistroAccesoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAccesoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegistroAcceso update
   */
  export type RegistroAccesoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAcceso
     */
    select?: RegistroAccesoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroAcceso
     */
    omit?: RegistroAccesoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAccesoInclude<ExtArgs> | null
    /**
     * The data needed to update a RegistroAcceso.
     */
    data: XOR<RegistroAccesoUpdateInput, RegistroAccesoUncheckedUpdateInput>
    /**
     * Choose, which RegistroAcceso to update.
     */
    where: RegistroAccesoWhereUniqueInput
  }

  /**
   * RegistroAcceso updateMany
   */
  export type RegistroAccesoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegistroAccesos.
     */
    data: XOR<RegistroAccesoUpdateManyMutationInput, RegistroAccesoUncheckedUpdateManyInput>
    /**
     * Filter which RegistroAccesos to update
     */
    where?: RegistroAccesoWhereInput
    /**
     * Limit how many RegistroAccesos to update.
     */
    limit?: number
  }

  /**
   * RegistroAcceso updateManyAndReturn
   */
  export type RegistroAccesoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAcceso
     */
    select?: RegistroAccesoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroAcceso
     */
    omit?: RegistroAccesoOmit<ExtArgs> | null
    /**
     * The data used to update RegistroAccesos.
     */
    data: XOR<RegistroAccesoUpdateManyMutationInput, RegistroAccesoUncheckedUpdateManyInput>
    /**
     * Filter which RegistroAccesos to update
     */
    where?: RegistroAccesoWhereInput
    /**
     * Limit how many RegistroAccesos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAccesoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegistroAcceso upsert
   */
  export type RegistroAccesoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAcceso
     */
    select?: RegistroAccesoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroAcceso
     */
    omit?: RegistroAccesoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAccesoInclude<ExtArgs> | null
    /**
     * The filter to search for the RegistroAcceso to update in case it exists.
     */
    where: RegistroAccesoWhereUniqueInput
    /**
     * In case the RegistroAcceso found by the `where` argument doesn't exist, create a new RegistroAcceso with this data.
     */
    create: XOR<RegistroAccesoCreateInput, RegistroAccesoUncheckedCreateInput>
    /**
     * In case the RegistroAcceso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegistroAccesoUpdateInput, RegistroAccesoUncheckedUpdateInput>
  }

  /**
   * RegistroAcceso delete
   */
  export type RegistroAccesoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAcceso
     */
    select?: RegistroAccesoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroAcceso
     */
    omit?: RegistroAccesoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAccesoInclude<ExtArgs> | null
    /**
     * Filter which RegistroAcceso to delete.
     */
    where: RegistroAccesoWhereUniqueInput
  }

  /**
   * RegistroAcceso deleteMany
   */
  export type RegistroAccesoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegistroAccesos to delete
     */
    where?: RegistroAccesoWhereInput
    /**
     * Limit how many RegistroAccesos to delete.
     */
    limit?: number
  }

  /**
   * RegistroAcceso without action
   */
  export type RegistroAccesoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroAcceso
     */
    select?: RegistroAccesoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroAcceso
     */
    omit?: RegistroAccesoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroAccesoInclude<ExtArgs> | null
  }


  /**
   * Model TokenInvalidado
   */

  export type AggregateTokenInvalidado = {
    _count: TokenInvalidadoCountAggregateOutputType | null
    _avg: TokenInvalidadoAvgAggregateOutputType | null
    _sum: TokenInvalidadoSumAggregateOutputType | null
    _min: TokenInvalidadoMinAggregateOutputType | null
    _max: TokenInvalidadoMaxAggregateOutputType | null
  }

  export type TokenInvalidadoAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type TokenInvalidadoSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type TokenInvalidadoMinAggregateOutputType = {
    id: number | null
    tokenHash: string | null
    usuarioId: number | null
    invalidadoEn: Date | null
    expiraEn: Date | null
    createdAt: Date | null
  }

  export type TokenInvalidadoMaxAggregateOutputType = {
    id: number | null
    tokenHash: string | null
    usuarioId: number | null
    invalidadoEn: Date | null
    expiraEn: Date | null
    createdAt: Date | null
  }

  export type TokenInvalidadoCountAggregateOutputType = {
    id: number
    tokenHash: number
    usuarioId: number
    invalidadoEn: number
    expiraEn: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type TokenInvalidadoAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type TokenInvalidadoSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type TokenInvalidadoMinAggregateInputType = {
    id?: true
    tokenHash?: true
    usuarioId?: true
    invalidadoEn?: true
    expiraEn?: true
    createdAt?: true
  }

  export type TokenInvalidadoMaxAggregateInputType = {
    id?: true
    tokenHash?: true
    usuarioId?: true
    invalidadoEn?: true
    expiraEn?: true
    createdAt?: true
  }

  export type TokenInvalidadoCountAggregateInputType = {
    id?: true
    tokenHash?: true
    usuarioId?: true
    invalidadoEn?: true
    expiraEn?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type TokenInvalidadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenInvalidado to aggregate.
     */
    where?: TokenInvalidadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenInvalidados to fetch.
     */
    orderBy?: TokenInvalidadoOrderByWithRelationInput | TokenInvalidadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenInvalidadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenInvalidados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenInvalidados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokenInvalidados
    **/
    _count?: true | TokenInvalidadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenInvalidadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenInvalidadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenInvalidadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenInvalidadoMaxAggregateInputType
  }

  export type GetTokenInvalidadoAggregateType<T extends TokenInvalidadoAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenInvalidado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenInvalidado[P]>
      : GetScalarType<T[P], AggregateTokenInvalidado[P]>
  }




  export type TokenInvalidadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenInvalidadoWhereInput
    orderBy?: TokenInvalidadoOrderByWithAggregationInput | TokenInvalidadoOrderByWithAggregationInput[]
    by: TokenInvalidadoScalarFieldEnum[] | TokenInvalidadoScalarFieldEnum
    having?: TokenInvalidadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenInvalidadoCountAggregateInputType | true
    _avg?: TokenInvalidadoAvgAggregateInputType
    _sum?: TokenInvalidadoSumAggregateInputType
    _min?: TokenInvalidadoMinAggregateInputType
    _max?: TokenInvalidadoMaxAggregateInputType
  }

  export type TokenInvalidadoGroupByOutputType = {
    id: number
    tokenHash: string
    usuarioId: number
    invalidadoEn: Date
    expiraEn: Date
    metadata: JsonValue
    createdAt: Date
    _count: TokenInvalidadoCountAggregateOutputType | null
    _avg: TokenInvalidadoAvgAggregateOutputType | null
    _sum: TokenInvalidadoSumAggregateOutputType | null
    _min: TokenInvalidadoMinAggregateOutputType | null
    _max: TokenInvalidadoMaxAggregateOutputType | null
  }

  type GetTokenInvalidadoGroupByPayload<T extends TokenInvalidadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenInvalidadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenInvalidadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenInvalidadoGroupByOutputType[P]>
            : GetScalarType<T[P], TokenInvalidadoGroupByOutputType[P]>
        }
      >
    >


  export type TokenInvalidadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenHash?: boolean
    usuarioId?: boolean
    invalidadoEn?: boolean
    expiraEn?: boolean
    metadata?: boolean
    createdAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenInvalidado"]>

  export type TokenInvalidadoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenHash?: boolean
    usuarioId?: boolean
    invalidadoEn?: boolean
    expiraEn?: boolean
    metadata?: boolean
    createdAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenInvalidado"]>

  export type TokenInvalidadoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenHash?: boolean
    usuarioId?: boolean
    invalidadoEn?: boolean
    expiraEn?: boolean
    metadata?: boolean
    createdAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenInvalidado"]>

  export type TokenInvalidadoSelectScalar = {
    id?: boolean
    tokenHash?: boolean
    usuarioId?: boolean
    invalidadoEn?: boolean
    expiraEn?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type TokenInvalidadoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tokenHash" | "usuarioId" | "invalidadoEn" | "expiraEn" | "metadata" | "createdAt", ExtArgs["result"]["tokenInvalidado"]>
  export type TokenInvalidadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type TokenInvalidadoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type TokenInvalidadoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $TokenInvalidadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TokenInvalidado"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tokenHash: string
      usuarioId: number
      invalidadoEn: Date
      expiraEn: Date
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["tokenInvalidado"]>
    composites: {}
  }

  type TokenInvalidadoGetPayload<S extends boolean | null | undefined | TokenInvalidadoDefaultArgs> = $Result.GetResult<Prisma.$TokenInvalidadoPayload, S>

  type TokenInvalidadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TokenInvalidadoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokenInvalidadoCountAggregateInputType | true
    }

  export interface TokenInvalidadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TokenInvalidado'], meta: { name: 'TokenInvalidado' } }
    /**
     * Find zero or one TokenInvalidado that matches the filter.
     * @param {TokenInvalidadoFindUniqueArgs} args - Arguments to find a TokenInvalidado
     * @example
     * // Get one TokenInvalidado
     * const tokenInvalidado = await prisma.tokenInvalidado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenInvalidadoFindUniqueArgs>(args: SelectSubset<T, TokenInvalidadoFindUniqueArgs<ExtArgs>>): Prisma__TokenInvalidadoClient<$Result.GetResult<Prisma.$TokenInvalidadoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TokenInvalidado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TokenInvalidadoFindUniqueOrThrowArgs} args - Arguments to find a TokenInvalidado
     * @example
     * // Get one TokenInvalidado
     * const tokenInvalidado = await prisma.tokenInvalidado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenInvalidadoFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenInvalidadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenInvalidadoClient<$Result.GetResult<Prisma.$TokenInvalidadoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TokenInvalidado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenInvalidadoFindFirstArgs} args - Arguments to find a TokenInvalidado
     * @example
     * // Get one TokenInvalidado
     * const tokenInvalidado = await prisma.tokenInvalidado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenInvalidadoFindFirstArgs>(args?: SelectSubset<T, TokenInvalidadoFindFirstArgs<ExtArgs>>): Prisma__TokenInvalidadoClient<$Result.GetResult<Prisma.$TokenInvalidadoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TokenInvalidado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenInvalidadoFindFirstOrThrowArgs} args - Arguments to find a TokenInvalidado
     * @example
     * // Get one TokenInvalidado
     * const tokenInvalidado = await prisma.tokenInvalidado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenInvalidadoFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenInvalidadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenInvalidadoClient<$Result.GetResult<Prisma.$TokenInvalidadoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TokenInvalidados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenInvalidadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenInvalidados
     * const tokenInvalidados = await prisma.tokenInvalidado.findMany()
     * 
     * // Get first 10 TokenInvalidados
     * const tokenInvalidados = await prisma.tokenInvalidado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenInvalidadoWithIdOnly = await prisma.tokenInvalidado.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenInvalidadoFindManyArgs>(args?: SelectSubset<T, TokenInvalidadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenInvalidadoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TokenInvalidado.
     * @param {TokenInvalidadoCreateArgs} args - Arguments to create a TokenInvalidado.
     * @example
     * // Create one TokenInvalidado
     * const TokenInvalidado = await prisma.tokenInvalidado.create({
     *   data: {
     *     // ... data to create a TokenInvalidado
     *   }
     * })
     * 
     */
    create<T extends TokenInvalidadoCreateArgs>(args: SelectSubset<T, TokenInvalidadoCreateArgs<ExtArgs>>): Prisma__TokenInvalidadoClient<$Result.GetResult<Prisma.$TokenInvalidadoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TokenInvalidados.
     * @param {TokenInvalidadoCreateManyArgs} args - Arguments to create many TokenInvalidados.
     * @example
     * // Create many TokenInvalidados
     * const tokenInvalidado = await prisma.tokenInvalidado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenInvalidadoCreateManyArgs>(args?: SelectSubset<T, TokenInvalidadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TokenInvalidados and returns the data saved in the database.
     * @param {TokenInvalidadoCreateManyAndReturnArgs} args - Arguments to create many TokenInvalidados.
     * @example
     * // Create many TokenInvalidados
     * const tokenInvalidado = await prisma.tokenInvalidado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TokenInvalidados and only return the `id`
     * const tokenInvalidadoWithIdOnly = await prisma.tokenInvalidado.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenInvalidadoCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenInvalidadoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenInvalidadoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TokenInvalidado.
     * @param {TokenInvalidadoDeleteArgs} args - Arguments to delete one TokenInvalidado.
     * @example
     * // Delete one TokenInvalidado
     * const TokenInvalidado = await prisma.tokenInvalidado.delete({
     *   where: {
     *     // ... filter to delete one TokenInvalidado
     *   }
     * })
     * 
     */
    delete<T extends TokenInvalidadoDeleteArgs>(args: SelectSubset<T, TokenInvalidadoDeleteArgs<ExtArgs>>): Prisma__TokenInvalidadoClient<$Result.GetResult<Prisma.$TokenInvalidadoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TokenInvalidado.
     * @param {TokenInvalidadoUpdateArgs} args - Arguments to update one TokenInvalidado.
     * @example
     * // Update one TokenInvalidado
     * const tokenInvalidado = await prisma.tokenInvalidado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenInvalidadoUpdateArgs>(args: SelectSubset<T, TokenInvalidadoUpdateArgs<ExtArgs>>): Prisma__TokenInvalidadoClient<$Result.GetResult<Prisma.$TokenInvalidadoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TokenInvalidados.
     * @param {TokenInvalidadoDeleteManyArgs} args - Arguments to filter TokenInvalidados to delete.
     * @example
     * // Delete a few TokenInvalidados
     * const { count } = await prisma.tokenInvalidado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenInvalidadoDeleteManyArgs>(args?: SelectSubset<T, TokenInvalidadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenInvalidados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenInvalidadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenInvalidados
     * const tokenInvalidado = await prisma.tokenInvalidado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenInvalidadoUpdateManyArgs>(args: SelectSubset<T, TokenInvalidadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenInvalidados and returns the data updated in the database.
     * @param {TokenInvalidadoUpdateManyAndReturnArgs} args - Arguments to update many TokenInvalidados.
     * @example
     * // Update many TokenInvalidados
     * const tokenInvalidado = await prisma.tokenInvalidado.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TokenInvalidados and only return the `id`
     * const tokenInvalidadoWithIdOnly = await prisma.tokenInvalidado.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TokenInvalidadoUpdateManyAndReturnArgs>(args: SelectSubset<T, TokenInvalidadoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenInvalidadoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TokenInvalidado.
     * @param {TokenInvalidadoUpsertArgs} args - Arguments to update or create a TokenInvalidado.
     * @example
     * // Update or create a TokenInvalidado
     * const tokenInvalidado = await prisma.tokenInvalidado.upsert({
     *   create: {
     *     // ... data to create a TokenInvalidado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenInvalidado we want to update
     *   }
     * })
     */
    upsert<T extends TokenInvalidadoUpsertArgs>(args: SelectSubset<T, TokenInvalidadoUpsertArgs<ExtArgs>>): Prisma__TokenInvalidadoClient<$Result.GetResult<Prisma.$TokenInvalidadoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TokenInvalidados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenInvalidadoCountArgs} args - Arguments to filter TokenInvalidados to count.
     * @example
     * // Count the number of TokenInvalidados
     * const count = await prisma.tokenInvalidado.count({
     *   where: {
     *     // ... the filter for the TokenInvalidados we want to count
     *   }
     * })
    **/
    count<T extends TokenInvalidadoCountArgs>(
      args?: Subset<T, TokenInvalidadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenInvalidadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenInvalidado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenInvalidadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenInvalidadoAggregateArgs>(args: Subset<T, TokenInvalidadoAggregateArgs>): Prisma.PrismaPromise<GetTokenInvalidadoAggregateType<T>>

    /**
     * Group by TokenInvalidado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenInvalidadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenInvalidadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenInvalidadoGroupByArgs['orderBy'] }
        : { orderBy?: TokenInvalidadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenInvalidadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenInvalidadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TokenInvalidado model
   */
  readonly fields: TokenInvalidadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TokenInvalidado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenInvalidadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TokenInvalidado model
   */
  interface TokenInvalidadoFieldRefs {
    readonly id: FieldRef<"TokenInvalidado", 'Int'>
    readonly tokenHash: FieldRef<"TokenInvalidado", 'String'>
    readonly usuarioId: FieldRef<"TokenInvalidado", 'Int'>
    readonly invalidadoEn: FieldRef<"TokenInvalidado", 'DateTime'>
    readonly expiraEn: FieldRef<"TokenInvalidado", 'DateTime'>
    readonly metadata: FieldRef<"TokenInvalidado", 'Json'>
    readonly createdAt: FieldRef<"TokenInvalidado", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TokenInvalidado findUnique
   */
  export type TokenInvalidadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenInvalidado
     */
    select?: TokenInvalidadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenInvalidado
     */
    omit?: TokenInvalidadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInvalidadoInclude<ExtArgs> | null
    /**
     * Filter, which TokenInvalidado to fetch.
     */
    where: TokenInvalidadoWhereUniqueInput
  }

  /**
   * TokenInvalidado findUniqueOrThrow
   */
  export type TokenInvalidadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenInvalidado
     */
    select?: TokenInvalidadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenInvalidado
     */
    omit?: TokenInvalidadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInvalidadoInclude<ExtArgs> | null
    /**
     * Filter, which TokenInvalidado to fetch.
     */
    where: TokenInvalidadoWhereUniqueInput
  }

  /**
   * TokenInvalidado findFirst
   */
  export type TokenInvalidadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenInvalidado
     */
    select?: TokenInvalidadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenInvalidado
     */
    omit?: TokenInvalidadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInvalidadoInclude<ExtArgs> | null
    /**
     * Filter, which TokenInvalidado to fetch.
     */
    where?: TokenInvalidadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenInvalidados to fetch.
     */
    orderBy?: TokenInvalidadoOrderByWithRelationInput | TokenInvalidadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenInvalidados.
     */
    cursor?: TokenInvalidadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenInvalidados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenInvalidados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenInvalidados.
     */
    distinct?: TokenInvalidadoScalarFieldEnum | TokenInvalidadoScalarFieldEnum[]
  }

  /**
   * TokenInvalidado findFirstOrThrow
   */
  export type TokenInvalidadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenInvalidado
     */
    select?: TokenInvalidadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenInvalidado
     */
    omit?: TokenInvalidadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInvalidadoInclude<ExtArgs> | null
    /**
     * Filter, which TokenInvalidado to fetch.
     */
    where?: TokenInvalidadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenInvalidados to fetch.
     */
    orderBy?: TokenInvalidadoOrderByWithRelationInput | TokenInvalidadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenInvalidados.
     */
    cursor?: TokenInvalidadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenInvalidados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenInvalidados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenInvalidados.
     */
    distinct?: TokenInvalidadoScalarFieldEnum | TokenInvalidadoScalarFieldEnum[]
  }

  /**
   * TokenInvalidado findMany
   */
  export type TokenInvalidadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenInvalidado
     */
    select?: TokenInvalidadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenInvalidado
     */
    omit?: TokenInvalidadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInvalidadoInclude<ExtArgs> | null
    /**
     * Filter, which TokenInvalidados to fetch.
     */
    where?: TokenInvalidadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenInvalidados to fetch.
     */
    orderBy?: TokenInvalidadoOrderByWithRelationInput | TokenInvalidadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokenInvalidados.
     */
    cursor?: TokenInvalidadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenInvalidados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenInvalidados.
     */
    skip?: number
    distinct?: TokenInvalidadoScalarFieldEnum | TokenInvalidadoScalarFieldEnum[]
  }

  /**
   * TokenInvalidado create
   */
  export type TokenInvalidadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenInvalidado
     */
    select?: TokenInvalidadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenInvalidado
     */
    omit?: TokenInvalidadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInvalidadoInclude<ExtArgs> | null
    /**
     * The data needed to create a TokenInvalidado.
     */
    data: XOR<TokenInvalidadoCreateInput, TokenInvalidadoUncheckedCreateInput>
  }

  /**
   * TokenInvalidado createMany
   */
  export type TokenInvalidadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TokenInvalidados.
     */
    data: TokenInvalidadoCreateManyInput | TokenInvalidadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TokenInvalidado createManyAndReturn
   */
  export type TokenInvalidadoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenInvalidado
     */
    select?: TokenInvalidadoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TokenInvalidado
     */
    omit?: TokenInvalidadoOmit<ExtArgs> | null
    /**
     * The data used to create many TokenInvalidados.
     */
    data: TokenInvalidadoCreateManyInput | TokenInvalidadoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInvalidadoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TokenInvalidado update
   */
  export type TokenInvalidadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenInvalidado
     */
    select?: TokenInvalidadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenInvalidado
     */
    omit?: TokenInvalidadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInvalidadoInclude<ExtArgs> | null
    /**
     * The data needed to update a TokenInvalidado.
     */
    data: XOR<TokenInvalidadoUpdateInput, TokenInvalidadoUncheckedUpdateInput>
    /**
     * Choose, which TokenInvalidado to update.
     */
    where: TokenInvalidadoWhereUniqueInput
  }

  /**
   * TokenInvalidado updateMany
   */
  export type TokenInvalidadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TokenInvalidados.
     */
    data: XOR<TokenInvalidadoUpdateManyMutationInput, TokenInvalidadoUncheckedUpdateManyInput>
    /**
     * Filter which TokenInvalidados to update
     */
    where?: TokenInvalidadoWhereInput
    /**
     * Limit how many TokenInvalidados to update.
     */
    limit?: number
  }

  /**
   * TokenInvalidado updateManyAndReturn
   */
  export type TokenInvalidadoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenInvalidado
     */
    select?: TokenInvalidadoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TokenInvalidado
     */
    omit?: TokenInvalidadoOmit<ExtArgs> | null
    /**
     * The data used to update TokenInvalidados.
     */
    data: XOR<TokenInvalidadoUpdateManyMutationInput, TokenInvalidadoUncheckedUpdateManyInput>
    /**
     * Filter which TokenInvalidados to update
     */
    where?: TokenInvalidadoWhereInput
    /**
     * Limit how many TokenInvalidados to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInvalidadoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TokenInvalidado upsert
   */
  export type TokenInvalidadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenInvalidado
     */
    select?: TokenInvalidadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenInvalidado
     */
    omit?: TokenInvalidadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInvalidadoInclude<ExtArgs> | null
    /**
     * The filter to search for the TokenInvalidado to update in case it exists.
     */
    where: TokenInvalidadoWhereUniqueInput
    /**
     * In case the TokenInvalidado found by the `where` argument doesn't exist, create a new TokenInvalidado with this data.
     */
    create: XOR<TokenInvalidadoCreateInput, TokenInvalidadoUncheckedCreateInput>
    /**
     * In case the TokenInvalidado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenInvalidadoUpdateInput, TokenInvalidadoUncheckedUpdateInput>
  }

  /**
   * TokenInvalidado delete
   */
  export type TokenInvalidadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenInvalidado
     */
    select?: TokenInvalidadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenInvalidado
     */
    omit?: TokenInvalidadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInvalidadoInclude<ExtArgs> | null
    /**
     * Filter which TokenInvalidado to delete.
     */
    where: TokenInvalidadoWhereUniqueInput
  }

  /**
   * TokenInvalidado deleteMany
   */
  export type TokenInvalidadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenInvalidados to delete
     */
    where?: TokenInvalidadoWhereInput
    /**
     * Limit how many TokenInvalidados to delete.
     */
    limit?: number
  }

  /**
   * TokenInvalidado without action
   */
  export type TokenInvalidadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenInvalidado
     */
    select?: TokenInvalidadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenInvalidado
     */
    omit?: TokenInvalidadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInvalidadoInclude<ExtArgs> | null
  }


  /**
   * Model Turista
   */

  export type AggregateTurista = {
    _count: TuristaCountAggregateOutputType | null
    _avg: TuristaAvgAggregateOutputType | null
    _sum: TuristaSumAggregateOutputType | null
    _min: TuristaMinAggregateOutputType | null
    _max: TuristaMaxAggregateOutputType | null
  }

  export type TuristaAvgAggregateOutputType = {
    id: number | null
    edad: Decimal | null
  }

  export type TuristaSumAggregateOutputType = {
    id: number | null
    edad: Decimal | null
  }

  export type TuristaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellidos: string | null
    telefono: string | null
    direccion: string | null
    edad: Decimal | null
    sexo: string | null
    pais: string | null
    peticionesEspeciales: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TuristaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellidos: string | null
    telefono: string | null
    direccion: string | null
    edad: Decimal | null
    sexo: string | null
    pais: string | null
    peticionesEspeciales: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TuristaCountAggregateOutputType = {
    id: number
    nombre: number
    apellidos: number
    telefono: number
    direccion: number
    edad: number
    sexo: number
    pais: number
    peticionesEspeciales: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TuristaAvgAggregateInputType = {
    id?: true
    edad?: true
  }

  export type TuristaSumAggregateInputType = {
    id?: true
    edad?: true
  }

  export type TuristaMinAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    telefono?: true
    direccion?: true
    edad?: true
    sexo?: true
    pais?: true
    peticionesEspeciales?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TuristaMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    telefono?: true
    direccion?: true
    edad?: true
    sexo?: true
    pais?: true
    peticionesEspeciales?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TuristaCountAggregateInputType = {
    id?: true
    nombre?: true
    apellidos?: true
    telefono?: true
    direccion?: true
    edad?: true
    sexo?: true
    pais?: true
    peticionesEspeciales?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TuristaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Turista to aggregate.
     */
    where?: TuristaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Turistas to fetch.
     */
    orderBy?: TuristaOrderByWithRelationInput | TuristaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TuristaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Turistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Turistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Turistas
    **/
    _count?: true | TuristaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TuristaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TuristaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TuristaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TuristaMaxAggregateInputType
  }

  export type GetTuristaAggregateType<T extends TuristaAggregateArgs> = {
        [P in keyof T & keyof AggregateTurista]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTurista[P]>
      : GetScalarType<T[P], AggregateTurista[P]>
  }




  export type TuristaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TuristaWhereInput
    orderBy?: TuristaOrderByWithAggregationInput | TuristaOrderByWithAggregationInput[]
    by: TuristaScalarFieldEnum[] | TuristaScalarFieldEnum
    having?: TuristaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TuristaCountAggregateInputType | true
    _avg?: TuristaAvgAggregateInputType
    _sum?: TuristaSumAggregateInputType
    _min?: TuristaMinAggregateInputType
    _max?: TuristaMaxAggregateInputType
  }

  export type TuristaGroupByOutputType = {
    id: number
    nombre: string
    apellidos: string
    telefono: string
    direccion: string
    edad: Decimal
    sexo: string
    pais: string
    peticionesEspeciales: string | null
    email: string
    createdAt: Date
    updatedAt: Date
    _count: TuristaCountAggregateOutputType | null
    _avg: TuristaAvgAggregateOutputType | null
    _sum: TuristaSumAggregateOutputType | null
    _min: TuristaMinAggregateOutputType | null
    _max: TuristaMaxAggregateOutputType | null
  }

  type GetTuristaGroupByPayload<T extends TuristaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TuristaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TuristaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TuristaGroupByOutputType[P]>
            : GetScalarType<T[P], TuristaGroupByOutputType[P]>
        }
      >
    >


  export type TuristaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    telefono?: boolean
    direccion?: boolean
    edad?: boolean
    sexo?: boolean
    pais?: boolean
    peticionesEspeciales?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reservas?: boolean | Turista$reservasArgs<ExtArgs>
    _count?: boolean | TuristaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["turista"]>

  export type TuristaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    telefono?: boolean
    direccion?: boolean
    edad?: boolean
    sexo?: boolean
    pais?: boolean
    peticionesEspeciales?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["turista"]>

  export type TuristaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    telefono?: boolean
    direccion?: boolean
    edad?: boolean
    sexo?: boolean
    pais?: boolean
    peticionesEspeciales?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["turista"]>

  export type TuristaSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellidos?: boolean
    telefono?: boolean
    direccion?: boolean
    edad?: boolean
    sexo?: boolean
    pais?: boolean
    peticionesEspeciales?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TuristaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "apellidos" | "telefono" | "direccion" | "edad" | "sexo" | "pais" | "peticionesEspeciales" | "email" | "createdAt" | "updatedAt", ExtArgs["result"]["turista"]>
  export type TuristaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservas?: boolean | Turista$reservasArgs<ExtArgs>
    _count?: boolean | TuristaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TuristaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TuristaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TuristaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Turista"
    objects: {
      reservas: Prisma.$ReservaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      apellidos: string
      telefono: string
      direccion: string
      edad: Prisma.Decimal
      sexo: string
      pais: string
      peticionesEspeciales: string | null
      email: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["turista"]>
    composites: {}
  }

  type TuristaGetPayload<S extends boolean | null | undefined | TuristaDefaultArgs> = $Result.GetResult<Prisma.$TuristaPayload, S>

  type TuristaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TuristaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TuristaCountAggregateInputType | true
    }

  export interface TuristaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Turista'], meta: { name: 'Turista' } }
    /**
     * Find zero or one Turista that matches the filter.
     * @param {TuristaFindUniqueArgs} args - Arguments to find a Turista
     * @example
     * // Get one Turista
     * const turista = await prisma.turista.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TuristaFindUniqueArgs>(args: SelectSubset<T, TuristaFindUniqueArgs<ExtArgs>>): Prisma__TuristaClient<$Result.GetResult<Prisma.$TuristaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Turista that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TuristaFindUniqueOrThrowArgs} args - Arguments to find a Turista
     * @example
     * // Get one Turista
     * const turista = await prisma.turista.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TuristaFindUniqueOrThrowArgs>(args: SelectSubset<T, TuristaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TuristaClient<$Result.GetResult<Prisma.$TuristaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Turista that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuristaFindFirstArgs} args - Arguments to find a Turista
     * @example
     * // Get one Turista
     * const turista = await prisma.turista.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TuristaFindFirstArgs>(args?: SelectSubset<T, TuristaFindFirstArgs<ExtArgs>>): Prisma__TuristaClient<$Result.GetResult<Prisma.$TuristaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Turista that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuristaFindFirstOrThrowArgs} args - Arguments to find a Turista
     * @example
     * // Get one Turista
     * const turista = await prisma.turista.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TuristaFindFirstOrThrowArgs>(args?: SelectSubset<T, TuristaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TuristaClient<$Result.GetResult<Prisma.$TuristaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Turistas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuristaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Turistas
     * const turistas = await prisma.turista.findMany()
     * 
     * // Get first 10 Turistas
     * const turistas = await prisma.turista.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const turistaWithIdOnly = await prisma.turista.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TuristaFindManyArgs>(args?: SelectSubset<T, TuristaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TuristaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Turista.
     * @param {TuristaCreateArgs} args - Arguments to create a Turista.
     * @example
     * // Create one Turista
     * const Turista = await prisma.turista.create({
     *   data: {
     *     // ... data to create a Turista
     *   }
     * })
     * 
     */
    create<T extends TuristaCreateArgs>(args: SelectSubset<T, TuristaCreateArgs<ExtArgs>>): Prisma__TuristaClient<$Result.GetResult<Prisma.$TuristaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Turistas.
     * @param {TuristaCreateManyArgs} args - Arguments to create many Turistas.
     * @example
     * // Create many Turistas
     * const turista = await prisma.turista.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TuristaCreateManyArgs>(args?: SelectSubset<T, TuristaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Turistas and returns the data saved in the database.
     * @param {TuristaCreateManyAndReturnArgs} args - Arguments to create many Turistas.
     * @example
     * // Create many Turistas
     * const turista = await prisma.turista.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Turistas and only return the `id`
     * const turistaWithIdOnly = await prisma.turista.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TuristaCreateManyAndReturnArgs>(args?: SelectSubset<T, TuristaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TuristaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Turista.
     * @param {TuristaDeleteArgs} args - Arguments to delete one Turista.
     * @example
     * // Delete one Turista
     * const Turista = await prisma.turista.delete({
     *   where: {
     *     // ... filter to delete one Turista
     *   }
     * })
     * 
     */
    delete<T extends TuristaDeleteArgs>(args: SelectSubset<T, TuristaDeleteArgs<ExtArgs>>): Prisma__TuristaClient<$Result.GetResult<Prisma.$TuristaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Turista.
     * @param {TuristaUpdateArgs} args - Arguments to update one Turista.
     * @example
     * // Update one Turista
     * const turista = await prisma.turista.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TuristaUpdateArgs>(args: SelectSubset<T, TuristaUpdateArgs<ExtArgs>>): Prisma__TuristaClient<$Result.GetResult<Prisma.$TuristaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Turistas.
     * @param {TuristaDeleteManyArgs} args - Arguments to filter Turistas to delete.
     * @example
     * // Delete a few Turistas
     * const { count } = await prisma.turista.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TuristaDeleteManyArgs>(args?: SelectSubset<T, TuristaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Turistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuristaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Turistas
     * const turista = await prisma.turista.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TuristaUpdateManyArgs>(args: SelectSubset<T, TuristaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Turistas and returns the data updated in the database.
     * @param {TuristaUpdateManyAndReturnArgs} args - Arguments to update many Turistas.
     * @example
     * // Update many Turistas
     * const turista = await prisma.turista.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Turistas and only return the `id`
     * const turistaWithIdOnly = await prisma.turista.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TuristaUpdateManyAndReturnArgs>(args: SelectSubset<T, TuristaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TuristaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Turista.
     * @param {TuristaUpsertArgs} args - Arguments to update or create a Turista.
     * @example
     * // Update or create a Turista
     * const turista = await prisma.turista.upsert({
     *   create: {
     *     // ... data to create a Turista
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Turista we want to update
     *   }
     * })
     */
    upsert<T extends TuristaUpsertArgs>(args: SelectSubset<T, TuristaUpsertArgs<ExtArgs>>): Prisma__TuristaClient<$Result.GetResult<Prisma.$TuristaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Turistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuristaCountArgs} args - Arguments to filter Turistas to count.
     * @example
     * // Count the number of Turistas
     * const count = await prisma.turista.count({
     *   where: {
     *     // ... the filter for the Turistas we want to count
     *   }
     * })
    **/
    count<T extends TuristaCountArgs>(
      args?: Subset<T, TuristaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TuristaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Turista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuristaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TuristaAggregateArgs>(args: Subset<T, TuristaAggregateArgs>): Prisma.PrismaPromise<GetTuristaAggregateType<T>>

    /**
     * Group by Turista.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TuristaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TuristaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TuristaGroupByArgs['orderBy'] }
        : { orderBy?: TuristaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TuristaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTuristaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Turista model
   */
  readonly fields: TuristaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Turista.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TuristaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservas<T extends Turista$reservasArgs<ExtArgs> = {}>(args?: Subset<T, Turista$reservasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Turista model
   */
  interface TuristaFieldRefs {
    readonly id: FieldRef<"Turista", 'Int'>
    readonly nombre: FieldRef<"Turista", 'String'>
    readonly apellidos: FieldRef<"Turista", 'String'>
    readonly telefono: FieldRef<"Turista", 'String'>
    readonly direccion: FieldRef<"Turista", 'String'>
    readonly edad: FieldRef<"Turista", 'Decimal'>
    readonly sexo: FieldRef<"Turista", 'String'>
    readonly pais: FieldRef<"Turista", 'String'>
    readonly peticionesEspeciales: FieldRef<"Turista", 'String'>
    readonly email: FieldRef<"Turista", 'String'>
    readonly createdAt: FieldRef<"Turista", 'DateTime'>
    readonly updatedAt: FieldRef<"Turista", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Turista findUnique
   */
  export type TuristaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turista
     */
    select?: TuristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Turista
     */
    omit?: TuristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuristaInclude<ExtArgs> | null
    /**
     * Filter, which Turista to fetch.
     */
    where: TuristaWhereUniqueInput
  }

  /**
   * Turista findUniqueOrThrow
   */
  export type TuristaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turista
     */
    select?: TuristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Turista
     */
    omit?: TuristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuristaInclude<ExtArgs> | null
    /**
     * Filter, which Turista to fetch.
     */
    where: TuristaWhereUniqueInput
  }

  /**
   * Turista findFirst
   */
  export type TuristaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turista
     */
    select?: TuristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Turista
     */
    omit?: TuristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuristaInclude<ExtArgs> | null
    /**
     * Filter, which Turista to fetch.
     */
    where?: TuristaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Turistas to fetch.
     */
    orderBy?: TuristaOrderByWithRelationInput | TuristaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Turistas.
     */
    cursor?: TuristaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Turistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Turistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Turistas.
     */
    distinct?: TuristaScalarFieldEnum | TuristaScalarFieldEnum[]
  }

  /**
   * Turista findFirstOrThrow
   */
  export type TuristaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turista
     */
    select?: TuristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Turista
     */
    omit?: TuristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuristaInclude<ExtArgs> | null
    /**
     * Filter, which Turista to fetch.
     */
    where?: TuristaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Turistas to fetch.
     */
    orderBy?: TuristaOrderByWithRelationInput | TuristaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Turistas.
     */
    cursor?: TuristaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Turistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Turistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Turistas.
     */
    distinct?: TuristaScalarFieldEnum | TuristaScalarFieldEnum[]
  }

  /**
   * Turista findMany
   */
  export type TuristaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turista
     */
    select?: TuristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Turista
     */
    omit?: TuristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuristaInclude<ExtArgs> | null
    /**
     * Filter, which Turistas to fetch.
     */
    where?: TuristaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Turistas to fetch.
     */
    orderBy?: TuristaOrderByWithRelationInput | TuristaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Turistas.
     */
    cursor?: TuristaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Turistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Turistas.
     */
    skip?: number
    distinct?: TuristaScalarFieldEnum | TuristaScalarFieldEnum[]
  }

  /**
   * Turista create
   */
  export type TuristaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turista
     */
    select?: TuristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Turista
     */
    omit?: TuristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuristaInclude<ExtArgs> | null
    /**
     * The data needed to create a Turista.
     */
    data: XOR<TuristaCreateInput, TuristaUncheckedCreateInput>
  }

  /**
   * Turista createMany
   */
  export type TuristaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Turistas.
     */
    data: TuristaCreateManyInput | TuristaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Turista createManyAndReturn
   */
  export type TuristaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turista
     */
    select?: TuristaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Turista
     */
    omit?: TuristaOmit<ExtArgs> | null
    /**
     * The data used to create many Turistas.
     */
    data: TuristaCreateManyInput | TuristaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Turista update
   */
  export type TuristaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turista
     */
    select?: TuristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Turista
     */
    omit?: TuristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuristaInclude<ExtArgs> | null
    /**
     * The data needed to update a Turista.
     */
    data: XOR<TuristaUpdateInput, TuristaUncheckedUpdateInput>
    /**
     * Choose, which Turista to update.
     */
    where: TuristaWhereUniqueInput
  }

  /**
   * Turista updateMany
   */
  export type TuristaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Turistas.
     */
    data: XOR<TuristaUpdateManyMutationInput, TuristaUncheckedUpdateManyInput>
    /**
     * Filter which Turistas to update
     */
    where?: TuristaWhereInput
    /**
     * Limit how many Turistas to update.
     */
    limit?: number
  }

  /**
   * Turista updateManyAndReturn
   */
  export type TuristaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turista
     */
    select?: TuristaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Turista
     */
    omit?: TuristaOmit<ExtArgs> | null
    /**
     * The data used to update Turistas.
     */
    data: XOR<TuristaUpdateManyMutationInput, TuristaUncheckedUpdateManyInput>
    /**
     * Filter which Turistas to update
     */
    where?: TuristaWhereInput
    /**
     * Limit how many Turistas to update.
     */
    limit?: number
  }

  /**
   * Turista upsert
   */
  export type TuristaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turista
     */
    select?: TuristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Turista
     */
    omit?: TuristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuristaInclude<ExtArgs> | null
    /**
     * The filter to search for the Turista to update in case it exists.
     */
    where: TuristaWhereUniqueInput
    /**
     * In case the Turista found by the `where` argument doesn't exist, create a new Turista with this data.
     */
    create: XOR<TuristaCreateInput, TuristaUncheckedCreateInput>
    /**
     * In case the Turista was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TuristaUpdateInput, TuristaUncheckedUpdateInput>
  }

  /**
   * Turista delete
   */
  export type TuristaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turista
     */
    select?: TuristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Turista
     */
    omit?: TuristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuristaInclude<ExtArgs> | null
    /**
     * Filter which Turista to delete.
     */
    where: TuristaWhereUniqueInput
  }

  /**
   * Turista deleteMany
   */
  export type TuristaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Turistas to delete
     */
    where?: TuristaWhereInput
    /**
     * Limit how many Turistas to delete.
     */
    limit?: number
  }

  /**
   * Turista.reservas
   */
  export type Turista$reservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reserva
     */
    omit?: ReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    where?: ReservaWhereInput
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    cursor?: ReservaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * Turista without action
   */
  export type TuristaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Turista
     */
    select?: TuristaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Turista
     */
    omit?: TuristaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TuristaInclude<ExtArgs> | null
  }


  /**
   * Model LugarTuristico
   */

  export type AggregateLugarTuristico = {
    _count: LugarTuristicoCountAggregateOutputType | null
    _avg: LugarTuristicoAvgAggregateOutputType | null
    _sum: LugarTuristicoSumAggregateOutputType | null
    _min: LugarTuristicoMinAggregateOutputType | null
    _max: LugarTuristicoMaxAggregateOutputType | null
  }

  export type LugarTuristicoAvgAggregateOutputType = {
    id: number | null
    costoEntrada: Decimal | null
  }

  export type LugarTuristicoSumAggregateOutputType = {
    id: number | null
    costoEntrada: Decimal | null
  }

  export type LugarTuristicoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    direccion: string | null
    coordenadas: string | null
    horarioApertura: Date | null
    horarioCierre: Date | null
    costoEntrada: Decimal | null
    recomendaciones: string | null
    restricciones: string | null
    esDestacado: boolean | null
    estado: string | null
    imagenUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LugarTuristicoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    direccion: string | null
    coordenadas: string | null
    horarioApertura: Date | null
    horarioCierre: Date | null
    costoEntrada: Decimal | null
    recomendaciones: string | null
    restricciones: string | null
    esDestacado: boolean | null
    estado: string | null
    imagenUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LugarTuristicoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    direccion: number
    coordenadas: number
    horarioApertura: number
    horarioCierre: number
    costoEntrada: number
    recomendaciones: number
    restricciones: number
    esDestacado: number
    estado: number
    imagenUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LugarTuristicoAvgAggregateInputType = {
    id?: true
    costoEntrada?: true
  }

  export type LugarTuristicoSumAggregateInputType = {
    id?: true
    costoEntrada?: true
  }

  export type LugarTuristicoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    direccion?: true
    coordenadas?: true
    horarioApertura?: true
    horarioCierre?: true
    costoEntrada?: true
    recomendaciones?: true
    restricciones?: true
    esDestacado?: true
    estado?: true
    imagenUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LugarTuristicoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    direccion?: true
    coordenadas?: true
    horarioApertura?: true
    horarioCierre?: true
    costoEntrada?: true
    recomendaciones?: true
    restricciones?: true
    esDestacado?: true
    estado?: true
    imagenUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LugarTuristicoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    direccion?: true
    coordenadas?: true
    horarioApertura?: true
    horarioCierre?: true
    costoEntrada?: true
    recomendaciones?: true
    restricciones?: true
    esDestacado?: true
    estado?: true
    imagenUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LugarTuristicoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LugarTuristico to aggregate.
     */
    where?: LugarTuristicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LugarTuristicos to fetch.
     */
    orderBy?: LugarTuristicoOrderByWithRelationInput | LugarTuristicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LugarTuristicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LugarTuristicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LugarTuristicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LugarTuristicos
    **/
    _count?: true | LugarTuristicoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LugarTuristicoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LugarTuristicoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LugarTuristicoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LugarTuristicoMaxAggregateInputType
  }

  export type GetLugarTuristicoAggregateType<T extends LugarTuristicoAggregateArgs> = {
        [P in keyof T & keyof AggregateLugarTuristico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLugarTuristico[P]>
      : GetScalarType<T[P], AggregateLugarTuristico[P]>
  }




  export type LugarTuristicoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LugarTuristicoWhereInput
    orderBy?: LugarTuristicoOrderByWithAggregationInput | LugarTuristicoOrderByWithAggregationInput[]
    by: LugarTuristicoScalarFieldEnum[] | LugarTuristicoScalarFieldEnum
    having?: LugarTuristicoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LugarTuristicoCountAggregateInputType | true
    _avg?: LugarTuristicoAvgAggregateInputType
    _sum?: LugarTuristicoSumAggregateInputType
    _min?: LugarTuristicoMinAggregateInputType
    _max?: LugarTuristicoMaxAggregateInputType
  }

  export type LugarTuristicoGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string
    direccion: string
    coordenadas: string
    horarioApertura: Date | null
    horarioCierre: Date | null
    costoEntrada: Decimal | null
    recomendaciones: string | null
    restricciones: string | null
    esDestacado: boolean
    estado: string
    imagenUrl: string
    createdAt: Date
    updatedAt: Date
    _count: LugarTuristicoCountAggregateOutputType | null
    _avg: LugarTuristicoAvgAggregateOutputType | null
    _sum: LugarTuristicoSumAggregateOutputType | null
    _min: LugarTuristicoMinAggregateOutputType | null
    _max: LugarTuristicoMaxAggregateOutputType | null
  }

  type GetLugarTuristicoGroupByPayload<T extends LugarTuristicoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LugarTuristicoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LugarTuristicoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LugarTuristicoGroupByOutputType[P]>
            : GetScalarType<T[P], LugarTuristicoGroupByOutputType[P]>
        }
      >
    >


  export type LugarTuristicoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    direccion?: boolean
    coordenadas?: boolean
    horarioApertura?: boolean
    horarioCierre?: boolean
    costoEntrada?: boolean
    recomendaciones?: boolean
    restricciones?: boolean
    esDestacado?: boolean
    estado?: boolean
    imagenUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itinerarioLugares?: boolean | LugarTuristico$itinerarioLugaresArgs<ExtArgs>
    _count?: boolean | LugarTuristicoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lugarTuristico"]>

  export type LugarTuristicoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    direccion?: boolean
    coordenadas?: boolean
    horarioApertura?: boolean
    horarioCierre?: boolean
    costoEntrada?: boolean
    recomendaciones?: boolean
    restricciones?: boolean
    esDestacado?: boolean
    estado?: boolean
    imagenUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lugarTuristico"]>

  export type LugarTuristicoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    direccion?: boolean
    coordenadas?: boolean
    horarioApertura?: boolean
    horarioCierre?: boolean
    costoEntrada?: boolean
    recomendaciones?: boolean
    restricciones?: boolean
    esDestacado?: boolean
    estado?: boolean
    imagenUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["lugarTuristico"]>

  export type LugarTuristicoSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    direccion?: boolean
    coordenadas?: boolean
    horarioApertura?: boolean
    horarioCierre?: boolean
    costoEntrada?: boolean
    recomendaciones?: boolean
    restricciones?: boolean
    esDestacado?: boolean
    estado?: boolean
    imagenUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LugarTuristicoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "direccion" | "coordenadas" | "horarioApertura" | "horarioCierre" | "costoEntrada" | "recomendaciones" | "restricciones" | "esDestacado" | "estado" | "imagenUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["lugarTuristico"]>
  export type LugarTuristicoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerarioLugares?: boolean | LugarTuristico$itinerarioLugaresArgs<ExtArgs>
    _count?: boolean | LugarTuristicoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LugarTuristicoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LugarTuristicoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LugarTuristicoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LugarTuristico"
    objects: {
      itinerarioLugares: Prisma.$ItinerarioLugarPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string
      direccion: string
      coordenadas: string
      horarioApertura: Date | null
      horarioCierre: Date | null
      costoEntrada: Prisma.Decimal | null
      recomendaciones: string | null
      restricciones: string | null
      esDestacado: boolean
      estado: string
      imagenUrl: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lugarTuristico"]>
    composites: {}
  }

  type LugarTuristicoGetPayload<S extends boolean | null | undefined | LugarTuristicoDefaultArgs> = $Result.GetResult<Prisma.$LugarTuristicoPayload, S>

  type LugarTuristicoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LugarTuristicoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LugarTuristicoCountAggregateInputType | true
    }

  export interface LugarTuristicoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LugarTuristico'], meta: { name: 'LugarTuristico' } }
    /**
     * Find zero or one LugarTuristico that matches the filter.
     * @param {LugarTuristicoFindUniqueArgs} args - Arguments to find a LugarTuristico
     * @example
     * // Get one LugarTuristico
     * const lugarTuristico = await prisma.lugarTuristico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LugarTuristicoFindUniqueArgs>(args: SelectSubset<T, LugarTuristicoFindUniqueArgs<ExtArgs>>): Prisma__LugarTuristicoClient<$Result.GetResult<Prisma.$LugarTuristicoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LugarTuristico that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LugarTuristicoFindUniqueOrThrowArgs} args - Arguments to find a LugarTuristico
     * @example
     * // Get one LugarTuristico
     * const lugarTuristico = await prisma.lugarTuristico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LugarTuristicoFindUniqueOrThrowArgs>(args: SelectSubset<T, LugarTuristicoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LugarTuristicoClient<$Result.GetResult<Prisma.$LugarTuristicoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LugarTuristico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LugarTuristicoFindFirstArgs} args - Arguments to find a LugarTuristico
     * @example
     * // Get one LugarTuristico
     * const lugarTuristico = await prisma.lugarTuristico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LugarTuristicoFindFirstArgs>(args?: SelectSubset<T, LugarTuristicoFindFirstArgs<ExtArgs>>): Prisma__LugarTuristicoClient<$Result.GetResult<Prisma.$LugarTuristicoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LugarTuristico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LugarTuristicoFindFirstOrThrowArgs} args - Arguments to find a LugarTuristico
     * @example
     * // Get one LugarTuristico
     * const lugarTuristico = await prisma.lugarTuristico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LugarTuristicoFindFirstOrThrowArgs>(args?: SelectSubset<T, LugarTuristicoFindFirstOrThrowArgs<ExtArgs>>): Prisma__LugarTuristicoClient<$Result.GetResult<Prisma.$LugarTuristicoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LugarTuristicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LugarTuristicoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LugarTuristicos
     * const lugarTuristicos = await prisma.lugarTuristico.findMany()
     * 
     * // Get first 10 LugarTuristicos
     * const lugarTuristicos = await prisma.lugarTuristico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lugarTuristicoWithIdOnly = await prisma.lugarTuristico.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LugarTuristicoFindManyArgs>(args?: SelectSubset<T, LugarTuristicoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LugarTuristicoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LugarTuristico.
     * @param {LugarTuristicoCreateArgs} args - Arguments to create a LugarTuristico.
     * @example
     * // Create one LugarTuristico
     * const LugarTuristico = await prisma.lugarTuristico.create({
     *   data: {
     *     // ... data to create a LugarTuristico
     *   }
     * })
     * 
     */
    create<T extends LugarTuristicoCreateArgs>(args: SelectSubset<T, LugarTuristicoCreateArgs<ExtArgs>>): Prisma__LugarTuristicoClient<$Result.GetResult<Prisma.$LugarTuristicoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LugarTuristicos.
     * @param {LugarTuristicoCreateManyArgs} args - Arguments to create many LugarTuristicos.
     * @example
     * // Create many LugarTuristicos
     * const lugarTuristico = await prisma.lugarTuristico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LugarTuristicoCreateManyArgs>(args?: SelectSubset<T, LugarTuristicoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LugarTuristicos and returns the data saved in the database.
     * @param {LugarTuristicoCreateManyAndReturnArgs} args - Arguments to create many LugarTuristicos.
     * @example
     * // Create many LugarTuristicos
     * const lugarTuristico = await prisma.lugarTuristico.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LugarTuristicos and only return the `id`
     * const lugarTuristicoWithIdOnly = await prisma.lugarTuristico.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LugarTuristicoCreateManyAndReturnArgs>(args?: SelectSubset<T, LugarTuristicoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LugarTuristicoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LugarTuristico.
     * @param {LugarTuristicoDeleteArgs} args - Arguments to delete one LugarTuristico.
     * @example
     * // Delete one LugarTuristico
     * const LugarTuristico = await prisma.lugarTuristico.delete({
     *   where: {
     *     // ... filter to delete one LugarTuristico
     *   }
     * })
     * 
     */
    delete<T extends LugarTuristicoDeleteArgs>(args: SelectSubset<T, LugarTuristicoDeleteArgs<ExtArgs>>): Prisma__LugarTuristicoClient<$Result.GetResult<Prisma.$LugarTuristicoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LugarTuristico.
     * @param {LugarTuristicoUpdateArgs} args - Arguments to update one LugarTuristico.
     * @example
     * // Update one LugarTuristico
     * const lugarTuristico = await prisma.lugarTuristico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LugarTuristicoUpdateArgs>(args: SelectSubset<T, LugarTuristicoUpdateArgs<ExtArgs>>): Prisma__LugarTuristicoClient<$Result.GetResult<Prisma.$LugarTuristicoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LugarTuristicos.
     * @param {LugarTuristicoDeleteManyArgs} args - Arguments to filter LugarTuristicos to delete.
     * @example
     * // Delete a few LugarTuristicos
     * const { count } = await prisma.lugarTuristico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LugarTuristicoDeleteManyArgs>(args?: SelectSubset<T, LugarTuristicoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LugarTuristicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LugarTuristicoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LugarTuristicos
     * const lugarTuristico = await prisma.lugarTuristico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LugarTuristicoUpdateManyArgs>(args: SelectSubset<T, LugarTuristicoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LugarTuristicos and returns the data updated in the database.
     * @param {LugarTuristicoUpdateManyAndReturnArgs} args - Arguments to update many LugarTuristicos.
     * @example
     * // Update many LugarTuristicos
     * const lugarTuristico = await prisma.lugarTuristico.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LugarTuristicos and only return the `id`
     * const lugarTuristicoWithIdOnly = await prisma.lugarTuristico.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LugarTuristicoUpdateManyAndReturnArgs>(args: SelectSubset<T, LugarTuristicoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LugarTuristicoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LugarTuristico.
     * @param {LugarTuristicoUpsertArgs} args - Arguments to update or create a LugarTuristico.
     * @example
     * // Update or create a LugarTuristico
     * const lugarTuristico = await prisma.lugarTuristico.upsert({
     *   create: {
     *     // ... data to create a LugarTuristico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LugarTuristico we want to update
     *   }
     * })
     */
    upsert<T extends LugarTuristicoUpsertArgs>(args: SelectSubset<T, LugarTuristicoUpsertArgs<ExtArgs>>): Prisma__LugarTuristicoClient<$Result.GetResult<Prisma.$LugarTuristicoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LugarTuristicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LugarTuristicoCountArgs} args - Arguments to filter LugarTuristicos to count.
     * @example
     * // Count the number of LugarTuristicos
     * const count = await prisma.lugarTuristico.count({
     *   where: {
     *     // ... the filter for the LugarTuristicos we want to count
     *   }
     * })
    **/
    count<T extends LugarTuristicoCountArgs>(
      args?: Subset<T, LugarTuristicoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LugarTuristicoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LugarTuristico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LugarTuristicoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LugarTuristicoAggregateArgs>(args: Subset<T, LugarTuristicoAggregateArgs>): Prisma.PrismaPromise<GetLugarTuristicoAggregateType<T>>

    /**
     * Group by LugarTuristico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LugarTuristicoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LugarTuristicoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LugarTuristicoGroupByArgs['orderBy'] }
        : { orderBy?: LugarTuristicoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LugarTuristicoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLugarTuristicoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LugarTuristico model
   */
  readonly fields: LugarTuristicoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LugarTuristico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LugarTuristicoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itinerarioLugares<T extends LugarTuristico$itinerarioLugaresArgs<ExtArgs> = {}>(args?: Subset<T, LugarTuristico$itinerarioLugaresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItinerarioLugarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LugarTuristico model
   */
  interface LugarTuristicoFieldRefs {
    readonly id: FieldRef<"LugarTuristico", 'Int'>
    readonly nombre: FieldRef<"LugarTuristico", 'String'>
    readonly descripcion: FieldRef<"LugarTuristico", 'String'>
    readonly direccion: FieldRef<"LugarTuristico", 'String'>
    readonly coordenadas: FieldRef<"LugarTuristico", 'String'>
    readonly horarioApertura: FieldRef<"LugarTuristico", 'DateTime'>
    readonly horarioCierre: FieldRef<"LugarTuristico", 'DateTime'>
    readonly costoEntrada: FieldRef<"LugarTuristico", 'Decimal'>
    readonly recomendaciones: FieldRef<"LugarTuristico", 'String'>
    readonly restricciones: FieldRef<"LugarTuristico", 'String'>
    readonly esDestacado: FieldRef<"LugarTuristico", 'Boolean'>
    readonly estado: FieldRef<"LugarTuristico", 'String'>
    readonly imagenUrl: FieldRef<"LugarTuristico", 'String'>
    readonly createdAt: FieldRef<"LugarTuristico", 'DateTime'>
    readonly updatedAt: FieldRef<"LugarTuristico", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LugarTuristico findUnique
   */
  export type LugarTuristicoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LugarTuristico
     */
    select?: LugarTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LugarTuristico
     */
    omit?: LugarTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LugarTuristicoInclude<ExtArgs> | null
    /**
     * Filter, which LugarTuristico to fetch.
     */
    where: LugarTuristicoWhereUniqueInput
  }

  /**
   * LugarTuristico findUniqueOrThrow
   */
  export type LugarTuristicoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LugarTuristico
     */
    select?: LugarTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LugarTuristico
     */
    omit?: LugarTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LugarTuristicoInclude<ExtArgs> | null
    /**
     * Filter, which LugarTuristico to fetch.
     */
    where: LugarTuristicoWhereUniqueInput
  }

  /**
   * LugarTuristico findFirst
   */
  export type LugarTuristicoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LugarTuristico
     */
    select?: LugarTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LugarTuristico
     */
    omit?: LugarTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LugarTuristicoInclude<ExtArgs> | null
    /**
     * Filter, which LugarTuristico to fetch.
     */
    where?: LugarTuristicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LugarTuristicos to fetch.
     */
    orderBy?: LugarTuristicoOrderByWithRelationInput | LugarTuristicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LugarTuristicos.
     */
    cursor?: LugarTuristicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LugarTuristicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LugarTuristicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LugarTuristicos.
     */
    distinct?: LugarTuristicoScalarFieldEnum | LugarTuristicoScalarFieldEnum[]
  }

  /**
   * LugarTuristico findFirstOrThrow
   */
  export type LugarTuristicoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LugarTuristico
     */
    select?: LugarTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LugarTuristico
     */
    omit?: LugarTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LugarTuristicoInclude<ExtArgs> | null
    /**
     * Filter, which LugarTuristico to fetch.
     */
    where?: LugarTuristicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LugarTuristicos to fetch.
     */
    orderBy?: LugarTuristicoOrderByWithRelationInput | LugarTuristicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LugarTuristicos.
     */
    cursor?: LugarTuristicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LugarTuristicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LugarTuristicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LugarTuristicos.
     */
    distinct?: LugarTuristicoScalarFieldEnum | LugarTuristicoScalarFieldEnum[]
  }

  /**
   * LugarTuristico findMany
   */
  export type LugarTuristicoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LugarTuristico
     */
    select?: LugarTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LugarTuristico
     */
    omit?: LugarTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LugarTuristicoInclude<ExtArgs> | null
    /**
     * Filter, which LugarTuristicos to fetch.
     */
    where?: LugarTuristicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LugarTuristicos to fetch.
     */
    orderBy?: LugarTuristicoOrderByWithRelationInput | LugarTuristicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LugarTuristicos.
     */
    cursor?: LugarTuristicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LugarTuristicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LugarTuristicos.
     */
    skip?: number
    distinct?: LugarTuristicoScalarFieldEnum | LugarTuristicoScalarFieldEnum[]
  }

  /**
   * LugarTuristico create
   */
  export type LugarTuristicoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LugarTuristico
     */
    select?: LugarTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LugarTuristico
     */
    omit?: LugarTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LugarTuristicoInclude<ExtArgs> | null
    /**
     * The data needed to create a LugarTuristico.
     */
    data: XOR<LugarTuristicoCreateInput, LugarTuristicoUncheckedCreateInput>
  }

  /**
   * LugarTuristico createMany
   */
  export type LugarTuristicoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LugarTuristicos.
     */
    data: LugarTuristicoCreateManyInput | LugarTuristicoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LugarTuristico createManyAndReturn
   */
  export type LugarTuristicoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LugarTuristico
     */
    select?: LugarTuristicoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LugarTuristico
     */
    omit?: LugarTuristicoOmit<ExtArgs> | null
    /**
     * The data used to create many LugarTuristicos.
     */
    data: LugarTuristicoCreateManyInput | LugarTuristicoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LugarTuristico update
   */
  export type LugarTuristicoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LugarTuristico
     */
    select?: LugarTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LugarTuristico
     */
    omit?: LugarTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LugarTuristicoInclude<ExtArgs> | null
    /**
     * The data needed to update a LugarTuristico.
     */
    data: XOR<LugarTuristicoUpdateInput, LugarTuristicoUncheckedUpdateInput>
    /**
     * Choose, which LugarTuristico to update.
     */
    where: LugarTuristicoWhereUniqueInput
  }

  /**
   * LugarTuristico updateMany
   */
  export type LugarTuristicoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LugarTuristicos.
     */
    data: XOR<LugarTuristicoUpdateManyMutationInput, LugarTuristicoUncheckedUpdateManyInput>
    /**
     * Filter which LugarTuristicos to update
     */
    where?: LugarTuristicoWhereInput
    /**
     * Limit how many LugarTuristicos to update.
     */
    limit?: number
  }

  /**
   * LugarTuristico updateManyAndReturn
   */
  export type LugarTuristicoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LugarTuristico
     */
    select?: LugarTuristicoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LugarTuristico
     */
    omit?: LugarTuristicoOmit<ExtArgs> | null
    /**
     * The data used to update LugarTuristicos.
     */
    data: XOR<LugarTuristicoUpdateManyMutationInput, LugarTuristicoUncheckedUpdateManyInput>
    /**
     * Filter which LugarTuristicos to update
     */
    where?: LugarTuristicoWhereInput
    /**
     * Limit how many LugarTuristicos to update.
     */
    limit?: number
  }

  /**
   * LugarTuristico upsert
   */
  export type LugarTuristicoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LugarTuristico
     */
    select?: LugarTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LugarTuristico
     */
    omit?: LugarTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LugarTuristicoInclude<ExtArgs> | null
    /**
     * The filter to search for the LugarTuristico to update in case it exists.
     */
    where: LugarTuristicoWhereUniqueInput
    /**
     * In case the LugarTuristico found by the `where` argument doesn't exist, create a new LugarTuristico with this data.
     */
    create: XOR<LugarTuristicoCreateInput, LugarTuristicoUncheckedCreateInput>
    /**
     * In case the LugarTuristico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LugarTuristicoUpdateInput, LugarTuristicoUncheckedUpdateInput>
  }

  /**
   * LugarTuristico delete
   */
  export type LugarTuristicoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LugarTuristico
     */
    select?: LugarTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LugarTuristico
     */
    omit?: LugarTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LugarTuristicoInclude<ExtArgs> | null
    /**
     * Filter which LugarTuristico to delete.
     */
    where: LugarTuristicoWhereUniqueInput
  }

  /**
   * LugarTuristico deleteMany
   */
  export type LugarTuristicoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LugarTuristicos to delete
     */
    where?: LugarTuristicoWhereInput
    /**
     * Limit how many LugarTuristicos to delete.
     */
    limit?: number
  }

  /**
   * LugarTuristico.itinerarioLugares
   */
  export type LugarTuristico$itinerarioLugaresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarInclude<ExtArgs> | null
    where?: ItinerarioLugarWhereInput
    orderBy?: ItinerarioLugarOrderByWithRelationInput | ItinerarioLugarOrderByWithRelationInput[]
    cursor?: ItinerarioLugarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItinerarioLugarScalarFieldEnum | ItinerarioLugarScalarFieldEnum[]
  }

  /**
   * LugarTuristico without action
   */
  export type LugarTuristicoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LugarTuristico
     */
    select?: LugarTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LugarTuristico
     */
    omit?: LugarTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LugarTuristicoInclude<ExtArgs> | null
  }


  /**
   * Model ServicioEmprendedor
   */

  export type AggregateServicioEmprendedor = {
    _count: ServicioEmprendedorCountAggregateOutputType | null
    _avg: ServicioEmprendedorAvgAggregateOutputType | null
    _sum: ServicioEmprendedorSumAggregateOutputType | null
    _min: ServicioEmprendedorMinAggregateOutputType | null
    _max: ServicioEmprendedorMaxAggregateOutputType | null
  }

  export type ServicioEmprendedorAvgAggregateOutputType = {
    id: number | null
    servicioId: number | null
    emprendimientoId: number | null
  }

  export type ServicioEmprendedorSumAggregateOutputType = {
    id: number | null
    servicioId: number | null
    emprendimientoId: number | null
  }

  export type ServicioEmprendedorMinAggregateOutputType = {
    id: number | null
    servicioId: number | null
    emprendimientoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicioEmprendedorMaxAggregateOutputType = {
    id: number | null
    servicioId: number | null
    emprendimientoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicioEmprendedorCountAggregateOutputType = {
    id: number
    servicioId: number
    emprendimientoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServicioEmprendedorAvgAggregateInputType = {
    id?: true
    servicioId?: true
    emprendimientoId?: true
  }

  export type ServicioEmprendedorSumAggregateInputType = {
    id?: true
    servicioId?: true
    emprendimientoId?: true
  }

  export type ServicioEmprendedorMinAggregateInputType = {
    id?: true
    servicioId?: true
    emprendimientoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicioEmprendedorMaxAggregateInputType = {
    id?: true
    servicioId?: true
    emprendimientoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicioEmprendedorCountAggregateInputType = {
    id?: true
    servicioId?: true
    emprendimientoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServicioEmprendedorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicioEmprendedor to aggregate.
     */
    where?: ServicioEmprendedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicioEmprendedors to fetch.
     */
    orderBy?: ServicioEmprendedorOrderByWithRelationInput | ServicioEmprendedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicioEmprendedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicioEmprendedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicioEmprendedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicioEmprendedors
    **/
    _count?: true | ServicioEmprendedorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicioEmprendedorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicioEmprendedorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicioEmprendedorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicioEmprendedorMaxAggregateInputType
  }

  export type GetServicioEmprendedorAggregateType<T extends ServicioEmprendedorAggregateArgs> = {
        [P in keyof T & keyof AggregateServicioEmprendedor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicioEmprendedor[P]>
      : GetScalarType<T[P], AggregateServicioEmprendedor[P]>
  }




  export type ServicioEmprendedorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioEmprendedorWhereInput
    orderBy?: ServicioEmprendedorOrderByWithAggregationInput | ServicioEmprendedorOrderByWithAggregationInput[]
    by: ServicioEmprendedorScalarFieldEnum[] | ServicioEmprendedorScalarFieldEnum
    having?: ServicioEmprendedorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicioEmprendedorCountAggregateInputType | true
    _avg?: ServicioEmprendedorAvgAggregateInputType
    _sum?: ServicioEmprendedorSumAggregateInputType
    _min?: ServicioEmprendedorMinAggregateInputType
    _max?: ServicioEmprendedorMaxAggregateInputType
  }

  export type ServicioEmprendedorGroupByOutputType = {
    id: number
    servicioId: number
    emprendimientoId: number
    createdAt: Date
    updatedAt: Date
    _count: ServicioEmprendedorCountAggregateOutputType | null
    _avg: ServicioEmprendedorAvgAggregateOutputType | null
    _sum: ServicioEmprendedorSumAggregateOutputType | null
    _min: ServicioEmprendedorMinAggregateOutputType | null
    _max: ServicioEmprendedorMaxAggregateOutputType | null
  }

  type GetServicioEmprendedorGroupByPayload<T extends ServicioEmprendedorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicioEmprendedorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicioEmprendedorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicioEmprendedorGroupByOutputType[P]>
            : GetScalarType<T[P], ServicioEmprendedorGroupByOutputType[P]>
        }
      >
    >


  export type ServicioEmprendedorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicioId?: boolean
    emprendimientoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicioEmprendedor"]>

  export type ServicioEmprendedorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicioId?: boolean
    emprendimientoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicioEmprendedor"]>

  export type ServicioEmprendedorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicioId?: boolean
    emprendimientoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicioEmprendedor"]>

  export type ServicioEmprendedorSelectScalar = {
    id?: boolean
    servicioId?: boolean
    emprendimientoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServicioEmprendedorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "servicioId" | "emprendimientoId" | "createdAt" | "updatedAt", ExtArgs["result"]["servicioEmprendedor"]>
  export type ServicioEmprendedorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }
  export type ServicioEmprendedorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }
  export type ServicioEmprendedorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }

  export type $ServicioEmprendedorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicioEmprendedor"
    objects: {
      emprendimiento: Prisma.$EmprendimientoPayload<ExtArgs>
      servicio: Prisma.$ServicioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      servicioId: number
      emprendimientoId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["servicioEmprendedor"]>
    composites: {}
  }

  type ServicioEmprendedorGetPayload<S extends boolean | null | undefined | ServicioEmprendedorDefaultArgs> = $Result.GetResult<Prisma.$ServicioEmprendedorPayload, S>

  type ServicioEmprendedorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicioEmprendedorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicioEmprendedorCountAggregateInputType | true
    }

  export interface ServicioEmprendedorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicioEmprendedor'], meta: { name: 'ServicioEmprendedor' } }
    /**
     * Find zero or one ServicioEmprendedor that matches the filter.
     * @param {ServicioEmprendedorFindUniqueArgs} args - Arguments to find a ServicioEmprendedor
     * @example
     * // Get one ServicioEmprendedor
     * const servicioEmprendedor = await prisma.servicioEmprendedor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicioEmprendedorFindUniqueArgs>(args: SelectSubset<T, ServicioEmprendedorFindUniqueArgs<ExtArgs>>): Prisma__ServicioEmprendedorClient<$Result.GetResult<Prisma.$ServicioEmprendedorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServicioEmprendedor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicioEmprendedorFindUniqueOrThrowArgs} args - Arguments to find a ServicioEmprendedor
     * @example
     * // Get one ServicioEmprendedor
     * const servicioEmprendedor = await prisma.servicioEmprendedor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicioEmprendedorFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicioEmprendedorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicioEmprendedorClient<$Result.GetResult<Prisma.$ServicioEmprendedorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicioEmprendedor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioEmprendedorFindFirstArgs} args - Arguments to find a ServicioEmprendedor
     * @example
     * // Get one ServicioEmprendedor
     * const servicioEmprendedor = await prisma.servicioEmprendedor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicioEmprendedorFindFirstArgs>(args?: SelectSubset<T, ServicioEmprendedorFindFirstArgs<ExtArgs>>): Prisma__ServicioEmprendedorClient<$Result.GetResult<Prisma.$ServicioEmprendedorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicioEmprendedor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioEmprendedorFindFirstOrThrowArgs} args - Arguments to find a ServicioEmprendedor
     * @example
     * // Get one ServicioEmprendedor
     * const servicioEmprendedor = await prisma.servicioEmprendedor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicioEmprendedorFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicioEmprendedorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicioEmprendedorClient<$Result.GetResult<Prisma.$ServicioEmprendedorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServicioEmprendedors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioEmprendedorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicioEmprendedors
     * const servicioEmprendedors = await prisma.servicioEmprendedor.findMany()
     * 
     * // Get first 10 ServicioEmprendedors
     * const servicioEmprendedors = await prisma.servicioEmprendedor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicioEmprendedorWithIdOnly = await prisma.servicioEmprendedor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicioEmprendedorFindManyArgs>(args?: SelectSubset<T, ServicioEmprendedorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioEmprendedorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServicioEmprendedor.
     * @param {ServicioEmprendedorCreateArgs} args - Arguments to create a ServicioEmprendedor.
     * @example
     * // Create one ServicioEmprendedor
     * const ServicioEmprendedor = await prisma.servicioEmprendedor.create({
     *   data: {
     *     // ... data to create a ServicioEmprendedor
     *   }
     * })
     * 
     */
    create<T extends ServicioEmprendedorCreateArgs>(args: SelectSubset<T, ServicioEmprendedorCreateArgs<ExtArgs>>): Prisma__ServicioEmprendedorClient<$Result.GetResult<Prisma.$ServicioEmprendedorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServicioEmprendedors.
     * @param {ServicioEmprendedorCreateManyArgs} args - Arguments to create many ServicioEmprendedors.
     * @example
     * // Create many ServicioEmprendedors
     * const servicioEmprendedor = await prisma.servicioEmprendedor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicioEmprendedorCreateManyArgs>(args?: SelectSubset<T, ServicioEmprendedorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServicioEmprendedors and returns the data saved in the database.
     * @param {ServicioEmprendedorCreateManyAndReturnArgs} args - Arguments to create many ServicioEmprendedors.
     * @example
     * // Create many ServicioEmprendedors
     * const servicioEmprendedor = await prisma.servicioEmprendedor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServicioEmprendedors and only return the `id`
     * const servicioEmprendedorWithIdOnly = await prisma.servicioEmprendedor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicioEmprendedorCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicioEmprendedorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioEmprendedorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServicioEmprendedor.
     * @param {ServicioEmprendedorDeleteArgs} args - Arguments to delete one ServicioEmprendedor.
     * @example
     * // Delete one ServicioEmprendedor
     * const ServicioEmprendedor = await prisma.servicioEmprendedor.delete({
     *   where: {
     *     // ... filter to delete one ServicioEmprendedor
     *   }
     * })
     * 
     */
    delete<T extends ServicioEmprendedorDeleteArgs>(args: SelectSubset<T, ServicioEmprendedorDeleteArgs<ExtArgs>>): Prisma__ServicioEmprendedorClient<$Result.GetResult<Prisma.$ServicioEmprendedorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServicioEmprendedor.
     * @param {ServicioEmprendedorUpdateArgs} args - Arguments to update one ServicioEmprendedor.
     * @example
     * // Update one ServicioEmprendedor
     * const servicioEmprendedor = await prisma.servicioEmprendedor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicioEmprendedorUpdateArgs>(args: SelectSubset<T, ServicioEmprendedorUpdateArgs<ExtArgs>>): Prisma__ServicioEmprendedorClient<$Result.GetResult<Prisma.$ServicioEmprendedorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServicioEmprendedors.
     * @param {ServicioEmprendedorDeleteManyArgs} args - Arguments to filter ServicioEmprendedors to delete.
     * @example
     * // Delete a few ServicioEmprendedors
     * const { count } = await prisma.servicioEmprendedor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicioEmprendedorDeleteManyArgs>(args?: SelectSubset<T, ServicioEmprendedorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicioEmprendedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioEmprendedorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicioEmprendedors
     * const servicioEmprendedor = await prisma.servicioEmprendedor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicioEmprendedorUpdateManyArgs>(args: SelectSubset<T, ServicioEmprendedorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicioEmprendedors and returns the data updated in the database.
     * @param {ServicioEmprendedorUpdateManyAndReturnArgs} args - Arguments to update many ServicioEmprendedors.
     * @example
     * // Update many ServicioEmprendedors
     * const servicioEmprendedor = await prisma.servicioEmprendedor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServicioEmprendedors and only return the `id`
     * const servicioEmprendedorWithIdOnly = await prisma.servicioEmprendedor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServicioEmprendedorUpdateManyAndReturnArgs>(args: SelectSubset<T, ServicioEmprendedorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioEmprendedorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServicioEmprendedor.
     * @param {ServicioEmprendedorUpsertArgs} args - Arguments to update or create a ServicioEmprendedor.
     * @example
     * // Update or create a ServicioEmprendedor
     * const servicioEmprendedor = await prisma.servicioEmprendedor.upsert({
     *   create: {
     *     // ... data to create a ServicioEmprendedor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicioEmprendedor we want to update
     *   }
     * })
     */
    upsert<T extends ServicioEmprendedorUpsertArgs>(args: SelectSubset<T, ServicioEmprendedorUpsertArgs<ExtArgs>>): Prisma__ServicioEmprendedorClient<$Result.GetResult<Prisma.$ServicioEmprendedorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServicioEmprendedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioEmprendedorCountArgs} args - Arguments to filter ServicioEmprendedors to count.
     * @example
     * // Count the number of ServicioEmprendedors
     * const count = await prisma.servicioEmprendedor.count({
     *   where: {
     *     // ... the filter for the ServicioEmprendedors we want to count
     *   }
     * })
    **/
    count<T extends ServicioEmprendedorCountArgs>(
      args?: Subset<T, ServicioEmprendedorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicioEmprendedorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicioEmprendedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioEmprendedorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicioEmprendedorAggregateArgs>(args: Subset<T, ServicioEmprendedorAggregateArgs>): Prisma.PrismaPromise<GetServicioEmprendedorAggregateType<T>>

    /**
     * Group by ServicioEmprendedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioEmprendedorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicioEmprendedorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicioEmprendedorGroupByArgs['orderBy'] }
        : { orderBy?: ServicioEmprendedorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicioEmprendedorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicioEmprendedorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicioEmprendedor model
   */
  readonly fields: ServicioEmprendedorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicioEmprendedor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicioEmprendedorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emprendimiento<T extends EmprendimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmprendimientoDefaultArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    servicio<T extends ServicioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServicioDefaultArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicioEmprendedor model
   */
  interface ServicioEmprendedorFieldRefs {
    readonly id: FieldRef<"ServicioEmprendedor", 'Int'>
    readonly servicioId: FieldRef<"ServicioEmprendedor", 'Int'>
    readonly emprendimientoId: FieldRef<"ServicioEmprendedor", 'Int'>
    readonly createdAt: FieldRef<"ServicioEmprendedor", 'DateTime'>
    readonly updatedAt: FieldRef<"ServicioEmprendedor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServicioEmprendedor findUnique
   */
  export type ServicioEmprendedorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorInclude<ExtArgs> | null
    /**
     * Filter, which ServicioEmprendedor to fetch.
     */
    where: ServicioEmprendedorWhereUniqueInput
  }

  /**
   * ServicioEmprendedor findUniqueOrThrow
   */
  export type ServicioEmprendedorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorInclude<ExtArgs> | null
    /**
     * Filter, which ServicioEmprendedor to fetch.
     */
    where: ServicioEmprendedorWhereUniqueInput
  }

  /**
   * ServicioEmprendedor findFirst
   */
  export type ServicioEmprendedorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorInclude<ExtArgs> | null
    /**
     * Filter, which ServicioEmprendedor to fetch.
     */
    where?: ServicioEmprendedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicioEmprendedors to fetch.
     */
    orderBy?: ServicioEmprendedorOrderByWithRelationInput | ServicioEmprendedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicioEmprendedors.
     */
    cursor?: ServicioEmprendedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicioEmprendedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicioEmprendedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicioEmprendedors.
     */
    distinct?: ServicioEmprendedorScalarFieldEnum | ServicioEmprendedorScalarFieldEnum[]
  }

  /**
   * ServicioEmprendedor findFirstOrThrow
   */
  export type ServicioEmprendedorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorInclude<ExtArgs> | null
    /**
     * Filter, which ServicioEmprendedor to fetch.
     */
    where?: ServicioEmprendedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicioEmprendedors to fetch.
     */
    orderBy?: ServicioEmprendedorOrderByWithRelationInput | ServicioEmprendedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicioEmprendedors.
     */
    cursor?: ServicioEmprendedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicioEmprendedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicioEmprendedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicioEmprendedors.
     */
    distinct?: ServicioEmprendedorScalarFieldEnum | ServicioEmprendedorScalarFieldEnum[]
  }

  /**
   * ServicioEmprendedor findMany
   */
  export type ServicioEmprendedorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorInclude<ExtArgs> | null
    /**
     * Filter, which ServicioEmprendedors to fetch.
     */
    where?: ServicioEmprendedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicioEmprendedors to fetch.
     */
    orderBy?: ServicioEmprendedorOrderByWithRelationInput | ServicioEmprendedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicioEmprendedors.
     */
    cursor?: ServicioEmprendedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicioEmprendedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicioEmprendedors.
     */
    skip?: number
    distinct?: ServicioEmprendedorScalarFieldEnum | ServicioEmprendedorScalarFieldEnum[]
  }

  /**
   * ServicioEmprendedor create
   */
  export type ServicioEmprendedorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicioEmprendedor.
     */
    data: XOR<ServicioEmprendedorCreateInput, ServicioEmprendedorUncheckedCreateInput>
  }

  /**
   * ServicioEmprendedor createMany
   */
  export type ServicioEmprendedorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicioEmprendedors.
     */
    data: ServicioEmprendedorCreateManyInput | ServicioEmprendedorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicioEmprendedor createManyAndReturn
   */
  export type ServicioEmprendedorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * The data used to create many ServicioEmprendedors.
     */
    data: ServicioEmprendedorCreateManyInput | ServicioEmprendedorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicioEmprendedor update
   */
  export type ServicioEmprendedorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicioEmprendedor.
     */
    data: XOR<ServicioEmprendedorUpdateInput, ServicioEmprendedorUncheckedUpdateInput>
    /**
     * Choose, which ServicioEmprendedor to update.
     */
    where: ServicioEmprendedorWhereUniqueInput
  }

  /**
   * ServicioEmprendedor updateMany
   */
  export type ServicioEmprendedorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicioEmprendedors.
     */
    data: XOR<ServicioEmprendedorUpdateManyMutationInput, ServicioEmprendedorUncheckedUpdateManyInput>
    /**
     * Filter which ServicioEmprendedors to update
     */
    where?: ServicioEmprendedorWhereInput
    /**
     * Limit how many ServicioEmprendedors to update.
     */
    limit?: number
  }

  /**
   * ServicioEmprendedor updateManyAndReturn
   */
  export type ServicioEmprendedorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * The data used to update ServicioEmprendedors.
     */
    data: XOR<ServicioEmprendedorUpdateManyMutationInput, ServicioEmprendedorUncheckedUpdateManyInput>
    /**
     * Filter which ServicioEmprendedors to update
     */
    where?: ServicioEmprendedorWhereInput
    /**
     * Limit how many ServicioEmprendedors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicioEmprendedor upsert
   */
  export type ServicioEmprendedorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicioEmprendedor to update in case it exists.
     */
    where: ServicioEmprendedorWhereUniqueInput
    /**
     * In case the ServicioEmprendedor found by the `where` argument doesn't exist, create a new ServicioEmprendedor with this data.
     */
    create: XOR<ServicioEmprendedorCreateInput, ServicioEmprendedorUncheckedCreateInput>
    /**
     * In case the ServicioEmprendedor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicioEmprendedorUpdateInput, ServicioEmprendedorUncheckedUpdateInput>
  }

  /**
   * ServicioEmprendedor delete
   */
  export type ServicioEmprendedorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorInclude<ExtArgs> | null
    /**
     * Filter which ServicioEmprendedor to delete.
     */
    where: ServicioEmprendedorWhereUniqueInput
  }

  /**
   * ServicioEmprendedor deleteMany
   */
  export type ServicioEmprendedorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicioEmprendedors to delete
     */
    where?: ServicioEmprendedorWhereInput
    /**
     * Limit how many ServicioEmprendedors to delete.
     */
    limit?: number
  }

  /**
   * ServicioEmprendedor without action
   */
  export type ServicioEmprendedorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorInclude<ExtArgs> | null
  }


  /**
   * Model Servicio
   */

  export type AggregateServicio = {
    _count: ServicioCountAggregateOutputType | null
    _avg: ServicioAvgAggregateOutputType | null
    _sum: ServicioSumAggregateOutputType | null
    _min: ServicioMinAggregateOutputType | null
    _max: ServicioMaxAggregateOutputType | null
  }

  export type ServicioAvgAggregateOutputType = {
    id: number | null
    tipoServicioId: number | null
    precioBase: Decimal | null
  }

  export type ServicioSumAggregateOutputType = {
    id: number | null
    tipoServicioId: number | null
    precioBase: Decimal | null
  }

  export type ServicioMinAggregateOutputType = {
    id: number | null
    tipoServicioId: number | null
    nombre: string | null
    descripcion: string | null
    precioBase: Decimal | null
    moneda: string | null
    estado: string | null
    imagenUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicioMaxAggregateOutputType = {
    id: number | null
    tipoServicioId: number | null
    nombre: string | null
    descripcion: string | null
    precioBase: Decimal | null
    moneda: string | null
    estado: string | null
    imagenUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicioCountAggregateOutputType = {
    id: number
    tipoServicioId: number
    nombre: number
    descripcion: number
    precioBase: number
    moneda: number
    estado: number
    imagenUrl: number
    detallesServicio: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServicioAvgAggregateInputType = {
    id?: true
    tipoServicioId?: true
    precioBase?: true
  }

  export type ServicioSumAggregateInputType = {
    id?: true
    tipoServicioId?: true
    precioBase?: true
  }

  export type ServicioMinAggregateInputType = {
    id?: true
    tipoServicioId?: true
    nombre?: true
    descripcion?: true
    precioBase?: true
    moneda?: true
    estado?: true
    imagenUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicioMaxAggregateInputType = {
    id?: true
    tipoServicioId?: true
    nombre?: true
    descripcion?: true
    precioBase?: true
    moneda?: true
    estado?: true
    imagenUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicioCountAggregateInputType = {
    id?: true
    tipoServicioId?: true
    nombre?: true
    descripcion?: true
    precioBase?: true
    moneda?: true
    estado?: true
    imagenUrl?: true
    detallesServicio?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServicioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicio to aggregate.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servicios
    **/
    _count?: true | ServicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicioMaxAggregateInputType
  }

  export type GetServicioAggregateType<T extends ServicioAggregateArgs> = {
        [P in keyof T & keyof AggregateServicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicio[P]>
      : GetScalarType<T[P], AggregateServicio[P]>
  }




  export type ServicioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioWhereInput
    orderBy?: ServicioOrderByWithAggregationInput | ServicioOrderByWithAggregationInput[]
    by: ServicioScalarFieldEnum[] | ServicioScalarFieldEnum
    having?: ServicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicioCountAggregateInputType | true
    _avg?: ServicioAvgAggregateInputType
    _sum?: ServicioSumAggregateInputType
    _min?: ServicioMinAggregateInputType
    _max?: ServicioMaxAggregateInputType
  }

  export type ServicioGroupByOutputType = {
    id: number
    tipoServicioId: number
    nombre: string
    descripcion: string | null
    precioBase: Decimal
    moneda: string
    estado: string
    imagenUrl: string
    detallesServicio: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ServicioCountAggregateOutputType | null
    _avg: ServicioAvgAggregateOutputType | null
    _sum: ServicioSumAggregateOutputType | null
    _min: ServicioMinAggregateOutputType | null
    _max: ServicioMaxAggregateOutputType | null
  }

  type GetServicioGroupByPayload<T extends ServicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicioGroupByOutputType[P]>
            : GetScalarType<T[P], ServicioGroupByOutputType[P]>
        }
      >
    >


  export type ServicioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoServicioId?: boolean
    nombre?: boolean
    descripcion?: boolean
    precioBase?: boolean
    moneda?: boolean
    estado?: boolean
    imagenUrl?: boolean
    detallesServicio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itinerariosReserva?: boolean | Servicio$itinerariosReservaArgs<ExtArgs>
    paquetesServicios?: boolean | Servicio$paquetesServiciosArgs<ExtArgs>
    tipoServicio?: boolean | TipoServicioDefaultArgs<ExtArgs>
    disponibilidad?: boolean | Servicio$disponibilidadArgs<ExtArgs>
    serviciosEmprendedores?: boolean | Servicio$serviciosEmprendedoresArgs<ExtArgs>
    _count?: boolean | ServicioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicio"]>

  export type ServicioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoServicioId?: boolean
    nombre?: boolean
    descripcion?: boolean
    precioBase?: boolean
    moneda?: boolean
    estado?: boolean
    imagenUrl?: boolean
    detallesServicio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tipoServicio?: boolean | TipoServicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicio"]>

  export type ServicioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoServicioId?: boolean
    nombre?: boolean
    descripcion?: boolean
    precioBase?: boolean
    moneda?: boolean
    estado?: boolean
    imagenUrl?: boolean
    detallesServicio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tipoServicio?: boolean | TipoServicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicio"]>

  export type ServicioSelectScalar = {
    id?: boolean
    tipoServicioId?: boolean
    nombre?: boolean
    descripcion?: boolean
    precioBase?: boolean
    moneda?: boolean
    estado?: boolean
    imagenUrl?: boolean
    detallesServicio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServicioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipoServicioId" | "nombre" | "descripcion" | "precioBase" | "moneda" | "estado" | "imagenUrl" | "detallesServicio" | "createdAt" | "updatedAt", ExtArgs["result"]["servicio"]>
  export type ServicioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerariosReserva?: boolean | Servicio$itinerariosReservaArgs<ExtArgs>
    paquetesServicios?: boolean | Servicio$paquetesServiciosArgs<ExtArgs>
    tipoServicio?: boolean | TipoServicioDefaultArgs<ExtArgs>
    disponibilidad?: boolean | Servicio$disponibilidadArgs<ExtArgs>
    serviciosEmprendedores?: boolean | Servicio$serviciosEmprendedoresArgs<ExtArgs>
    _count?: boolean | ServicioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServicioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoServicio?: boolean | TipoServicioDefaultArgs<ExtArgs>
  }
  export type ServicioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoServicio?: boolean | TipoServicioDefaultArgs<ExtArgs>
  }

  export type $ServicioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Servicio"
    objects: {
      itinerariosReserva: Prisma.$ItinerarioReservaPayload<ExtArgs>[]
      paquetesServicios: Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>[]
      tipoServicio: Prisma.$TipoServicioPayload<ExtArgs>
      disponibilidad: Prisma.$ServicioDisponibilidadPayload<ExtArgs>[]
      serviciosEmprendedores: Prisma.$ServicioEmprendedorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipoServicioId: number
      nombre: string
      descripcion: string | null
      precioBase: Prisma.Decimal
      moneda: string
      estado: string
      imagenUrl: string
      detallesServicio: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["servicio"]>
    composites: {}
  }

  type ServicioGetPayload<S extends boolean | null | undefined | ServicioDefaultArgs> = $Result.GetResult<Prisma.$ServicioPayload, S>

  type ServicioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicioCountAggregateInputType | true
    }

  export interface ServicioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Servicio'], meta: { name: 'Servicio' } }
    /**
     * Find zero or one Servicio that matches the filter.
     * @param {ServicioFindUniqueArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicioFindUniqueArgs>(args: SelectSubset<T, ServicioFindUniqueArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Servicio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicioFindUniqueOrThrowArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicioFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Servicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindFirstArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicioFindFirstArgs>(args?: SelectSubset<T, ServicioFindFirstArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Servicio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindFirstOrThrowArgs} args - Arguments to find a Servicio
     * @example
     * // Get one Servicio
     * const servicio = await prisma.servicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicioFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Servicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servicios
     * const servicios = await prisma.servicio.findMany()
     * 
     * // Get first 10 Servicios
     * const servicios = await prisma.servicio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicioWithIdOnly = await prisma.servicio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicioFindManyArgs>(args?: SelectSubset<T, ServicioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Servicio.
     * @param {ServicioCreateArgs} args - Arguments to create a Servicio.
     * @example
     * // Create one Servicio
     * const Servicio = await prisma.servicio.create({
     *   data: {
     *     // ... data to create a Servicio
     *   }
     * })
     * 
     */
    create<T extends ServicioCreateArgs>(args: SelectSubset<T, ServicioCreateArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Servicios.
     * @param {ServicioCreateManyArgs} args - Arguments to create many Servicios.
     * @example
     * // Create many Servicios
     * const servicio = await prisma.servicio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicioCreateManyArgs>(args?: SelectSubset<T, ServicioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Servicios and returns the data saved in the database.
     * @param {ServicioCreateManyAndReturnArgs} args - Arguments to create many Servicios.
     * @example
     * // Create many Servicios
     * const servicio = await prisma.servicio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Servicios and only return the `id`
     * const servicioWithIdOnly = await prisma.servicio.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicioCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Servicio.
     * @param {ServicioDeleteArgs} args - Arguments to delete one Servicio.
     * @example
     * // Delete one Servicio
     * const Servicio = await prisma.servicio.delete({
     *   where: {
     *     // ... filter to delete one Servicio
     *   }
     * })
     * 
     */
    delete<T extends ServicioDeleteArgs>(args: SelectSubset<T, ServicioDeleteArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Servicio.
     * @param {ServicioUpdateArgs} args - Arguments to update one Servicio.
     * @example
     * // Update one Servicio
     * const servicio = await prisma.servicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicioUpdateArgs>(args: SelectSubset<T, ServicioUpdateArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Servicios.
     * @param {ServicioDeleteManyArgs} args - Arguments to filter Servicios to delete.
     * @example
     * // Delete a few Servicios
     * const { count } = await prisma.servicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicioDeleteManyArgs>(args?: SelectSubset<T, ServicioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servicios
     * const servicio = await prisma.servicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicioUpdateManyArgs>(args: SelectSubset<T, ServicioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servicios and returns the data updated in the database.
     * @param {ServicioUpdateManyAndReturnArgs} args - Arguments to update many Servicios.
     * @example
     * // Update many Servicios
     * const servicio = await prisma.servicio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Servicios and only return the `id`
     * const servicioWithIdOnly = await prisma.servicio.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServicioUpdateManyAndReturnArgs>(args: SelectSubset<T, ServicioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Servicio.
     * @param {ServicioUpsertArgs} args - Arguments to update or create a Servicio.
     * @example
     * // Update or create a Servicio
     * const servicio = await prisma.servicio.upsert({
     *   create: {
     *     // ... data to create a Servicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Servicio we want to update
     *   }
     * })
     */
    upsert<T extends ServicioUpsertArgs>(args: SelectSubset<T, ServicioUpsertArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Servicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioCountArgs} args - Arguments to filter Servicios to count.
     * @example
     * // Count the number of Servicios
     * const count = await prisma.servicio.count({
     *   where: {
     *     // ... the filter for the Servicios we want to count
     *   }
     * })
    **/
    count<T extends ServicioCountArgs>(
      args?: Subset<T, ServicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicioAggregateArgs>(args: Subset<T, ServicioAggregateArgs>): Prisma.PrismaPromise<GetServicioAggregateType<T>>

    /**
     * Group by Servicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicioGroupByArgs['orderBy'] }
        : { orderBy?: ServicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Servicio model
   */
  readonly fields: ServicioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Servicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itinerariosReserva<T extends Servicio$itinerariosReservaArgs<ExtArgs> = {}>(args?: Subset<T, Servicio$itinerariosReservaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paquetesServicios<T extends Servicio$paquetesServiciosArgs<ExtArgs> = {}>(args?: Subset<T, Servicio$paquetesServiciosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tipoServicio<T extends TipoServicioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TipoServicioDefaultArgs<ExtArgs>>): Prisma__TipoServicioClient<$Result.GetResult<Prisma.$TipoServicioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    disponibilidad<T extends Servicio$disponibilidadArgs<ExtArgs> = {}>(args?: Subset<T, Servicio$disponibilidadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioDisponibilidadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviciosEmprendedores<T extends Servicio$serviciosEmprendedoresArgs<ExtArgs> = {}>(args?: Subset<T, Servicio$serviciosEmprendedoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioEmprendedorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Servicio model
   */
  interface ServicioFieldRefs {
    readonly id: FieldRef<"Servicio", 'Int'>
    readonly tipoServicioId: FieldRef<"Servicio", 'Int'>
    readonly nombre: FieldRef<"Servicio", 'String'>
    readonly descripcion: FieldRef<"Servicio", 'String'>
    readonly precioBase: FieldRef<"Servicio", 'Decimal'>
    readonly moneda: FieldRef<"Servicio", 'String'>
    readonly estado: FieldRef<"Servicio", 'String'>
    readonly imagenUrl: FieldRef<"Servicio", 'String'>
    readonly detallesServicio: FieldRef<"Servicio", 'Json'>
    readonly createdAt: FieldRef<"Servicio", 'DateTime'>
    readonly updatedAt: FieldRef<"Servicio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Servicio findUnique
   */
  export type ServicioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio findUniqueOrThrow
   */
  export type ServicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio findFirst
   */
  export type ServicioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Servicio findFirstOrThrow
   */
  export type ServicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicio to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servicios.
     */
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Servicio findMany
   */
  export type ServicioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter, which Servicios to fetch.
     */
    where?: ServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servicios to fetch.
     */
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servicios.
     */
    cursor?: ServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servicios.
     */
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * Servicio create
   */
  export type ServicioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The data needed to create a Servicio.
     */
    data: XOR<ServicioCreateInput, ServicioUncheckedCreateInput>
  }

  /**
   * Servicio createMany
   */
  export type ServicioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Servicios.
     */
    data: ServicioCreateManyInput | ServicioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Servicio createManyAndReturn
   */
  export type ServicioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * The data used to create many Servicios.
     */
    data: ServicioCreateManyInput | ServicioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Servicio update
   */
  export type ServicioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The data needed to update a Servicio.
     */
    data: XOR<ServicioUpdateInput, ServicioUncheckedUpdateInput>
    /**
     * Choose, which Servicio to update.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio updateMany
   */
  export type ServicioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Servicios.
     */
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyInput>
    /**
     * Filter which Servicios to update
     */
    where?: ServicioWhereInput
    /**
     * Limit how many Servicios to update.
     */
    limit?: number
  }

  /**
   * Servicio updateManyAndReturn
   */
  export type ServicioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * The data used to update Servicios.
     */
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyInput>
    /**
     * Filter which Servicios to update
     */
    where?: ServicioWhereInput
    /**
     * Limit how many Servicios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Servicio upsert
   */
  export type ServicioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * The filter to search for the Servicio to update in case it exists.
     */
    where: ServicioWhereUniqueInput
    /**
     * In case the Servicio found by the `where` argument doesn't exist, create a new Servicio with this data.
     */
    create: XOR<ServicioCreateInput, ServicioUncheckedCreateInput>
    /**
     * In case the Servicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicioUpdateInput, ServicioUncheckedUpdateInput>
  }

  /**
   * Servicio delete
   */
  export type ServicioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    /**
     * Filter which Servicio to delete.
     */
    where: ServicioWhereUniqueInput
  }

  /**
   * Servicio deleteMany
   */
  export type ServicioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servicios to delete
     */
    where?: ServicioWhereInput
    /**
     * Limit how many Servicios to delete.
     */
    limit?: number
  }

  /**
   * Servicio.itinerariosReserva
   */
  export type Servicio$itinerariosReservaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaInclude<ExtArgs> | null
    where?: ItinerarioReservaWhereInput
    orderBy?: ItinerarioReservaOrderByWithRelationInput | ItinerarioReservaOrderByWithRelationInput[]
    cursor?: ItinerarioReservaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItinerarioReservaScalarFieldEnum | ItinerarioReservaScalarFieldEnum[]
  }

  /**
   * Servicio.paquetesServicios
   */
  export type Servicio$paquetesServiciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioInclude<ExtArgs> | null
    where?: PaqueteTuristicoServicioWhereInput
    orderBy?: PaqueteTuristicoServicioOrderByWithRelationInput | PaqueteTuristicoServicioOrderByWithRelationInput[]
    cursor?: PaqueteTuristicoServicioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaqueteTuristicoServicioScalarFieldEnum | PaqueteTuristicoServicioScalarFieldEnum[]
  }

  /**
   * Servicio.disponibilidad
   */
  export type Servicio$disponibilidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioDisponibilidad
     */
    select?: ServicioDisponibilidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioDisponibilidad
     */
    omit?: ServicioDisponibilidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioDisponibilidadInclude<ExtArgs> | null
    where?: ServicioDisponibilidadWhereInput
    orderBy?: ServicioDisponibilidadOrderByWithRelationInput | ServicioDisponibilidadOrderByWithRelationInput[]
    cursor?: ServicioDisponibilidadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicioDisponibilidadScalarFieldEnum | ServicioDisponibilidadScalarFieldEnum[]
  }

  /**
   * Servicio.serviciosEmprendedores
   */
  export type Servicio$serviciosEmprendedoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioEmprendedor
     */
    select?: ServicioEmprendedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioEmprendedor
     */
    omit?: ServicioEmprendedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioEmprendedorInclude<ExtArgs> | null
    where?: ServicioEmprendedorWhereInput
    orderBy?: ServicioEmprendedorOrderByWithRelationInput | ServicioEmprendedorOrderByWithRelationInput[]
    cursor?: ServicioEmprendedorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicioEmprendedorScalarFieldEnum | ServicioEmprendedorScalarFieldEnum[]
  }

  /**
   * Servicio without action
   */
  export type ServicioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
  }


  /**
   * Model PaqueteTuristicoServicio
   */

  export type AggregatePaqueteTuristicoServicio = {
    _count: PaqueteTuristicoServicioCountAggregateOutputType | null
    _avg: PaqueteTuristicoServicioAvgAggregateOutputType | null
    _sum: PaqueteTuristicoServicioSumAggregateOutputType | null
    _min: PaqueteTuristicoServicioMinAggregateOutputType | null
    _max: PaqueteTuristicoServicioMaxAggregateOutputType | null
  }

  export type PaqueteTuristicoServicioAvgAggregateOutputType = {
    id: number | null
    servicioId: number | null
    paqueteTuristicoId: number | null
  }

  export type PaqueteTuristicoServicioSumAggregateOutputType = {
    id: number | null
    servicioId: number | null
    paqueteTuristicoId: number | null
  }

  export type PaqueteTuristicoServicioMinAggregateOutputType = {
    id: number | null
    servicioId: number | null
    paqueteTuristicoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaqueteTuristicoServicioMaxAggregateOutputType = {
    id: number | null
    servicioId: number | null
    paqueteTuristicoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaqueteTuristicoServicioCountAggregateOutputType = {
    id: number
    servicioId: number
    paqueteTuristicoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaqueteTuristicoServicioAvgAggregateInputType = {
    id?: true
    servicioId?: true
    paqueteTuristicoId?: true
  }

  export type PaqueteTuristicoServicioSumAggregateInputType = {
    id?: true
    servicioId?: true
    paqueteTuristicoId?: true
  }

  export type PaqueteTuristicoServicioMinAggregateInputType = {
    id?: true
    servicioId?: true
    paqueteTuristicoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaqueteTuristicoServicioMaxAggregateInputType = {
    id?: true
    servicioId?: true
    paqueteTuristicoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaqueteTuristicoServicioCountAggregateInputType = {
    id?: true
    servicioId?: true
    paqueteTuristicoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaqueteTuristicoServicioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaqueteTuristicoServicio to aggregate.
     */
    where?: PaqueteTuristicoServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteTuristicoServicios to fetch.
     */
    orderBy?: PaqueteTuristicoServicioOrderByWithRelationInput | PaqueteTuristicoServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaqueteTuristicoServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteTuristicoServicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteTuristicoServicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaqueteTuristicoServicios
    **/
    _count?: true | PaqueteTuristicoServicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaqueteTuristicoServicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaqueteTuristicoServicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaqueteTuristicoServicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaqueteTuristicoServicioMaxAggregateInputType
  }

  export type GetPaqueteTuristicoServicioAggregateType<T extends PaqueteTuristicoServicioAggregateArgs> = {
        [P in keyof T & keyof AggregatePaqueteTuristicoServicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaqueteTuristicoServicio[P]>
      : GetScalarType<T[P], AggregatePaqueteTuristicoServicio[P]>
  }




  export type PaqueteTuristicoServicioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaqueteTuristicoServicioWhereInput
    orderBy?: PaqueteTuristicoServicioOrderByWithAggregationInput | PaqueteTuristicoServicioOrderByWithAggregationInput[]
    by: PaqueteTuristicoServicioScalarFieldEnum[] | PaqueteTuristicoServicioScalarFieldEnum
    having?: PaqueteTuristicoServicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaqueteTuristicoServicioCountAggregateInputType | true
    _avg?: PaqueteTuristicoServicioAvgAggregateInputType
    _sum?: PaqueteTuristicoServicioSumAggregateInputType
    _min?: PaqueteTuristicoServicioMinAggregateInputType
    _max?: PaqueteTuristicoServicioMaxAggregateInputType
  }

  export type PaqueteTuristicoServicioGroupByOutputType = {
    id: number
    servicioId: number
    paqueteTuristicoId: number
    createdAt: Date
    updatedAt: Date
    _count: PaqueteTuristicoServicioCountAggregateOutputType | null
    _avg: PaqueteTuristicoServicioAvgAggregateOutputType | null
    _sum: PaqueteTuristicoServicioSumAggregateOutputType | null
    _min: PaqueteTuristicoServicioMinAggregateOutputType | null
    _max: PaqueteTuristicoServicioMaxAggregateOutputType | null
  }

  type GetPaqueteTuristicoServicioGroupByPayload<T extends PaqueteTuristicoServicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaqueteTuristicoServicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaqueteTuristicoServicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaqueteTuristicoServicioGroupByOutputType[P]>
            : GetScalarType<T[P], PaqueteTuristicoServicioGroupByOutputType[P]>
        }
      >
    >


  export type PaqueteTuristicoServicioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicioId?: boolean
    paqueteTuristicoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paqueteTuristico?: boolean | PaqueteTuristicoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paqueteTuristicoServicio"]>

  export type PaqueteTuristicoServicioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicioId?: boolean
    paqueteTuristicoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paqueteTuristico?: boolean | PaqueteTuristicoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paqueteTuristicoServicio"]>

  export type PaqueteTuristicoServicioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicioId?: boolean
    paqueteTuristicoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paqueteTuristico?: boolean | PaqueteTuristicoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paqueteTuristicoServicio"]>

  export type PaqueteTuristicoServicioSelectScalar = {
    id?: boolean
    servicioId?: boolean
    paqueteTuristicoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaqueteTuristicoServicioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "servicioId" | "paqueteTuristicoId" | "createdAt" | "updatedAt", ExtArgs["result"]["paqueteTuristicoServicio"]>
  export type PaqueteTuristicoServicioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paqueteTuristico?: boolean | PaqueteTuristicoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }
  export type PaqueteTuristicoServicioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paqueteTuristico?: boolean | PaqueteTuristicoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }
  export type PaqueteTuristicoServicioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paqueteTuristico?: boolean | PaqueteTuristicoDefaultArgs<ExtArgs>
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }

  export type $PaqueteTuristicoServicioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaqueteTuristicoServicio"
    objects: {
      paqueteTuristico: Prisma.$PaqueteTuristicoPayload<ExtArgs>
      servicio: Prisma.$ServicioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      servicioId: number
      paqueteTuristicoId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paqueteTuristicoServicio"]>
    composites: {}
  }

  type PaqueteTuristicoServicioGetPayload<S extends boolean | null | undefined | PaqueteTuristicoServicioDefaultArgs> = $Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload, S>

  type PaqueteTuristicoServicioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaqueteTuristicoServicioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaqueteTuristicoServicioCountAggregateInputType | true
    }

  export interface PaqueteTuristicoServicioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaqueteTuristicoServicio'], meta: { name: 'PaqueteTuristicoServicio' } }
    /**
     * Find zero or one PaqueteTuristicoServicio that matches the filter.
     * @param {PaqueteTuristicoServicioFindUniqueArgs} args - Arguments to find a PaqueteTuristicoServicio
     * @example
     * // Get one PaqueteTuristicoServicio
     * const paqueteTuristicoServicio = await prisma.paqueteTuristicoServicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaqueteTuristicoServicioFindUniqueArgs>(args: SelectSubset<T, PaqueteTuristicoServicioFindUniqueArgs<ExtArgs>>): Prisma__PaqueteTuristicoServicioClient<$Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaqueteTuristicoServicio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaqueteTuristicoServicioFindUniqueOrThrowArgs} args - Arguments to find a PaqueteTuristicoServicio
     * @example
     * // Get one PaqueteTuristicoServicio
     * const paqueteTuristicoServicio = await prisma.paqueteTuristicoServicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaqueteTuristicoServicioFindUniqueOrThrowArgs>(args: SelectSubset<T, PaqueteTuristicoServicioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaqueteTuristicoServicioClient<$Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaqueteTuristicoServicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoServicioFindFirstArgs} args - Arguments to find a PaqueteTuristicoServicio
     * @example
     * // Get one PaqueteTuristicoServicio
     * const paqueteTuristicoServicio = await prisma.paqueteTuristicoServicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaqueteTuristicoServicioFindFirstArgs>(args?: SelectSubset<T, PaqueteTuristicoServicioFindFirstArgs<ExtArgs>>): Prisma__PaqueteTuristicoServicioClient<$Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaqueteTuristicoServicio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoServicioFindFirstOrThrowArgs} args - Arguments to find a PaqueteTuristicoServicio
     * @example
     * // Get one PaqueteTuristicoServicio
     * const paqueteTuristicoServicio = await prisma.paqueteTuristicoServicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaqueteTuristicoServicioFindFirstOrThrowArgs>(args?: SelectSubset<T, PaqueteTuristicoServicioFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaqueteTuristicoServicioClient<$Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaqueteTuristicoServicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoServicioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaqueteTuristicoServicios
     * const paqueteTuristicoServicios = await prisma.paqueteTuristicoServicio.findMany()
     * 
     * // Get first 10 PaqueteTuristicoServicios
     * const paqueteTuristicoServicios = await prisma.paqueteTuristicoServicio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paqueteTuristicoServicioWithIdOnly = await prisma.paqueteTuristicoServicio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaqueteTuristicoServicioFindManyArgs>(args?: SelectSubset<T, PaqueteTuristicoServicioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaqueteTuristicoServicio.
     * @param {PaqueteTuristicoServicioCreateArgs} args - Arguments to create a PaqueteTuristicoServicio.
     * @example
     * // Create one PaqueteTuristicoServicio
     * const PaqueteTuristicoServicio = await prisma.paqueteTuristicoServicio.create({
     *   data: {
     *     // ... data to create a PaqueteTuristicoServicio
     *   }
     * })
     * 
     */
    create<T extends PaqueteTuristicoServicioCreateArgs>(args: SelectSubset<T, PaqueteTuristicoServicioCreateArgs<ExtArgs>>): Prisma__PaqueteTuristicoServicioClient<$Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaqueteTuristicoServicios.
     * @param {PaqueteTuristicoServicioCreateManyArgs} args - Arguments to create many PaqueteTuristicoServicios.
     * @example
     * // Create many PaqueteTuristicoServicios
     * const paqueteTuristicoServicio = await prisma.paqueteTuristicoServicio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaqueteTuristicoServicioCreateManyArgs>(args?: SelectSubset<T, PaqueteTuristicoServicioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaqueteTuristicoServicios and returns the data saved in the database.
     * @param {PaqueteTuristicoServicioCreateManyAndReturnArgs} args - Arguments to create many PaqueteTuristicoServicios.
     * @example
     * // Create many PaqueteTuristicoServicios
     * const paqueteTuristicoServicio = await prisma.paqueteTuristicoServicio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaqueteTuristicoServicios and only return the `id`
     * const paqueteTuristicoServicioWithIdOnly = await prisma.paqueteTuristicoServicio.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaqueteTuristicoServicioCreateManyAndReturnArgs>(args?: SelectSubset<T, PaqueteTuristicoServicioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaqueteTuristicoServicio.
     * @param {PaqueteTuristicoServicioDeleteArgs} args - Arguments to delete one PaqueteTuristicoServicio.
     * @example
     * // Delete one PaqueteTuristicoServicio
     * const PaqueteTuristicoServicio = await prisma.paqueteTuristicoServicio.delete({
     *   where: {
     *     // ... filter to delete one PaqueteTuristicoServicio
     *   }
     * })
     * 
     */
    delete<T extends PaqueteTuristicoServicioDeleteArgs>(args: SelectSubset<T, PaqueteTuristicoServicioDeleteArgs<ExtArgs>>): Prisma__PaqueteTuristicoServicioClient<$Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaqueteTuristicoServicio.
     * @param {PaqueteTuristicoServicioUpdateArgs} args - Arguments to update one PaqueteTuristicoServicio.
     * @example
     * // Update one PaqueteTuristicoServicio
     * const paqueteTuristicoServicio = await prisma.paqueteTuristicoServicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaqueteTuristicoServicioUpdateArgs>(args: SelectSubset<T, PaqueteTuristicoServicioUpdateArgs<ExtArgs>>): Prisma__PaqueteTuristicoServicioClient<$Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaqueteTuristicoServicios.
     * @param {PaqueteTuristicoServicioDeleteManyArgs} args - Arguments to filter PaqueteTuristicoServicios to delete.
     * @example
     * // Delete a few PaqueteTuristicoServicios
     * const { count } = await prisma.paqueteTuristicoServicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaqueteTuristicoServicioDeleteManyArgs>(args?: SelectSubset<T, PaqueteTuristicoServicioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaqueteTuristicoServicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoServicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaqueteTuristicoServicios
     * const paqueteTuristicoServicio = await prisma.paqueteTuristicoServicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaqueteTuristicoServicioUpdateManyArgs>(args: SelectSubset<T, PaqueteTuristicoServicioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaqueteTuristicoServicios and returns the data updated in the database.
     * @param {PaqueteTuristicoServicioUpdateManyAndReturnArgs} args - Arguments to update many PaqueteTuristicoServicios.
     * @example
     * // Update many PaqueteTuristicoServicios
     * const paqueteTuristicoServicio = await prisma.paqueteTuristicoServicio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaqueteTuristicoServicios and only return the `id`
     * const paqueteTuristicoServicioWithIdOnly = await prisma.paqueteTuristicoServicio.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaqueteTuristicoServicioUpdateManyAndReturnArgs>(args: SelectSubset<T, PaqueteTuristicoServicioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaqueteTuristicoServicio.
     * @param {PaqueteTuristicoServicioUpsertArgs} args - Arguments to update or create a PaqueteTuristicoServicio.
     * @example
     * // Update or create a PaqueteTuristicoServicio
     * const paqueteTuristicoServicio = await prisma.paqueteTuristicoServicio.upsert({
     *   create: {
     *     // ... data to create a PaqueteTuristicoServicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaqueteTuristicoServicio we want to update
     *   }
     * })
     */
    upsert<T extends PaqueteTuristicoServicioUpsertArgs>(args: SelectSubset<T, PaqueteTuristicoServicioUpsertArgs<ExtArgs>>): Prisma__PaqueteTuristicoServicioClient<$Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaqueteTuristicoServicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoServicioCountArgs} args - Arguments to filter PaqueteTuristicoServicios to count.
     * @example
     * // Count the number of PaqueteTuristicoServicios
     * const count = await prisma.paqueteTuristicoServicio.count({
     *   where: {
     *     // ... the filter for the PaqueteTuristicoServicios we want to count
     *   }
     * })
    **/
    count<T extends PaqueteTuristicoServicioCountArgs>(
      args?: Subset<T, PaqueteTuristicoServicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaqueteTuristicoServicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaqueteTuristicoServicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoServicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaqueteTuristicoServicioAggregateArgs>(args: Subset<T, PaqueteTuristicoServicioAggregateArgs>): Prisma.PrismaPromise<GetPaqueteTuristicoServicioAggregateType<T>>

    /**
     * Group by PaqueteTuristicoServicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoServicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaqueteTuristicoServicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaqueteTuristicoServicioGroupByArgs['orderBy'] }
        : { orderBy?: PaqueteTuristicoServicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaqueteTuristicoServicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaqueteTuristicoServicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaqueteTuristicoServicio model
   */
  readonly fields: PaqueteTuristicoServicioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaqueteTuristicoServicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaqueteTuristicoServicioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paqueteTuristico<T extends PaqueteTuristicoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaqueteTuristicoDefaultArgs<ExtArgs>>): Prisma__PaqueteTuristicoClient<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    servicio<T extends ServicioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServicioDefaultArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaqueteTuristicoServicio model
   */
  interface PaqueteTuristicoServicioFieldRefs {
    readonly id: FieldRef<"PaqueteTuristicoServicio", 'Int'>
    readonly servicioId: FieldRef<"PaqueteTuristicoServicio", 'Int'>
    readonly paqueteTuristicoId: FieldRef<"PaqueteTuristicoServicio", 'Int'>
    readonly createdAt: FieldRef<"PaqueteTuristicoServicio", 'DateTime'>
    readonly updatedAt: FieldRef<"PaqueteTuristicoServicio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaqueteTuristicoServicio findUnique
   */
  export type PaqueteTuristicoServicioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTuristicoServicio to fetch.
     */
    where: PaqueteTuristicoServicioWhereUniqueInput
  }

  /**
   * PaqueteTuristicoServicio findUniqueOrThrow
   */
  export type PaqueteTuristicoServicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTuristicoServicio to fetch.
     */
    where: PaqueteTuristicoServicioWhereUniqueInput
  }

  /**
   * PaqueteTuristicoServicio findFirst
   */
  export type PaqueteTuristicoServicioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTuristicoServicio to fetch.
     */
    where?: PaqueteTuristicoServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteTuristicoServicios to fetch.
     */
    orderBy?: PaqueteTuristicoServicioOrderByWithRelationInput | PaqueteTuristicoServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaqueteTuristicoServicios.
     */
    cursor?: PaqueteTuristicoServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteTuristicoServicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteTuristicoServicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaqueteTuristicoServicios.
     */
    distinct?: PaqueteTuristicoServicioScalarFieldEnum | PaqueteTuristicoServicioScalarFieldEnum[]
  }

  /**
   * PaqueteTuristicoServicio findFirstOrThrow
   */
  export type PaqueteTuristicoServicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTuristicoServicio to fetch.
     */
    where?: PaqueteTuristicoServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteTuristicoServicios to fetch.
     */
    orderBy?: PaqueteTuristicoServicioOrderByWithRelationInput | PaqueteTuristicoServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaqueteTuristicoServicios.
     */
    cursor?: PaqueteTuristicoServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteTuristicoServicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteTuristicoServicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaqueteTuristicoServicios.
     */
    distinct?: PaqueteTuristicoServicioScalarFieldEnum | PaqueteTuristicoServicioScalarFieldEnum[]
  }

  /**
   * PaqueteTuristicoServicio findMany
   */
  export type PaqueteTuristicoServicioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTuristicoServicios to fetch.
     */
    where?: PaqueteTuristicoServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteTuristicoServicios to fetch.
     */
    orderBy?: PaqueteTuristicoServicioOrderByWithRelationInput | PaqueteTuristicoServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaqueteTuristicoServicios.
     */
    cursor?: PaqueteTuristicoServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteTuristicoServicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteTuristicoServicios.
     */
    skip?: number
    distinct?: PaqueteTuristicoServicioScalarFieldEnum | PaqueteTuristicoServicioScalarFieldEnum[]
  }

  /**
   * PaqueteTuristicoServicio create
   */
  export type PaqueteTuristicoServicioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioInclude<ExtArgs> | null
    /**
     * The data needed to create a PaqueteTuristicoServicio.
     */
    data: XOR<PaqueteTuristicoServicioCreateInput, PaqueteTuristicoServicioUncheckedCreateInput>
  }

  /**
   * PaqueteTuristicoServicio createMany
   */
  export type PaqueteTuristicoServicioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaqueteTuristicoServicios.
     */
    data: PaqueteTuristicoServicioCreateManyInput | PaqueteTuristicoServicioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaqueteTuristicoServicio createManyAndReturn
   */
  export type PaqueteTuristicoServicioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * The data used to create many PaqueteTuristicoServicios.
     */
    data: PaqueteTuristicoServicioCreateManyInput | PaqueteTuristicoServicioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaqueteTuristicoServicio update
   */
  export type PaqueteTuristicoServicioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioInclude<ExtArgs> | null
    /**
     * The data needed to update a PaqueteTuristicoServicio.
     */
    data: XOR<PaqueteTuristicoServicioUpdateInput, PaqueteTuristicoServicioUncheckedUpdateInput>
    /**
     * Choose, which PaqueteTuristicoServicio to update.
     */
    where: PaqueteTuristicoServicioWhereUniqueInput
  }

  /**
   * PaqueteTuristicoServicio updateMany
   */
  export type PaqueteTuristicoServicioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaqueteTuristicoServicios.
     */
    data: XOR<PaqueteTuristicoServicioUpdateManyMutationInput, PaqueteTuristicoServicioUncheckedUpdateManyInput>
    /**
     * Filter which PaqueteTuristicoServicios to update
     */
    where?: PaqueteTuristicoServicioWhereInput
    /**
     * Limit how many PaqueteTuristicoServicios to update.
     */
    limit?: number
  }

  /**
   * PaqueteTuristicoServicio updateManyAndReturn
   */
  export type PaqueteTuristicoServicioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * The data used to update PaqueteTuristicoServicios.
     */
    data: XOR<PaqueteTuristicoServicioUpdateManyMutationInput, PaqueteTuristicoServicioUncheckedUpdateManyInput>
    /**
     * Filter which PaqueteTuristicoServicios to update
     */
    where?: PaqueteTuristicoServicioWhereInput
    /**
     * Limit how many PaqueteTuristicoServicios to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaqueteTuristicoServicio upsert
   */
  export type PaqueteTuristicoServicioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioInclude<ExtArgs> | null
    /**
     * The filter to search for the PaqueteTuristicoServicio to update in case it exists.
     */
    where: PaqueteTuristicoServicioWhereUniqueInput
    /**
     * In case the PaqueteTuristicoServicio found by the `where` argument doesn't exist, create a new PaqueteTuristicoServicio with this data.
     */
    create: XOR<PaqueteTuristicoServicioCreateInput, PaqueteTuristicoServicioUncheckedCreateInput>
    /**
     * In case the PaqueteTuristicoServicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaqueteTuristicoServicioUpdateInput, PaqueteTuristicoServicioUncheckedUpdateInput>
  }

  /**
   * PaqueteTuristicoServicio delete
   */
  export type PaqueteTuristicoServicioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioInclude<ExtArgs> | null
    /**
     * Filter which PaqueteTuristicoServicio to delete.
     */
    where: PaqueteTuristicoServicioWhereUniqueInput
  }

  /**
   * PaqueteTuristicoServicio deleteMany
   */
  export type PaqueteTuristicoServicioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaqueteTuristicoServicios to delete
     */
    where?: PaqueteTuristicoServicioWhereInput
    /**
     * Limit how many PaqueteTuristicoServicios to delete.
     */
    limit?: number
  }

  /**
   * PaqueteTuristicoServicio without action
   */
  export type PaqueteTuristicoServicioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioInclude<ExtArgs> | null
  }


  /**
   * Model PaqueteTuristico
   */

  export type AggregatePaqueteTuristico = {
    _count: PaqueteTuristicoCountAggregateOutputType | null
    _avg: PaqueteTuristicoAvgAggregateOutputType | null
    _sum: PaqueteTuristicoSumAggregateOutputType | null
    _min: PaqueteTuristicoMinAggregateOutputType | null
    _max: PaqueteTuristicoMaxAggregateOutputType | null
  }

  export type PaqueteTuristicoAvgAggregateOutputType = {
    id: number | null
    emprendimientoId: number | null
    duracionDias: number | null
    duracionNoches: number | null
    precioPorPersona: Decimal | null
    capacidadMaxima: number | null
  }

  export type PaqueteTuristicoSumAggregateOutputType = {
    id: number | null
    emprendimientoId: number | null
    duracionDias: number | null
    duracionNoches: number | null
    precioPorPersona: Decimal | null
    capacidadMaxima: number | null
  }

  export type PaqueteTuristicoMinAggregateOutputType = {
    id: number | null
    emprendimientoId: number | null
    nombre: string | null
    descripcion: string | null
    duracionDias: number | null
    duracionNoches: number | null
    precioPorPersona: Decimal | null
    moneda: string | null
    capacidadMaxima: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    requisitos: string | null
    incluye: string | null
    noIncluye: string | null
    estado: string | null
    esPersonalizable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaqueteTuristicoMaxAggregateOutputType = {
    id: number | null
    emprendimientoId: number | null
    nombre: string | null
    descripcion: string | null
    duracionDias: number | null
    duracionNoches: number | null
    precioPorPersona: Decimal | null
    moneda: string | null
    capacidadMaxima: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    requisitos: string | null
    incluye: string | null
    noIncluye: string | null
    estado: string | null
    esPersonalizable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaqueteTuristicoCountAggregateOutputType = {
    id: number
    emprendimientoId: number
    nombre: number
    descripcion: number
    duracionDias: number
    duracionNoches: number
    precioPorPersona: number
    moneda: number
    capacidadMaxima: number
    fechaInicio: number
    fechaFin: number
    lugaresVisitados: number
    requisitos: number
    incluye: number
    noIncluye: number
    estado: number
    esPersonalizable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaqueteTuristicoAvgAggregateInputType = {
    id?: true
    emprendimientoId?: true
    duracionDias?: true
    duracionNoches?: true
    precioPorPersona?: true
    capacidadMaxima?: true
  }

  export type PaqueteTuristicoSumAggregateInputType = {
    id?: true
    emprendimientoId?: true
    duracionDias?: true
    duracionNoches?: true
    precioPorPersona?: true
    capacidadMaxima?: true
  }

  export type PaqueteTuristicoMinAggregateInputType = {
    id?: true
    emprendimientoId?: true
    nombre?: true
    descripcion?: true
    duracionDias?: true
    duracionNoches?: true
    precioPorPersona?: true
    moneda?: true
    capacidadMaxima?: true
    fechaInicio?: true
    fechaFin?: true
    requisitos?: true
    incluye?: true
    noIncluye?: true
    estado?: true
    esPersonalizable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaqueteTuristicoMaxAggregateInputType = {
    id?: true
    emprendimientoId?: true
    nombre?: true
    descripcion?: true
    duracionDias?: true
    duracionNoches?: true
    precioPorPersona?: true
    moneda?: true
    capacidadMaxima?: true
    fechaInicio?: true
    fechaFin?: true
    requisitos?: true
    incluye?: true
    noIncluye?: true
    estado?: true
    esPersonalizable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaqueteTuristicoCountAggregateInputType = {
    id?: true
    emprendimientoId?: true
    nombre?: true
    descripcion?: true
    duracionDias?: true
    duracionNoches?: true
    precioPorPersona?: true
    moneda?: true
    capacidadMaxima?: true
    fechaInicio?: true
    fechaFin?: true
    lugaresVisitados?: true
    requisitos?: true
    incluye?: true
    noIncluye?: true
    estado?: true
    esPersonalizable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaqueteTuristicoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaqueteTuristico to aggregate.
     */
    where?: PaqueteTuristicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteTuristicos to fetch.
     */
    orderBy?: PaqueteTuristicoOrderByWithRelationInput | PaqueteTuristicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaqueteTuristicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteTuristicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteTuristicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaqueteTuristicos
    **/
    _count?: true | PaqueteTuristicoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaqueteTuristicoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaqueteTuristicoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaqueteTuristicoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaqueteTuristicoMaxAggregateInputType
  }

  export type GetPaqueteTuristicoAggregateType<T extends PaqueteTuristicoAggregateArgs> = {
        [P in keyof T & keyof AggregatePaqueteTuristico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaqueteTuristico[P]>
      : GetScalarType<T[P], AggregatePaqueteTuristico[P]>
  }




  export type PaqueteTuristicoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaqueteTuristicoWhereInput
    orderBy?: PaqueteTuristicoOrderByWithAggregationInput | PaqueteTuristicoOrderByWithAggregationInput[]
    by: PaqueteTuristicoScalarFieldEnum[] | PaqueteTuristicoScalarFieldEnum
    having?: PaqueteTuristicoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaqueteTuristicoCountAggregateInputType | true
    _avg?: PaqueteTuristicoAvgAggregateInputType
    _sum?: PaqueteTuristicoSumAggregateInputType
    _min?: PaqueteTuristicoMinAggregateInputType
    _max?: PaqueteTuristicoMaxAggregateInputType
  }

  export type PaqueteTuristicoGroupByOutputType = {
    id: number
    emprendimientoId: number | null
    nombre: string
    descripcion: string
    duracionDias: number
    duracionNoches: number | null
    precioPorPersona: Decimal
    moneda: string
    capacidadMaxima: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    lugaresVisitados: JsonValue | null
    requisitos: string | null
    incluye: string | null
    noIncluye: string | null
    estado: string
    esPersonalizable: boolean
    createdAt: Date
    updatedAt: Date
    _count: PaqueteTuristicoCountAggregateOutputType | null
    _avg: PaqueteTuristicoAvgAggregateOutputType | null
    _sum: PaqueteTuristicoSumAggregateOutputType | null
    _min: PaqueteTuristicoMinAggregateOutputType | null
    _max: PaqueteTuristicoMaxAggregateOutputType | null
  }

  type GetPaqueteTuristicoGroupByPayload<T extends PaqueteTuristicoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaqueteTuristicoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaqueteTuristicoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaqueteTuristicoGroupByOutputType[P]>
            : GetScalarType<T[P], PaqueteTuristicoGroupByOutputType[P]>
        }
      >
    >


  export type PaqueteTuristicoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emprendimientoId?: boolean
    nombre?: boolean
    descripcion?: boolean
    duracionDias?: boolean
    duracionNoches?: boolean
    precioPorPersona?: boolean
    moneda?: boolean
    capacidadMaxima?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    lugaresVisitados?: boolean
    requisitos?: boolean
    incluye?: boolean
    noIncluye?: boolean
    estado?: boolean
    esPersonalizable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    disponibilidad?: boolean | PaqueteTuristico$disponibilidadArgs<ExtArgs>
    emprendimiento?: boolean | PaqueteTuristico$emprendimientoArgs<ExtArgs>
    servicios?: boolean | PaqueteTuristico$serviciosArgs<ExtArgs>
    _count?: boolean | PaqueteTuristicoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paqueteTuristico"]>

  export type PaqueteTuristicoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emprendimientoId?: boolean
    nombre?: boolean
    descripcion?: boolean
    duracionDias?: boolean
    duracionNoches?: boolean
    precioPorPersona?: boolean
    moneda?: boolean
    capacidadMaxima?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    lugaresVisitados?: boolean
    requisitos?: boolean
    incluye?: boolean
    noIncluye?: boolean
    estado?: boolean
    esPersonalizable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emprendimiento?: boolean | PaqueteTuristico$emprendimientoArgs<ExtArgs>
  }, ExtArgs["result"]["paqueteTuristico"]>

  export type PaqueteTuristicoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emprendimientoId?: boolean
    nombre?: boolean
    descripcion?: boolean
    duracionDias?: boolean
    duracionNoches?: boolean
    precioPorPersona?: boolean
    moneda?: boolean
    capacidadMaxima?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    lugaresVisitados?: boolean
    requisitos?: boolean
    incluye?: boolean
    noIncluye?: boolean
    estado?: boolean
    esPersonalizable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    emprendimiento?: boolean | PaqueteTuristico$emprendimientoArgs<ExtArgs>
  }, ExtArgs["result"]["paqueteTuristico"]>

  export type PaqueteTuristicoSelectScalar = {
    id?: boolean
    emprendimientoId?: boolean
    nombre?: boolean
    descripcion?: boolean
    duracionDias?: boolean
    duracionNoches?: boolean
    precioPorPersona?: boolean
    moneda?: boolean
    capacidadMaxima?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    lugaresVisitados?: boolean
    requisitos?: boolean
    incluye?: boolean
    noIncluye?: boolean
    estado?: boolean
    esPersonalizable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaqueteTuristicoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emprendimientoId" | "nombre" | "descripcion" | "duracionDias" | "duracionNoches" | "precioPorPersona" | "moneda" | "capacidadMaxima" | "fechaInicio" | "fechaFin" | "lugaresVisitados" | "requisitos" | "incluye" | "noIncluye" | "estado" | "esPersonalizable" | "createdAt" | "updatedAt", ExtArgs["result"]["paqueteTuristico"]>
  export type PaqueteTuristicoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disponibilidad?: boolean | PaqueteTuristico$disponibilidadArgs<ExtArgs>
    emprendimiento?: boolean | PaqueteTuristico$emprendimientoArgs<ExtArgs>
    servicios?: boolean | PaqueteTuristico$serviciosArgs<ExtArgs>
    _count?: boolean | PaqueteTuristicoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaqueteTuristicoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimiento?: boolean | PaqueteTuristico$emprendimientoArgs<ExtArgs>
  }
  export type PaqueteTuristicoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimiento?: boolean | PaqueteTuristico$emprendimientoArgs<ExtArgs>
  }

  export type $PaqueteTuristicoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaqueteTuristico"
    objects: {
      disponibilidad: Prisma.$DisponibilidadPaquetePayload<ExtArgs>[]
      emprendimiento: Prisma.$EmprendimientoPayload<ExtArgs> | null
      servicios: Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      emprendimientoId: number | null
      nombre: string
      descripcion: string
      duracionDias: number
      duracionNoches: number | null
      precioPorPersona: Prisma.Decimal
      moneda: string
      capacidadMaxima: number | null
      fechaInicio: Date | null
      fechaFin: Date | null
      lugaresVisitados: Prisma.JsonValue | null
      requisitos: string | null
      incluye: string | null
      noIncluye: string | null
      estado: string
      esPersonalizable: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paqueteTuristico"]>
    composites: {}
  }

  type PaqueteTuristicoGetPayload<S extends boolean | null | undefined | PaqueteTuristicoDefaultArgs> = $Result.GetResult<Prisma.$PaqueteTuristicoPayload, S>

  type PaqueteTuristicoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaqueteTuristicoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaqueteTuristicoCountAggregateInputType | true
    }

  export interface PaqueteTuristicoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaqueteTuristico'], meta: { name: 'PaqueteTuristico' } }
    /**
     * Find zero or one PaqueteTuristico that matches the filter.
     * @param {PaqueteTuristicoFindUniqueArgs} args - Arguments to find a PaqueteTuristico
     * @example
     * // Get one PaqueteTuristico
     * const paqueteTuristico = await prisma.paqueteTuristico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaqueteTuristicoFindUniqueArgs>(args: SelectSubset<T, PaqueteTuristicoFindUniqueArgs<ExtArgs>>): Prisma__PaqueteTuristicoClient<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaqueteTuristico that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaqueteTuristicoFindUniqueOrThrowArgs} args - Arguments to find a PaqueteTuristico
     * @example
     * // Get one PaqueteTuristico
     * const paqueteTuristico = await prisma.paqueteTuristico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaqueteTuristicoFindUniqueOrThrowArgs>(args: SelectSubset<T, PaqueteTuristicoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaqueteTuristicoClient<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaqueteTuristico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoFindFirstArgs} args - Arguments to find a PaqueteTuristico
     * @example
     * // Get one PaqueteTuristico
     * const paqueteTuristico = await prisma.paqueteTuristico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaqueteTuristicoFindFirstArgs>(args?: SelectSubset<T, PaqueteTuristicoFindFirstArgs<ExtArgs>>): Prisma__PaqueteTuristicoClient<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaqueteTuristico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoFindFirstOrThrowArgs} args - Arguments to find a PaqueteTuristico
     * @example
     * // Get one PaqueteTuristico
     * const paqueteTuristico = await prisma.paqueteTuristico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaqueteTuristicoFindFirstOrThrowArgs>(args?: SelectSubset<T, PaqueteTuristicoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaqueteTuristicoClient<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaqueteTuristicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaqueteTuristicos
     * const paqueteTuristicos = await prisma.paqueteTuristico.findMany()
     * 
     * // Get first 10 PaqueteTuristicos
     * const paqueteTuristicos = await prisma.paqueteTuristico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paqueteTuristicoWithIdOnly = await prisma.paqueteTuristico.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaqueteTuristicoFindManyArgs>(args?: SelectSubset<T, PaqueteTuristicoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaqueteTuristico.
     * @param {PaqueteTuristicoCreateArgs} args - Arguments to create a PaqueteTuristico.
     * @example
     * // Create one PaqueteTuristico
     * const PaqueteTuristico = await prisma.paqueteTuristico.create({
     *   data: {
     *     // ... data to create a PaqueteTuristico
     *   }
     * })
     * 
     */
    create<T extends PaqueteTuristicoCreateArgs>(args: SelectSubset<T, PaqueteTuristicoCreateArgs<ExtArgs>>): Prisma__PaqueteTuristicoClient<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaqueteTuristicos.
     * @param {PaqueteTuristicoCreateManyArgs} args - Arguments to create many PaqueteTuristicos.
     * @example
     * // Create many PaqueteTuristicos
     * const paqueteTuristico = await prisma.paqueteTuristico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaqueteTuristicoCreateManyArgs>(args?: SelectSubset<T, PaqueteTuristicoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaqueteTuristicos and returns the data saved in the database.
     * @param {PaqueteTuristicoCreateManyAndReturnArgs} args - Arguments to create many PaqueteTuristicos.
     * @example
     * // Create many PaqueteTuristicos
     * const paqueteTuristico = await prisma.paqueteTuristico.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaqueteTuristicos and only return the `id`
     * const paqueteTuristicoWithIdOnly = await prisma.paqueteTuristico.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaqueteTuristicoCreateManyAndReturnArgs>(args?: SelectSubset<T, PaqueteTuristicoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaqueteTuristico.
     * @param {PaqueteTuristicoDeleteArgs} args - Arguments to delete one PaqueteTuristico.
     * @example
     * // Delete one PaqueteTuristico
     * const PaqueteTuristico = await prisma.paqueteTuristico.delete({
     *   where: {
     *     // ... filter to delete one PaqueteTuristico
     *   }
     * })
     * 
     */
    delete<T extends PaqueteTuristicoDeleteArgs>(args: SelectSubset<T, PaqueteTuristicoDeleteArgs<ExtArgs>>): Prisma__PaqueteTuristicoClient<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaqueteTuristico.
     * @param {PaqueteTuristicoUpdateArgs} args - Arguments to update one PaqueteTuristico.
     * @example
     * // Update one PaqueteTuristico
     * const paqueteTuristico = await prisma.paqueteTuristico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaqueteTuristicoUpdateArgs>(args: SelectSubset<T, PaqueteTuristicoUpdateArgs<ExtArgs>>): Prisma__PaqueteTuristicoClient<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaqueteTuristicos.
     * @param {PaqueteTuristicoDeleteManyArgs} args - Arguments to filter PaqueteTuristicos to delete.
     * @example
     * // Delete a few PaqueteTuristicos
     * const { count } = await prisma.paqueteTuristico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaqueteTuristicoDeleteManyArgs>(args?: SelectSubset<T, PaqueteTuristicoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaqueteTuristicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaqueteTuristicos
     * const paqueteTuristico = await prisma.paqueteTuristico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaqueteTuristicoUpdateManyArgs>(args: SelectSubset<T, PaqueteTuristicoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaqueteTuristicos and returns the data updated in the database.
     * @param {PaqueteTuristicoUpdateManyAndReturnArgs} args - Arguments to update many PaqueteTuristicos.
     * @example
     * // Update many PaqueteTuristicos
     * const paqueteTuristico = await prisma.paqueteTuristico.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaqueteTuristicos and only return the `id`
     * const paqueteTuristicoWithIdOnly = await prisma.paqueteTuristico.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaqueteTuristicoUpdateManyAndReturnArgs>(args: SelectSubset<T, PaqueteTuristicoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaqueteTuristico.
     * @param {PaqueteTuristicoUpsertArgs} args - Arguments to update or create a PaqueteTuristico.
     * @example
     * // Update or create a PaqueteTuristico
     * const paqueteTuristico = await prisma.paqueteTuristico.upsert({
     *   create: {
     *     // ... data to create a PaqueteTuristico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaqueteTuristico we want to update
     *   }
     * })
     */
    upsert<T extends PaqueteTuristicoUpsertArgs>(args: SelectSubset<T, PaqueteTuristicoUpsertArgs<ExtArgs>>): Prisma__PaqueteTuristicoClient<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaqueteTuristicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoCountArgs} args - Arguments to filter PaqueteTuristicos to count.
     * @example
     * // Count the number of PaqueteTuristicos
     * const count = await prisma.paqueteTuristico.count({
     *   where: {
     *     // ... the filter for the PaqueteTuristicos we want to count
     *   }
     * })
    **/
    count<T extends PaqueteTuristicoCountArgs>(
      args?: Subset<T, PaqueteTuristicoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaqueteTuristicoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaqueteTuristico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaqueteTuristicoAggregateArgs>(args: Subset<T, PaqueteTuristicoAggregateArgs>): Prisma.PrismaPromise<GetPaqueteTuristicoAggregateType<T>>

    /**
     * Group by PaqueteTuristico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaqueteTuristicoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaqueteTuristicoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaqueteTuristicoGroupByArgs['orderBy'] }
        : { orderBy?: PaqueteTuristicoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaqueteTuristicoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaqueteTuristicoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaqueteTuristico model
   */
  readonly fields: PaqueteTuristicoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaqueteTuristico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaqueteTuristicoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    disponibilidad<T extends PaqueteTuristico$disponibilidadArgs<ExtArgs> = {}>(args?: Subset<T, PaqueteTuristico$disponibilidadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisponibilidadPaquetePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emprendimiento<T extends PaqueteTuristico$emprendimientoArgs<ExtArgs> = {}>(args?: Subset<T, PaqueteTuristico$emprendimientoArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    servicios<T extends PaqueteTuristico$serviciosArgs<ExtArgs> = {}>(args?: Subset<T, PaqueteTuristico$serviciosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaqueteTuristicoServicioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaqueteTuristico model
   */
  interface PaqueteTuristicoFieldRefs {
    readonly id: FieldRef<"PaqueteTuristico", 'Int'>
    readonly emprendimientoId: FieldRef<"PaqueteTuristico", 'Int'>
    readonly nombre: FieldRef<"PaqueteTuristico", 'String'>
    readonly descripcion: FieldRef<"PaqueteTuristico", 'String'>
    readonly duracionDias: FieldRef<"PaqueteTuristico", 'Int'>
    readonly duracionNoches: FieldRef<"PaqueteTuristico", 'Int'>
    readonly precioPorPersona: FieldRef<"PaqueteTuristico", 'Decimal'>
    readonly moneda: FieldRef<"PaqueteTuristico", 'String'>
    readonly capacidadMaxima: FieldRef<"PaqueteTuristico", 'Int'>
    readonly fechaInicio: FieldRef<"PaqueteTuristico", 'DateTime'>
    readonly fechaFin: FieldRef<"PaqueteTuristico", 'DateTime'>
    readonly lugaresVisitados: FieldRef<"PaqueteTuristico", 'Json'>
    readonly requisitos: FieldRef<"PaqueteTuristico", 'String'>
    readonly incluye: FieldRef<"PaqueteTuristico", 'String'>
    readonly noIncluye: FieldRef<"PaqueteTuristico", 'String'>
    readonly estado: FieldRef<"PaqueteTuristico", 'String'>
    readonly esPersonalizable: FieldRef<"PaqueteTuristico", 'Boolean'>
    readonly createdAt: FieldRef<"PaqueteTuristico", 'DateTime'>
    readonly updatedAt: FieldRef<"PaqueteTuristico", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaqueteTuristico findUnique
   */
  export type PaqueteTuristicoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristico
     */
    select?: PaqueteTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristico
     */
    omit?: PaqueteTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTuristico to fetch.
     */
    where: PaqueteTuristicoWhereUniqueInput
  }

  /**
   * PaqueteTuristico findUniqueOrThrow
   */
  export type PaqueteTuristicoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristico
     */
    select?: PaqueteTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristico
     */
    omit?: PaqueteTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTuristico to fetch.
     */
    where: PaqueteTuristicoWhereUniqueInput
  }

  /**
   * PaqueteTuristico findFirst
   */
  export type PaqueteTuristicoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristico
     */
    select?: PaqueteTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristico
     */
    omit?: PaqueteTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTuristico to fetch.
     */
    where?: PaqueteTuristicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteTuristicos to fetch.
     */
    orderBy?: PaqueteTuristicoOrderByWithRelationInput | PaqueteTuristicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaqueteTuristicos.
     */
    cursor?: PaqueteTuristicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteTuristicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteTuristicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaqueteTuristicos.
     */
    distinct?: PaqueteTuristicoScalarFieldEnum | PaqueteTuristicoScalarFieldEnum[]
  }

  /**
   * PaqueteTuristico findFirstOrThrow
   */
  export type PaqueteTuristicoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristico
     */
    select?: PaqueteTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristico
     */
    omit?: PaqueteTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTuristico to fetch.
     */
    where?: PaqueteTuristicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteTuristicos to fetch.
     */
    orderBy?: PaqueteTuristicoOrderByWithRelationInput | PaqueteTuristicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaqueteTuristicos.
     */
    cursor?: PaqueteTuristicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteTuristicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteTuristicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaqueteTuristicos.
     */
    distinct?: PaqueteTuristicoScalarFieldEnum | PaqueteTuristicoScalarFieldEnum[]
  }

  /**
   * PaqueteTuristico findMany
   */
  export type PaqueteTuristicoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristico
     */
    select?: PaqueteTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristico
     */
    omit?: PaqueteTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoInclude<ExtArgs> | null
    /**
     * Filter, which PaqueteTuristicos to fetch.
     */
    where?: PaqueteTuristicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaqueteTuristicos to fetch.
     */
    orderBy?: PaqueteTuristicoOrderByWithRelationInput | PaqueteTuristicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaqueteTuristicos.
     */
    cursor?: PaqueteTuristicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaqueteTuristicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaqueteTuristicos.
     */
    skip?: number
    distinct?: PaqueteTuristicoScalarFieldEnum | PaqueteTuristicoScalarFieldEnum[]
  }

  /**
   * PaqueteTuristico create
   */
  export type PaqueteTuristicoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristico
     */
    select?: PaqueteTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristico
     */
    omit?: PaqueteTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoInclude<ExtArgs> | null
    /**
     * The data needed to create a PaqueteTuristico.
     */
    data: XOR<PaqueteTuristicoCreateInput, PaqueteTuristicoUncheckedCreateInput>
  }

  /**
   * PaqueteTuristico createMany
   */
  export type PaqueteTuristicoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaqueteTuristicos.
     */
    data: PaqueteTuristicoCreateManyInput | PaqueteTuristicoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaqueteTuristico createManyAndReturn
   */
  export type PaqueteTuristicoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristico
     */
    select?: PaqueteTuristicoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristico
     */
    omit?: PaqueteTuristicoOmit<ExtArgs> | null
    /**
     * The data used to create many PaqueteTuristicos.
     */
    data: PaqueteTuristicoCreateManyInput | PaqueteTuristicoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaqueteTuristico update
   */
  export type PaqueteTuristicoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristico
     */
    select?: PaqueteTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristico
     */
    omit?: PaqueteTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoInclude<ExtArgs> | null
    /**
     * The data needed to update a PaqueteTuristico.
     */
    data: XOR<PaqueteTuristicoUpdateInput, PaqueteTuristicoUncheckedUpdateInput>
    /**
     * Choose, which PaqueteTuristico to update.
     */
    where: PaqueteTuristicoWhereUniqueInput
  }

  /**
   * PaqueteTuristico updateMany
   */
  export type PaqueteTuristicoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaqueteTuristicos.
     */
    data: XOR<PaqueteTuristicoUpdateManyMutationInput, PaqueteTuristicoUncheckedUpdateManyInput>
    /**
     * Filter which PaqueteTuristicos to update
     */
    where?: PaqueteTuristicoWhereInput
    /**
     * Limit how many PaqueteTuristicos to update.
     */
    limit?: number
  }

  /**
   * PaqueteTuristico updateManyAndReturn
   */
  export type PaqueteTuristicoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristico
     */
    select?: PaqueteTuristicoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristico
     */
    omit?: PaqueteTuristicoOmit<ExtArgs> | null
    /**
     * The data used to update PaqueteTuristicos.
     */
    data: XOR<PaqueteTuristicoUpdateManyMutationInput, PaqueteTuristicoUncheckedUpdateManyInput>
    /**
     * Filter which PaqueteTuristicos to update
     */
    where?: PaqueteTuristicoWhereInput
    /**
     * Limit how many PaqueteTuristicos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaqueteTuristico upsert
   */
  export type PaqueteTuristicoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristico
     */
    select?: PaqueteTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristico
     */
    omit?: PaqueteTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoInclude<ExtArgs> | null
    /**
     * The filter to search for the PaqueteTuristico to update in case it exists.
     */
    where: PaqueteTuristicoWhereUniqueInput
    /**
     * In case the PaqueteTuristico found by the `where` argument doesn't exist, create a new PaqueteTuristico with this data.
     */
    create: XOR<PaqueteTuristicoCreateInput, PaqueteTuristicoUncheckedCreateInput>
    /**
     * In case the PaqueteTuristico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaqueteTuristicoUpdateInput, PaqueteTuristicoUncheckedUpdateInput>
  }

  /**
   * PaqueteTuristico delete
   */
  export type PaqueteTuristicoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristico
     */
    select?: PaqueteTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristico
     */
    omit?: PaqueteTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoInclude<ExtArgs> | null
    /**
     * Filter which PaqueteTuristico to delete.
     */
    where: PaqueteTuristicoWhereUniqueInput
  }

  /**
   * PaqueteTuristico deleteMany
   */
  export type PaqueteTuristicoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaqueteTuristicos to delete
     */
    where?: PaqueteTuristicoWhereInput
    /**
     * Limit how many PaqueteTuristicos to delete.
     */
    limit?: number
  }

  /**
   * PaqueteTuristico.disponibilidad
   */
  export type PaqueteTuristico$disponibilidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibilidadPaquete
     */
    select?: DisponibilidadPaqueteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisponibilidadPaquete
     */
    omit?: DisponibilidadPaqueteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibilidadPaqueteInclude<ExtArgs> | null
    where?: DisponibilidadPaqueteWhereInput
    orderBy?: DisponibilidadPaqueteOrderByWithRelationInput | DisponibilidadPaqueteOrderByWithRelationInput[]
    cursor?: DisponibilidadPaqueteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisponibilidadPaqueteScalarFieldEnum | DisponibilidadPaqueteScalarFieldEnum[]
  }

  /**
   * PaqueteTuristico.emprendimiento
   */
  export type PaqueteTuristico$emprendimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Emprendimiento
     */
    omit?: EmprendimientoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    where?: EmprendimientoWhereInput
  }

  /**
   * PaqueteTuristico.servicios
   */
  export type PaqueteTuristico$serviciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristicoServicio
     */
    select?: PaqueteTuristicoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristicoServicio
     */
    omit?: PaqueteTuristicoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoServicioInclude<ExtArgs> | null
    where?: PaqueteTuristicoServicioWhereInput
    orderBy?: PaqueteTuristicoServicioOrderByWithRelationInput | PaqueteTuristicoServicioOrderByWithRelationInput[]
    cursor?: PaqueteTuristicoServicioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaqueteTuristicoServicioScalarFieldEnum | PaqueteTuristicoServicioScalarFieldEnum[]
  }

  /**
   * PaqueteTuristico without action
   */
  export type PaqueteTuristicoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaqueteTuristico
     */
    select?: PaqueteTuristicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaqueteTuristico
     */
    omit?: PaqueteTuristicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaqueteTuristicoInclude<ExtArgs> | null
  }


  /**
   * Model DisponibilidadPaquete
   */

  export type AggregateDisponibilidadPaquete = {
    _count: DisponibilidadPaqueteCountAggregateOutputType | null
    _avg: DisponibilidadPaqueteAvgAggregateOutputType | null
    _sum: DisponibilidadPaqueteSumAggregateOutputType | null
    _min: DisponibilidadPaqueteMinAggregateOutputType | null
    _max: DisponibilidadPaqueteMaxAggregateOutputType | null
  }

  export type DisponibilidadPaqueteAvgAggregateOutputType = {
    id: number | null
    paqueteId: number | null
    cuposDisponibles: number | null
    precioEspecial: Decimal | null
  }

  export type DisponibilidadPaqueteSumAggregateOutputType = {
    id: number | null
    paqueteId: number | null
    cuposDisponibles: number | null
    precioEspecial: Decimal | null
  }

  export type DisponibilidadPaqueteMinAggregateOutputType = {
    id: number | null
    paqueteId: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    cuposDisponibles: number | null
    precioEspecial: Decimal | null
    notas: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisponibilidadPaqueteMaxAggregateOutputType = {
    id: number | null
    paqueteId: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    cuposDisponibles: number | null
    precioEspecial: Decimal | null
    notas: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisponibilidadPaqueteCountAggregateOutputType = {
    id: number
    paqueteId: number
    fechaInicio: number
    fechaFin: number
    cuposDisponibles: number
    precioEspecial: number
    notas: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DisponibilidadPaqueteAvgAggregateInputType = {
    id?: true
    paqueteId?: true
    cuposDisponibles?: true
    precioEspecial?: true
  }

  export type DisponibilidadPaqueteSumAggregateInputType = {
    id?: true
    paqueteId?: true
    cuposDisponibles?: true
    precioEspecial?: true
  }

  export type DisponibilidadPaqueteMinAggregateInputType = {
    id?: true
    paqueteId?: true
    fechaInicio?: true
    fechaFin?: true
    cuposDisponibles?: true
    precioEspecial?: true
    notas?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisponibilidadPaqueteMaxAggregateInputType = {
    id?: true
    paqueteId?: true
    fechaInicio?: true
    fechaFin?: true
    cuposDisponibles?: true
    precioEspecial?: true
    notas?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisponibilidadPaqueteCountAggregateInputType = {
    id?: true
    paqueteId?: true
    fechaInicio?: true
    fechaFin?: true
    cuposDisponibles?: true
    precioEspecial?: true
    notas?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DisponibilidadPaqueteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisponibilidadPaquete to aggregate.
     */
    where?: DisponibilidadPaqueteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibilidadPaquetes to fetch.
     */
    orderBy?: DisponibilidadPaqueteOrderByWithRelationInput | DisponibilidadPaqueteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisponibilidadPaqueteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibilidadPaquetes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibilidadPaquetes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisponibilidadPaquetes
    **/
    _count?: true | DisponibilidadPaqueteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DisponibilidadPaqueteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DisponibilidadPaqueteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisponibilidadPaqueteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisponibilidadPaqueteMaxAggregateInputType
  }

  export type GetDisponibilidadPaqueteAggregateType<T extends DisponibilidadPaqueteAggregateArgs> = {
        [P in keyof T & keyof AggregateDisponibilidadPaquete]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisponibilidadPaquete[P]>
      : GetScalarType<T[P], AggregateDisponibilidadPaquete[P]>
  }




  export type DisponibilidadPaqueteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisponibilidadPaqueteWhereInput
    orderBy?: DisponibilidadPaqueteOrderByWithAggregationInput | DisponibilidadPaqueteOrderByWithAggregationInput[]
    by: DisponibilidadPaqueteScalarFieldEnum[] | DisponibilidadPaqueteScalarFieldEnum
    having?: DisponibilidadPaqueteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisponibilidadPaqueteCountAggregateInputType | true
    _avg?: DisponibilidadPaqueteAvgAggregateInputType
    _sum?: DisponibilidadPaqueteSumAggregateInputType
    _min?: DisponibilidadPaqueteMinAggregateInputType
    _max?: DisponibilidadPaqueteMaxAggregateInputType
  }

  export type DisponibilidadPaqueteGroupByOutputType = {
    id: number
    paqueteId: number
    fechaInicio: Date
    fechaFin: Date
    cuposDisponibles: number
    precioEspecial: Decimal | null
    notas: string | null
    createdAt: Date
    updatedAt: Date
    _count: DisponibilidadPaqueteCountAggregateOutputType | null
    _avg: DisponibilidadPaqueteAvgAggregateOutputType | null
    _sum: DisponibilidadPaqueteSumAggregateOutputType | null
    _min: DisponibilidadPaqueteMinAggregateOutputType | null
    _max: DisponibilidadPaqueteMaxAggregateOutputType | null
  }

  type GetDisponibilidadPaqueteGroupByPayload<T extends DisponibilidadPaqueteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisponibilidadPaqueteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisponibilidadPaqueteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisponibilidadPaqueteGroupByOutputType[P]>
            : GetScalarType<T[P], DisponibilidadPaqueteGroupByOutputType[P]>
        }
      >
    >


  export type DisponibilidadPaqueteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paqueteId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    cuposDisponibles?: boolean
    precioEspecial?: boolean
    notas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paquete?: boolean | PaqueteTuristicoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disponibilidadPaquete"]>

  export type DisponibilidadPaqueteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paqueteId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    cuposDisponibles?: boolean
    precioEspecial?: boolean
    notas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paquete?: boolean | PaqueteTuristicoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disponibilidadPaquete"]>

  export type DisponibilidadPaqueteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paqueteId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    cuposDisponibles?: boolean
    precioEspecial?: boolean
    notas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paquete?: boolean | PaqueteTuristicoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disponibilidadPaquete"]>

  export type DisponibilidadPaqueteSelectScalar = {
    id?: boolean
    paqueteId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    cuposDisponibles?: boolean
    precioEspecial?: boolean
    notas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DisponibilidadPaqueteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paqueteId" | "fechaInicio" | "fechaFin" | "cuposDisponibles" | "precioEspecial" | "notas" | "createdAt" | "updatedAt", ExtArgs["result"]["disponibilidadPaquete"]>
  export type DisponibilidadPaqueteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paquete?: boolean | PaqueteTuristicoDefaultArgs<ExtArgs>
  }
  export type DisponibilidadPaqueteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paquete?: boolean | PaqueteTuristicoDefaultArgs<ExtArgs>
  }
  export type DisponibilidadPaqueteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paquete?: boolean | PaqueteTuristicoDefaultArgs<ExtArgs>
  }

  export type $DisponibilidadPaquetePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisponibilidadPaquete"
    objects: {
      paquete: Prisma.$PaqueteTuristicoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      paqueteId: number
      fechaInicio: Date
      fechaFin: Date
      cuposDisponibles: number
      precioEspecial: Prisma.Decimal | null
      notas: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["disponibilidadPaquete"]>
    composites: {}
  }

  type DisponibilidadPaqueteGetPayload<S extends boolean | null | undefined | DisponibilidadPaqueteDefaultArgs> = $Result.GetResult<Prisma.$DisponibilidadPaquetePayload, S>

  type DisponibilidadPaqueteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisponibilidadPaqueteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisponibilidadPaqueteCountAggregateInputType | true
    }

  export interface DisponibilidadPaqueteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisponibilidadPaquete'], meta: { name: 'DisponibilidadPaquete' } }
    /**
     * Find zero or one DisponibilidadPaquete that matches the filter.
     * @param {DisponibilidadPaqueteFindUniqueArgs} args - Arguments to find a DisponibilidadPaquete
     * @example
     * // Get one DisponibilidadPaquete
     * const disponibilidadPaquete = await prisma.disponibilidadPaquete.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisponibilidadPaqueteFindUniqueArgs>(args: SelectSubset<T, DisponibilidadPaqueteFindUniqueArgs<ExtArgs>>): Prisma__DisponibilidadPaqueteClient<$Result.GetResult<Prisma.$DisponibilidadPaquetePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisponibilidadPaquete that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisponibilidadPaqueteFindUniqueOrThrowArgs} args - Arguments to find a DisponibilidadPaquete
     * @example
     * // Get one DisponibilidadPaquete
     * const disponibilidadPaquete = await prisma.disponibilidadPaquete.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisponibilidadPaqueteFindUniqueOrThrowArgs>(args: SelectSubset<T, DisponibilidadPaqueteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisponibilidadPaqueteClient<$Result.GetResult<Prisma.$DisponibilidadPaquetePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisponibilidadPaquete that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadPaqueteFindFirstArgs} args - Arguments to find a DisponibilidadPaquete
     * @example
     * // Get one DisponibilidadPaquete
     * const disponibilidadPaquete = await prisma.disponibilidadPaquete.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisponibilidadPaqueteFindFirstArgs>(args?: SelectSubset<T, DisponibilidadPaqueteFindFirstArgs<ExtArgs>>): Prisma__DisponibilidadPaqueteClient<$Result.GetResult<Prisma.$DisponibilidadPaquetePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisponibilidadPaquete that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadPaqueteFindFirstOrThrowArgs} args - Arguments to find a DisponibilidadPaquete
     * @example
     * // Get one DisponibilidadPaquete
     * const disponibilidadPaquete = await prisma.disponibilidadPaquete.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisponibilidadPaqueteFindFirstOrThrowArgs>(args?: SelectSubset<T, DisponibilidadPaqueteFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisponibilidadPaqueteClient<$Result.GetResult<Prisma.$DisponibilidadPaquetePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisponibilidadPaquetes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadPaqueteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisponibilidadPaquetes
     * const disponibilidadPaquetes = await prisma.disponibilidadPaquete.findMany()
     * 
     * // Get first 10 DisponibilidadPaquetes
     * const disponibilidadPaquetes = await prisma.disponibilidadPaquete.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disponibilidadPaqueteWithIdOnly = await prisma.disponibilidadPaquete.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisponibilidadPaqueteFindManyArgs>(args?: SelectSubset<T, DisponibilidadPaqueteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisponibilidadPaquetePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisponibilidadPaquete.
     * @param {DisponibilidadPaqueteCreateArgs} args - Arguments to create a DisponibilidadPaquete.
     * @example
     * // Create one DisponibilidadPaquete
     * const DisponibilidadPaquete = await prisma.disponibilidadPaquete.create({
     *   data: {
     *     // ... data to create a DisponibilidadPaquete
     *   }
     * })
     * 
     */
    create<T extends DisponibilidadPaqueteCreateArgs>(args: SelectSubset<T, DisponibilidadPaqueteCreateArgs<ExtArgs>>): Prisma__DisponibilidadPaqueteClient<$Result.GetResult<Prisma.$DisponibilidadPaquetePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisponibilidadPaquetes.
     * @param {DisponibilidadPaqueteCreateManyArgs} args - Arguments to create many DisponibilidadPaquetes.
     * @example
     * // Create many DisponibilidadPaquetes
     * const disponibilidadPaquete = await prisma.disponibilidadPaquete.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisponibilidadPaqueteCreateManyArgs>(args?: SelectSubset<T, DisponibilidadPaqueteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisponibilidadPaquetes and returns the data saved in the database.
     * @param {DisponibilidadPaqueteCreateManyAndReturnArgs} args - Arguments to create many DisponibilidadPaquetes.
     * @example
     * // Create many DisponibilidadPaquetes
     * const disponibilidadPaquete = await prisma.disponibilidadPaquete.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisponibilidadPaquetes and only return the `id`
     * const disponibilidadPaqueteWithIdOnly = await prisma.disponibilidadPaquete.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisponibilidadPaqueteCreateManyAndReturnArgs>(args?: SelectSubset<T, DisponibilidadPaqueteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisponibilidadPaquetePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DisponibilidadPaquete.
     * @param {DisponibilidadPaqueteDeleteArgs} args - Arguments to delete one DisponibilidadPaquete.
     * @example
     * // Delete one DisponibilidadPaquete
     * const DisponibilidadPaquete = await prisma.disponibilidadPaquete.delete({
     *   where: {
     *     // ... filter to delete one DisponibilidadPaquete
     *   }
     * })
     * 
     */
    delete<T extends DisponibilidadPaqueteDeleteArgs>(args: SelectSubset<T, DisponibilidadPaqueteDeleteArgs<ExtArgs>>): Prisma__DisponibilidadPaqueteClient<$Result.GetResult<Prisma.$DisponibilidadPaquetePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisponibilidadPaquete.
     * @param {DisponibilidadPaqueteUpdateArgs} args - Arguments to update one DisponibilidadPaquete.
     * @example
     * // Update one DisponibilidadPaquete
     * const disponibilidadPaquete = await prisma.disponibilidadPaquete.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisponibilidadPaqueteUpdateArgs>(args: SelectSubset<T, DisponibilidadPaqueteUpdateArgs<ExtArgs>>): Prisma__DisponibilidadPaqueteClient<$Result.GetResult<Prisma.$DisponibilidadPaquetePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisponibilidadPaquetes.
     * @param {DisponibilidadPaqueteDeleteManyArgs} args - Arguments to filter DisponibilidadPaquetes to delete.
     * @example
     * // Delete a few DisponibilidadPaquetes
     * const { count } = await prisma.disponibilidadPaquete.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisponibilidadPaqueteDeleteManyArgs>(args?: SelectSubset<T, DisponibilidadPaqueteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisponibilidadPaquetes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadPaqueteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisponibilidadPaquetes
     * const disponibilidadPaquete = await prisma.disponibilidadPaquete.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisponibilidadPaqueteUpdateManyArgs>(args: SelectSubset<T, DisponibilidadPaqueteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisponibilidadPaquetes and returns the data updated in the database.
     * @param {DisponibilidadPaqueteUpdateManyAndReturnArgs} args - Arguments to update many DisponibilidadPaquetes.
     * @example
     * // Update many DisponibilidadPaquetes
     * const disponibilidadPaquete = await prisma.disponibilidadPaquete.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DisponibilidadPaquetes and only return the `id`
     * const disponibilidadPaqueteWithIdOnly = await prisma.disponibilidadPaquete.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisponibilidadPaqueteUpdateManyAndReturnArgs>(args: SelectSubset<T, DisponibilidadPaqueteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisponibilidadPaquetePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DisponibilidadPaquete.
     * @param {DisponibilidadPaqueteUpsertArgs} args - Arguments to update or create a DisponibilidadPaquete.
     * @example
     * // Update or create a DisponibilidadPaquete
     * const disponibilidadPaquete = await prisma.disponibilidadPaquete.upsert({
     *   create: {
     *     // ... data to create a DisponibilidadPaquete
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisponibilidadPaquete we want to update
     *   }
     * })
     */
    upsert<T extends DisponibilidadPaqueteUpsertArgs>(args: SelectSubset<T, DisponibilidadPaqueteUpsertArgs<ExtArgs>>): Prisma__DisponibilidadPaqueteClient<$Result.GetResult<Prisma.$DisponibilidadPaquetePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisponibilidadPaquetes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadPaqueteCountArgs} args - Arguments to filter DisponibilidadPaquetes to count.
     * @example
     * // Count the number of DisponibilidadPaquetes
     * const count = await prisma.disponibilidadPaquete.count({
     *   where: {
     *     // ... the filter for the DisponibilidadPaquetes we want to count
     *   }
     * })
    **/
    count<T extends DisponibilidadPaqueteCountArgs>(
      args?: Subset<T, DisponibilidadPaqueteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisponibilidadPaqueteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisponibilidadPaquete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadPaqueteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisponibilidadPaqueteAggregateArgs>(args: Subset<T, DisponibilidadPaqueteAggregateArgs>): Prisma.PrismaPromise<GetDisponibilidadPaqueteAggregateType<T>>

    /**
     * Group by DisponibilidadPaquete.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibilidadPaqueteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisponibilidadPaqueteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisponibilidadPaqueteGroupByArgs['orderBy'] }
        : { orderBy?: DisponibilidadPaqueteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisponibilidadPaqueteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisponibilidadPaqueteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisponibilidadPaquete model
   */
  readonly fields: DisponibilidadPaqueteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisponibilidadPaquete.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisponibilidadPaqueteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paquete<T extends PaqueteTuristicoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaqueteTuristicoDefaultArgs<ExtArgs>>): Prisma__PaqueteTuristicoClient<$Result.GetResult<Prisma.$PaqueteTuristicoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisponibilidadPaquete model
   */
  interface DisponibilidadPaqueteFieldRefs {
    readonly id: FieldRef<"DisponibilidadPaquete", 'Int'>
    readonly paqueteId: FieldRef<"DisponibilidadPaquete", 'Int'>
    readonly fechaInicio: FieldRef<"DisponibilidadPaquete", 'DateTime'>
    readonly fechaFin: FieldRef<"DisponibilidadPaquete", 'DateTime'>
    readonly cuposDisponibles: FieldRef<"DisponibilidadPaquete", 'Int'>
    readonly precioEspecial: FieldRef<"DisponibilidadPaquete", 'Decimal'>
    readonly notas: FieldRef<"DisponibilidadPaquete", 'String'>
    readonly createdAt: FieldRef<"DisponibilidadPaquete", 'DateTime'>
    readonly updatedAt: FieldRef<"DisponibilidadPaquete", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DisponibilidadPaquete findUnique
   */
  export type DisponibilidadPaqueteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibilidadPaquete
     */
    select?: DisponibilidadPaqueteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisponibilidadPaquete
     */
    omit?: DisponibilidadPaqueteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibilidadPaqueteInclude<ExtArgs> | null
    /**
     * Filter, which DisponibilidadPaquete to fetch.
     */
    where: DisponibilidadPaqueteWhereUniqueInput
  }

  /**
   * DisponibilidadPaquete findUniqueOrThrow
   */
  export type DisponibilidadPaqueteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibilidadPaquete
     */
    select?: DisponibilidadPaqueteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisponibilidadPaquete
     */
    omit?: DisponibilidadPaqueteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibilidadPaqueteInclude<ExtArgs> | null
    /**
     * Filter, which DisponibilidadPaquete to fetch.
     */
    where: DisponibilidadPaqueteWhereUniqueInput
  }

  /**
   * DisponibilidadPaquete findFirst
   */
  export type DisponibilidadPaqueteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibilidadPaquete
     */
    select?: DisponibilidadPaqueteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisponibilidadPaquete
     */
    omit?: DisponibilidadPaqueteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibilidadPaqueteInclude<ExtArgs> | null
    /**
     * Filter, which DisponibilidadPaquete to fetch.
     */
    where?: DisponibilidadPaqueteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibilidadPaquetes to fetch.
     */
    orderBy?: DisponibilidadPaqueteOrderByWithRelationInput | DisponibilidadPaqueteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisponibilidadPaquetes.
     */
    cursor?: DisponibilidadPaqueteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibilidadPaquetes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibilidadPaquetes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisponibilidadPaquetes.
     */
    distinct?: DisponibilidadPaqueteScalarFieldEnum | DisponibilidadPaqueteScalarFieldEnum[]
  }

  /**
   * DisponibilidadPaquete findFirstOrThrow
   */
  export type DisponibilidadPaqueteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibilidadPaquete
     */
    select?: DisponibilidadPaqueteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisponibilidadPaquete
     */
    omit?: DisponibilidadPaqueteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibilidadPaqueteInclude<ExtArgs> | null
    /**
     * Filter, which DisponibilidadPaquete to fetch.
     */
    where?: DisponibilidadPaqueteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibilidadPaquetes to fetch.
     */
    orderBy?: DisponibilidadPaqueteOrderByWithRelationInput | DisponibilidadPaqueteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisponibilidadPaquetes.
     */
    cursor?: DisponibilidadPaqueteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibilidadPaquetes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibilidadPaquetes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisponibilidadPaquetes.
     */
    distinct?: DisponibilidadPaqueteScalarFieldEnum | DisponibilidadPaqueteScalarFieldEnum[]
  }

  /**
   * DisponibilidadPaquete findMany
   */
  export type DisponibilidadPaqueteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibilidadPaquete
     */
    select?: DisponibilidadPaqueteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisponibilidadPaquete
     */
    omit?: DisponibilidadPaqueteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibilidadPaqueteInclude<ExtArgs> | null
    /**
     * Filter, which DisponibilidadPaquetes to fetch.
     */
    where?: DisponibilidadPaqueteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibilidadPaquetes to fetch.
     */
    orderBy?: DisponibilidadPaqueteOrderByWithRelationInput | DisponibilidadPaqueteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisponibilidadPaquetes.
     */
    cursor?: DisponibilidadPaqueteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibilidadPaquetes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibilidadPaquetes.
     */
    skip?: number
    distinct?: DisponibilidadPaqueteScalarFieldEnum | DisponibilidadPaqueteScalarFieldEnum[]
  }

  /**
   * DisponibilidadPaquete create
   */
  export type DisponibilidadPaqueteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibilidadPaquete
     */
    select?: DisponibilidadPaqueteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisponibilidadPaquete
     */
    omit?: DisponibilidadPaqueteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibilidadPaqueteInclude<ExtArgs> | null
    /**
     * The data needed to create a DisponibilidadPaquete.
     */
    data: XOR<DisponibilidadPaqueteCreateInput, DisponibilidadPaqueteUncheckedCreateInput>
  }

  /**
   * DisponibilidadPaquete createMany
   */
  export type DisponibilidadPaqueteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisponibilidadPaquetes.
     */
    data: DisponibilidadPaqueteCreateManyInput | DisponibilidadPaqueteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisponibilidadPaquete createManyAndReturn
   */
  export type DisponibilidadPaqueteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibilidadPaquete
     */
    select?: DisponibilidadPaqueteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisponibilidadPaquete
     */
    omit?: DisponibilidadPaqueteOmit<ExtArgs> | null
    /**
     * The data used to create many DisponibilidadPaquetes.
     */
    data: DisponibilidadPaqueteCreateManyInput | DisponibilidadPaqueteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibilidadPaqueteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisponibilidadPaquete update
   */
  export type DisponibilidadPaqueteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibilidadPaquete
     */
    select?: DisponibilidadPaqueteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisponibilidadPaquete
     */
    omit?: DisponibilidadPaqueteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibilidadPaqueteInclude<ExtArgs> | null
    /**
     * The data needed to update a DisponibilidadPaquete.
     */
    data: XOR<DisponibilidadPaqueteUpdateInput, DisponibilidadPaqueteUncheckedUpdateInput>
    /**
     * Choose, which DisponibilidadPaquete to update.
     */
    where: DisponibilidadPaqueteWhereUniqueInput
  }

  /**
   * DisponibilidadPaquete updateMany
   */
  export type DisponibilidadPaqueteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisponibilidadPaquetes.
     */
    data: XOR<DisponibilidadPaqueteUpdateManyMutationInput, DisponibilidadPaqueteUncheckedUpdateManyInput>
    /**
     * Filter which DisponibilidadPaquetes to update
     */
    where?: DisponibilidadPaqueteWhereInput
    /**
     * Limit how many DisponibilidadPaquetes to update.
     */
    limit?: number
  }

  /**
   * DisponibilidadPaquete updateManyAndReturn
   */
  export type DisponibilidadPaqueteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibilidadPaquete
     */
    select?: DisponibilidadPaqueteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisponibilidadPaquete
     */
    omit?: DisponibilidadPaqueteOmit<ExtArgs> | null
    /**
     * The data used to update DisponibilidadPaquetes.
     */
    data: XOR<DisponibilidadPaqueteUpdateManyMutationInput, DisponibilidadPaqueteUncheckedUpdateManyInput>
    /**
     * Filter which DisponibilidadPaquetes to update
     */
    where?: DisponibilidadPaqueteWhereInput
    /**
     * Limit how many DisponibilidadPaquetes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibilidadPaqueteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisponibilidadPaquete upsert
   */
  export type DisponibilidadPaqueteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibilidadPaquete
     */
    select?: DisponibilidadPaqueteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisponibilidadPaquete
     */
    omit?: DisponibilidadPaqueteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibilidadPaqueteInclude<ExtArgs> | null
    /**
     * The filter to search for the DisponibilidadPaquete to update in case it exists.
     */
    where: DisponibilidadPaqueteWhereUniqueInput
    /**
     * In case the DisponibilidadPaquete found by the `where` argument doesn't exist, create a new DisponibilidadPaquete with this data.
     */
    create: XOR<DisponibilidadPaqueteCreateInput, DisponibilidadPaqueteUncheckedCreateInput>
    /**
     * In case the DisponibilidadPaquete was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisponibilidadPaqueteUpdateInput, DisponibilidadPaqueteUncheckedUpdateInput>
  }

  /**
   * DisponibilidadPaquete delete
   */
  export type DisponibilidadPaqueteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibilidadPaquete
     */
    select?: DisponibilidadPaqueteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisponibilidadPaquete
     */
    omit?: DisponibilidadPaqueteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibilidadPaqueteInclude<ExtArgs> | null
    /**
     * Filter which DisponibilidadPaquete to delete.
     */
    where: DisponibilidadPaqueteWhereUniqueInput
  }

  /**
   * DisponibilidadPaquete deleteMany
   */
  export type DisponibilidadPaqueteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisponibilidadPaquetes to delete
     */
    where?: DisponibilidadPaqueteWhereInput
    /**
     * Limit how many DisponibilidadPaquetes to delete.
     */
    limit?: number
  }

  /**
   * DisponibilidadPaquete without action
   */
  export type DisponibilidadPaqueteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibilidadPaquete
     */
    select?: DisponibilidadPaqueteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisponibilidadPaquete
     */
    omit?: DisponibilidadPaqueteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibilidadPaqueteInclude<ExtArgs> | null
  }


  /**
   * Model TipoServicio
   */

  export type AggregateTipoServicio = {
    _count: TipoServicioCountAggregateOutputType | null
    _avg: TipoServicioAvgAggregateOutputType | null
    _sum: TipoServicioSumAggregateOutputType | null
    _min: TipoServicioMinAggregateOutputType | null
    _max: TipoServicioMaxAggregateOutputType | null
  }

  export type TipoServicioAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoServicioSumAggregateOutputType = {
    id: number | null
  }

  export type TipoServicioMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    imagenUrl: string | null
    requiereCupo: boolean | null
    createdAt: Date | null
  }

  export type TipoServicioMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    imagenUrl: string | null
    requiereCupo: boolean | null
    createdAt: Date | null
  }

  export type TipoServicioCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    imagenUrl: number
    requiereCupo: number
    createdAt: number
    _all: number
  }


  export type TipoServicioAvgAggregateInputType = {
    id?: true
  }

  export type TipoServicioSumAggregateInputType = {
    id?: true
  }

  export type TipoServicioMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    imagenUrl?: true
    requiereCupo?: true
    createdAt?: true
  }

  export type TipoServicioMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    imagenUrl?: true
    requiereCupo?: true
    createdAt?: true
  }

  export type TipoServicioCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    imagenUrl?: true
    requiereCupo?: true
    createdAt?: true
    _all?: true
  }

  export type TipoServicioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoServicio to aggregate.
     */
    where?: TipoServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoServicios to fetch.
     */
    orderBy?: TipoServicioOrderByWithRelationInput | TipoServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoServicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoServicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoServicios
    **/
    _count?: true | TipoServicioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoServicioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoServicioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoServicioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoServicioMaxAggregateInputType
  }

  export type GetTipoServicioAggregateType<T extends TipoServicioAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoServicio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoServicio[P]>
      : GetScalarType<T[P], AggregateTipoServicio[P]>
  }




  export type TipoServicioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoServicioWhereInput
    orderBy?: TipoServicioOrderByWithAggregationInput | TipoServicioOrderByWithAggregationInput[]
    by: TipoServicioScalarFieldEnum[] | TipoServicioScalarFieldEnum
    having?: TipoServicioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoServicioCountAggregateInputType | true
    _avg?: TipoServicioAvgAggregateInputType
    _sum?: TipoServicioSumAggregateInputType
    _min?: TipoServicioMinAggregateInputType
    _max?: TipoServicioMaxAggregateInputType
  }

  export type TipoServicioGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    imagenUrl: string
    requiereCupo: boolean
    createdAt: Date
    _count: TipoServicioCountAggregateOutputType | null
    _avg: TipoServicioAvgAggregateOutputType | null
    _sum: TipoServicioSumAggregateOutputType | null
    _min: TipoServicioMinAggregateOutputType | null
    _max: TipoServicioMaxAggregateOutputType | null
  }

  type GetTipoServicioGroupByPayload<T extends TipoServicioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoServicioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoServicioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoServicioGroupByOutputType[P]>
            : GetScalarType<T[P], TipoServicioGroupByOutputType[P]>
        }
      >
    >


  export type TipoServicioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    imagenUrl?: boolean
    requiereCupo?: boolean
    createdAt?: boolean
    servicios?: boolean | TipoServicio$serviciosArgs<ExtArgs>
    _count?: boolean | TipoServicioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoServicio"]>

  export type TipoServicioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    imagenUrl?: boolean
    requiereCupo?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tipoServicio"]>

  export type TipoServicioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    imagenUrl?: boolean
    requiereCupo?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["tipoServicio"]>

  export type TipoServicioSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    imagenUrl?: boolean
    requiereCupo?: boolean
    createdAt?: boolean
  }

  export type TipoServicioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "imagenUrl" | "requiereCupo" | "createdAt", ExtArgs["result"]["tipoServicio"]>
  export type TipoServicioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicios?: boolean | TipoServicio$serviciosArgs<ExtArgs>
    _count?: boolean | TipoServicioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipoServicioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TipoServicioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipoServicioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoServicio"
    objects: {
      servicios: Prisma.$ServicioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      imagenUrl: string
      requiereCupo: boolean
      createdAt: Date
    }, ExtArgs["result"]["tipoServicio"]>
    composites: {}
  }

  type TipoServicioGetPayload<S extends boolean | null | undefined | TipoServicioDefaultArgs> = $Result.GetResult<Prisma.$TipoServicioPayload, S>

  type TipoServicioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoServicioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoServicioCountAggregateInputType | true
    }

  export interface TipoServicioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoServicio'], meta: { name: 'TipoServicio' } }
    /**
     * Find zero or one TipoServicio that matches the filter.
     * @param {TipoServicioFindUniqueArgs} args - Arguments to find a TipoServicio
     * @example
     * // Get one TipoServicio
     * const tipoServicio = await prisma.tipoServicio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoServicioFindUniqueArgs>(args: SelectSubset<T, TipoServicioFindUniqueArgs<ExtArgs>>): Prisma__TipoServicioClient<$Result.GetResult<Prisma.$TipoServicioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoServicio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoServicioFindUniqueOrThrowArgs} args - Arguments to find a TipoServicio
     * @example
     * // Get one TipoServicio
     * const tipoServicio = await prisma.tipoServicio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoServicioFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoServicioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoServicioClient<$Result.GetResult<Prisma.$TipoServicioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoServicio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoServicioFindFirstArgs} args - Arguments to find a TipoServicio
     * @example
     * // Get one TipoServicio
     * const tipoServicio = await prisma.tipoServicio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoServicioFindFirstArgs>(args?: SelectSubset<T, TipoServicioFindFirstArgs<ExtArgs>>): Prisma__TipoServicioClient<$Result.GetResult<Prisma.$TipoServicioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoServicio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoServicioFindFirstOrThrowArgs} args - Arguments to find a TipoServicio
     * @example
     * // Get one TipoServicio
     * const tipoServicio = await prisma.tipoServicio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoServicioFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoServicioFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoServicioClient<$Result.GetResult<Prisma.$TipoServicioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoServicios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoServicioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoServicios
     * const tipoServicios = await prisma.tipoServicio.findMany()
     * 
     * // Get first 10 TipoServicios
     * const tipoServicios = await prisma.tipoServicio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoServicioWithIdOnly = await prisma.tipoServicio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoServicioFindManyArgs>(args?: SelectSubset<T, TipoServicioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoServicioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoServicio.
     * @param {TipoServicioCreateArgs} args - Arguments to create a TipoServicio.
     * @example
     * // Create one TipoServicio
     * const TipoServicio = await prisma.tipoServicio.create({
     *   data: {
     *     // ... data to create a TipoServicio
     *   }
     * })
     * 
     */
    create<T extends TipoServicioCreateArgs>(args: SelectSubset<T, TipoServicioCreateArgs<ExtArgs>>): Prisma__TipoServicioClient<$Result.GetResult<Prisma.$TipoServicioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoServicios.
     * @param {TipoServicioCreateManyArgs} args - Arguments to create many TipoServicios.
     * @example
     * // Create many TipoServicios
     * const tipoServicio = await prisma.tipoServicio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoServicioCreateManyArgs>(args?: SelectSubset<T, TipoServicioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoServicios and returns the data saved in the database.
     * @param {TipoServicioCreateManyAndReturnArgs} args - Arguments to create many TipoServicios.
     * @example
     * // Create many TipoServicios
     * const tipoServicio = await prisma.tipoServicio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoServicios and only return the `id`
     * const tipoServicioWithIdOnly = await prisma.tipoServicio.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoServicioCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoServicioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoServicioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoServicio.
     * @param {TipoServicioDeleteArgs} args - Arguments to delete one TipoServicio.
     * @example
     * // Delete one TipoServicio
     * const TipoServicio = await prisma.tipoServicio.delete({
     *   where: {
     *     // ... filter to delete one TipoServicio
     *   }
     * })
     * 
     */
    delete<T extends TipoServicioDeleteArgs>(args: SelectSubset<T, TipoServicioDeleteArgs<ExtArgs>>): Prisma__TipoServicioClient<$Result.GetResult<Prisma.$TipoServicioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoServicio.
     * @param {TipoServicioUpdateArgs} args - Arguments to update one TipoServicio.
     * @example
     * // Update one TipoServicio
     * const tipoServicio = await prisma.tipoServicio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoServicioUpdateArgs>(args: SelectSubset<T, TipoServicioUpdateArgs<ExtArgs>>): Prisma__TipoServicioClient<$Result.GetResult<Prisma.$TipoServicioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoServicios.
     * @param {TipoServicioDeleteManyArgs} args - Arguments to filter TipoServicios to delete.
     * @example
     * // Delete a few TipoServicios
     * const { count } = await prisma.tipoServicio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoServicioDeleteManyArgs>(args?: SelectSubset<T, TipoServicioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoServicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoServicioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoServicios
     * const tipoServicio = await prisma.tipoServicio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoServicioUpdateManyArgs>(args: SelectSubset<T, TipoServicioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoServicios and returns the data updated in the database.
     * @param {TipoServicioUpdateManyAndReturnArgs} args - Arguments to update many TipoServicios.
     * @example
     * // Update many TipoServicios
     * const tipoServicio = await prisma.tipoServicio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoServicios and only return the `id`
     * const tipoServicioWithIdOnly = await prisma.tipoServicio.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoServicioUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoServicioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoServicioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoServicio.
     * @param {TipoServicioUpsertArgs} args - Arguments to update or create a TipoServicio.
     * @example
     * // Update or create a TipoServicio
     * const tipoServicio = await prisma.tipoServicio.upsert({
     *   create: {
     *     // ... data to create a TipoServicio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoServicio we want to update
     *   }
     * })
     */
    upsert<T extends TipoServicioUpsertArgs>(args: SelectSubset<T, TipoServicioUpsertArgs<ExtArgs>>): Prisma__TipoServicioClient<$Result.GetResult<Prisma.$TipoServicioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoServicios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoServicioCountArgs} args - Arguments to filter TipoServicios to count.
     * @example
     * // Count the number of TipoServicios
     * const count = await prisma.tipoServicio.count({
     *   where: {
     *     // ... the filter for the TipoServicios we want to count
     *   }
     * })
    **/
    count<T extends TipoServicioCountArgs>(
      args?: Subset<T, TipoServicioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoServicioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoServicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoServicioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoServicioAggregateArgs>(args: Subset<T, TipoServicioAggregateArgs>): Prisma.PrismaPromise<GetTipoServicioAggregateType<T>>

    /**
     * Group by TipoServicio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoServicioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoServicioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoServicioGroupByArgs['orderBy'] }
        : { orderBy?: TipoServicioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoServicioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoServicioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoServicio model
   */
  readonly fields: TipoServicioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoServicio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoServicioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servicios<T extends TipoServicio$serviciosArgs<ExtArgs> = {}>(args?: Subset<T, TipoServicio$serviciosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoServicio model
   */
  interface TipoServicioFieldRefs {
    readonly id: FieldRef<"TipoServicio", 'Int'>
    readonly nombre: FieldRef<"TipoServicio", 'String'>
    readonly descripcion: FieldRef<"TipoServicio", 'String'>
    readonly imagenUrl: FieldRef<"TipoServicio", 'String'>
    readonly requiereCupo: FieldRef<"TipoServicio", 'Boolean'>
    readonly createdAt: FieldRef<"TipoServicio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TipoServicio findUnique
   */
  export type TipoServicioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoServicio
     */
    select?: TipoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoServicio
     */
    omit?: TipoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoServicioInclude<ExtArgs> | null
    /**
     * Filter, which TipoServicio to fetch.
     */
    where: TipoServicioWhereUniqueInput
  }

  /**
   * TipoServicio findUniqueOrThrow
   */
  export type TipoServicioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoServicio
     */
    select?: TipoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoServicio
     */
    omit?: TipoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoServicioInclude<ExtArgs> | null
    /**
     * Filter, which TipoServicio to fetch.
     */
    where: TipoServicioWhereUniqueInput
  }

  /**
   * TipoServicio findFirst
   */
  export type TipoServicioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoServicio
     */
    select?: TipoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoServicio
     */
    omit?: TipoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoServicioInclude<ExtArgs> | null
    /**
     * Filter, which TipoServicio to fetch.
     */
    where?: TipoServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoServicios to fetch.
     */
    orderBy?: TipoServicioOrderByWithRelationInput | TipoServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoServicios.
     */
    cursor?: TipoServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoServicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoServicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoServicios.
     */
    distinct?: TipoServicioScalarFieldEnum | TipoServicioScalarFieldEnum[]
  }

  /**
   * TipoServicio findFirstOrThrow
   */
  export type TipoServicioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoServicio
     */
    select?: TipoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoServicio
     */
    omit?: TipoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoServicioInclude<ExtArgs> | null
    /**
     * Filter, which TipoServicio to fetch.
     */
    where?: TipoServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoServicios to fetch.
     */
    orderBy?: TipoServicioOrderByWithRelationInput | TipoServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoServicios.
     */
    cursor?: TipoServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoServicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoServicios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoServicios.
     */
    distinct?: TipoServicioScalarFieldEnum | TipoServicioScalarFieldEnum[]
  }

  /**
   * TipoServicio findMany
   */
  export type TipoServicioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoServicio
     */
    select?: TipoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoServicio
     */
    omit?: TipoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoServicioInclude<ExtArgs> | null
    /**
     * Filter, which TipoServicios to fetch.
     */
    where?: TipoServicioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoServicios to fetch.
     */
    orderBy?: TipoServicioOrderByWithRelationInput | TipoServicioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoServicios.
     */
    cursor?: TipoServicioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoServicios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoServicios.
     */
    skip?: number
    distinct?: TipoServicioScalarFieldEnum | TipoServicioScalarFieldEnum[]
  }

  /**
   * TipoServicio create
   */
  export type TipoServicioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoServicio
     */
    select?: TipoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoServicio
     */
    omit?: TipoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoServicioInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoServicio.
     */
    data: XOR<TipoServicioCreateInput, TipoServicioUncheckedCreateInput>
  }

  /**
   * TipoServicio createMany
   */
  export type TipoServicioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoServicios.
     */
    data: TipoServicioCreateManyInput | TipoServicioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoServicio createManyAndReturn
   */
  export type TipoServicioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoServicio
     */
    select?: TipoServicioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoServicio
     */
    omit?: TipoServicioOmit<ExtArgs> | null
    /**
     * The data used to create many TipoServicios.
     */
    data: TipoServicioCreateManyInput | TipoServicioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoServicio update
   */
  export type TipoServicioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoServicio
     */
    select?: TipoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoServicio
     */
    omit?: TipoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoServicioInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoServicio.
     */
    data: XOR<TipoServicioUpdateInput, TipoServicioUncheckedUpdateInput>
    /**
     * Choose, which TipoServicio to update.
     */
    where: TipoServicioWhereUniqueInput
  }

  /**
   * TipoServicio updateMany
   */
  export type TipoServicioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoServicios.
     */
    data: XOR<TipoServicioUpdateManyMutationInput, TipoServicioUncheckedUpdateManyInput>
    /**
     * Filter which TipoServicios to update
     */
    where?: TipoServicioWhereInput
    /**
     * Limit how many TipoServicios to update.
     */
    limit?: number
  }

  /**
   * TipoServicio updateManyAndReturn
   */
  export type TipoServicioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoServicio
     */
    select?: TipoServicioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoServicio
     */
    omit?: TipoServicioOmit<ExtArgs> | null
    /**
     * The data used to update TipoServicios.
     */
    data: XOR<TipoServicioUpdateManyMutationInput, TipoServicioUncheckedUpdateManyInput>
    /**
     * Filter which TipoServicios to update
     */
    where?: TipoServicioWhereInput
    /**
     * Limit how many TipoServicios to update.
     */
    limit?: number
  }

  /**
   * TipoServicio upsert
   */
  export type TipoServicioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoServicio
     */
    select?: TipoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoServicio
     */
    omit?: TipoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoServicioInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoServicio to update in case it exists.
     */
    where: TipoServicioWhereUniqueInput
    /**
     * In case the TipoServicio found by the `where` argument doesn't exist, create a new TipoServicio with this data.
     */
    create: XOR<TipoServicioCreateInput, TipoServicioUncheckedCreateInput>
    /**
     * In case the TipoServicio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoServicioUpdateInput, TipoServicioUncheckedUpdateInput>
  }

  /**
   * TipoServicio delete
   */
  export type TipoServicioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoServicio
     */
    select?: TipoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoServicio
     */
    omit?: TipoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoServicioInclude<ExtArgs> | null
    /**
     * Filter which TipoServicio to delete.
     */
    where: TipoServicioWhereUniqueInput
  }

  /**
   * TipoServicio deleteMany
   */
  export type TipoServicioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoServicios to delete
     */
    where?: TipoServicioWhereInput
    /**
     * Limit how many TipoServicios to delete.
     */
    limit?: number
  }

  /**
   * TipoServicio.servicios
   */
  export type TipoServicio$serviciosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    where?: ServicioWhereInput
    orderBy?: ServicioOrderByWithRelationInput | ServicioOrderByWithRelationInput[]
    cursor?: ServicioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicioScalarFieldEnum | ServicioScalarFieldEnum[]
  }

  /**
   * TipoServicio without action
   */
  export type TipoServicioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoServicio
     */
    select?: TipoServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoServicio
     */
    omit?: TipoServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoServicioInclude<ExtArgs> | null
  }


  /**
   * Model ServicioDisponibilidad
   */

  export type AggregateServicioDisponibilidad = {
    _count: ServicioDisponibilidadCountAggregateOutputType | null
    _avg: ServicioDisponibilidadAvgAggregateOutputType | null
    _sum: ServicioDisponibilidadSumAggregateOutputType | null
    _min: ServicioDisponibilidadMinAggregateOutputType | null
    _max: ServicioDisponibilidadMaxAggregateOutputType | null
  }

  export type ServicioDisponibilidadAvgAggregateOutputType = {
    id: number | null
    servicioId: number | null
    cuposDisponibles: number | null
    precioEspecial: Decimal | null
  }

  export type ServicioDisponibilidadSumAggregateOutputType = {
    id: number | null
    servicioId: number | null
    cuposDisponibles: number | null
    precioEspecial: Decimal | null
  }

  export type ServicioDisponibilidadMinAggregateOutputType = {
    id: number | null
    servicioId: number | null
    fecha: Date | null
    cuposDisponibles: number | null
    precioEspecial: Decimal | null
  }

  export type ServicioDisponibilidadMaxAggregateOutputType = {
    id: number | null
    servicioId: number | null
    fecha: Date | null
    cuposDisponibles: number | null
    precioEspecial: Decimal | null
  }

  export type ServicioDisponibilidadCountAggregateOutputType = {
    id: number
    servicioId: number
    fecha: number
    cuposDisponibles: number
    precioEspecial: number
    _all: number
  }


  export type ServicioDisponibilidadAvgAggregateInputType = {
    id?: true
    servicioId?: true
    cuposDisponibles?: true
    precioEspecial?: true
  }

  export type ServicioDisponibilidadSumAggregateInputType = {
    id?: true
    servicioId?: true
    cuposDisponibles?: true
    precioEspecial?: true
  }

  export type ServicioDisponibilidadMinAggregateInputType = {
    id?: true
    servicioId?: true
    fecha?: true
    cuposDisponibles?: true
    precioEspecial?: true
  }

  export type ServicioDisponibilidadMaxAggregateInputType = {
    id?: true
    servicioId?: true
    fecha?: true
    cuposDisponibles?: true
    precioEspecial?: true
  }

  export type ServicioDisponibilidadCountAggregateInputType = {
    id?: true
    servicioId?: true
    fecha?: true
    cuposDisponibles?: true
    precioEspecial?: true
    _all?: true
  }

  export type ServicioDisponibilidadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicioDisponibilidad to aggregate.
     */
    where?: ServicioDisponibilidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicioDisponibilidads to fetch.
     */
    orderBy?: ServicioDisponibilidadOrderByWithRelationInput | ServicioDisponibilidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicioDisponibilidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicioDisponibilidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicioDisponibilidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicioDisponibilidads
    **/
    _count?: true | ServicioDisponibilidadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicioDisponibilidadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicioDisponibilidadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicioDisponibilidadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicioDisponibilidadMaxAggregateInputType
  }

  export type GetServicioDisponibilidadAggregateType<T extends ServicioDisponibilidadAggregateArgs> = {
        [P in keyof T & keyof AggregateServicioDisponibilidad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicioDisponibilidad[P]>
      : GetScalarType<T[P], AggregateServicioDisponibilidad[P]>
  }




  export type ServicioDisponibilidadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicioDisponibilidadWhereInput
    orderBy?: ServicioDisponibilidadOrderByWithAggregationInput | ServicioDisponibilidadOrderByWithAggregationInput[]
    by: ServicioDisponibilidadScalarFieldEnum[] | ServicioDisponibilidadScalarFieldEnum
    having?: ServicioDisponibilidadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicioDisponibilidadCountAggregateInputType | true
    _avg?: ServicioDisponibilidadAvgAggregateInputType
    _sum?: ServicioDisponibilidadSumAggregateInputType
    _min?: ServicioDisponibilidadMinAggregateInputType
    _max?: ServicioDisponibilidadMaxAggregateInputType
  }

  export type ServicioDisponibilidadGroupByOutputType = {
    id: number
    servicioId: number
    fecha: Date
    cuposDisponibles: number
    precioEspecial: Decimal | null
    _count: ServicioDisponibilidadCountAggregateOutputType | null
    _avg: ServicioDisponibilidadAvgAggregateOutputType | null
    _sum: ServicioDisponibilidadSumAggregateOutputType | null
    _min: ServicioDisponibilidadMinAggregateOutputType | null
    _max: ServicioDisponibilidadMaxAggregateOutputType | null
  }

  type GetServicioDisponibilidadGroupByPayload<T extends ServicioDisponibilidadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicioDisponibilidadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicioDisponibilidadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicioDisponibilidadGroupByOutputType[P]>
            : GetScalarType<T[P], ServicioDisponibilidadGroupByOutputType[P]>
        }
      >
    >


  export type ServicioDisponibilidadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicioId?: boolean
    fecha?: boolean
    cuposDisponibles?: boolean
    precioEspecial?: boolean
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicioDisponibilidad"]>

  export type ServicioDisponibilidadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicioId?: boolean
    fecha?: boolean
    cuposDisponibles?: boolean
    precioEspecial?: boolean
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicioDisponibilidad"]>

  export type ServicioDisponibilidadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    servicioId?: boolean
    fecha?: boolean
    cuposDisponibles?: boolean
    precioEspecial?: boolean
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicioDisponibilidad"]>

  export type ServicioDisponibilidadSelectScalar = {
    id?: boolean
    servicioId?: boolean
    fecha?: boolean
    cuposDisponibles?: boolean
    precioEspecial?: boolean
  }

  export type ServicioDisponibilidadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "servicioId" | "fecha" | "cuposDisponibles" | "precioEspecial", ExtArgs["result"]["servicioDisponibilidad"]>
  export type ServicioDisponibilidadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }
  export type ServicioDisponibilidadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }
  export type ServicioDisponibilidadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    servicio?: boolean | ServicioDefaultArgs<ExtArgs>
  }

  export type $ServicioDisponibilidadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicioDisponibilidad"
    objects: {
      servicio: Prisma.$ServicioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      servicioId: number
      fecha: Date
      cuposDisponibles: number
      precioEspecial: Prisma.Decimal | null
    }, ExtArgs["result"]["servicioDisponibilidad"]>
    composites: {}
  }

  type ServicioDisponibilidadGetPayload<S extends boolean | null | undefined | ServicioDisponibilidadDefaultArgs> = $Result.GetResult<Prisma.$ServicioDisponibilidadPayload, S>

  type ServicioDisponibilidadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicioDisponibilidadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicioDisponibilidadCountAggregateInputType | true
    }

  export interface ServicioDisponibilidadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicioDisponibilidad'], meta: { name: 'ServicioDisponibilidad' } }
    /**
     * Find zero or one ServicioDisponibilidad that matches the filter.
     * @param {ServicioDisponibilidadFindUniqueArgs} args - Arguments to find a ServicioDisponibilidad
     * @example
     * // Get one ServicioDisponibilidad
     * const servicioDisponibilidad = await prisma.servicioDisponibilidad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicioDisponibilidadFindUniqueArgs>(args: SelectSubset<T, ServicioDisponibilidadFindUniqueArgs<ExtArgs>>): Prisma__ServicioDisponibilidadClient<$Result.GetResult<Prisma.$ServicioDisponibilidadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServicioDisponibilidad that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicioDisponibilidadFindUniqueOrThrowArgs} args - Arguments to find a ServicioDisponibilidad
     * @example
     * // Get one ServicioDisponibilidad
     * const servicioDisponibilidad = await prisma.servicioDisponibilidad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicioDisponibilidadFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicioDisponibilidadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicioDisponibilidadClient<$Result.GetResult<Prisma.$ServicioDisponibilidadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicioDisponibilidad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioDisponibilidadFindFirstArgs} args - Arguments to find a ServicioDisponibilidad
     * @example
     * // Get one ServicioDisponibilidad
     * const servicioDisponibilidad = await prisma.servicioDisponibilidad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicioDisponibilidadFindFirstArgs>(args?: SelectSubset<T, ServicioDisponibilidadFindFirstArgs<ExtArgs>>): Prisma__ServicioDisponibilidadClient<$Result.GetResult<Prisma.$ServicioDisponibilidadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicioDisponibilidad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioDisponibilidadFindFirstOrThrowArgs} args - Arguments to find a ServicioDisponibilidad
     * @example
     * // Get one ServicioDisponibilidad
     * const servicioDisponibilidad = await prisma.servicioDisponibilidad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicioDisponibilidadFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicioDisponibilidadFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicioDisponibilidadClient<$Result.GetResult<Prisma.$ServicioDisponibilidadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServicioDisponibilidads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioDisponibilidadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicioDisponibilidads
     * const servicioDisponibilidads = await prisma.servicioDisponibilidad.findMany()
     * 
     * // Get first 10 ServicioDisponibilidads
     * const servicioDisponibilidads = await prisma.servicioDisponibilidad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicioDisponibilidadWithIdOnly = await prisma.servicioDisponibilidad.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicioDisponibilidadFindManyArgs>(args?: SelectSubset<T, ServicioDisponibilidadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioDisponibilidadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServicioDisponibilidad.
     * @param {ServicioDisponibilidadCreateArgs} args - Arguments to create a ServicioDisponibilidad.
     * @example
     * // Create one ServicioDisponibilidad
     * const ServicioDisponibilidad = await prisma.servicioDisponibilidad.create({
     *   data: {
     *     // ... data to create a ServicioDisponibilidad
     *   }
     * })
     * 
     */
    create<T extends ServicioDisponibilidadCreateArgs>(args: SelectSubset<T, ServicioDisponibilidadCreateArgs<ExtArgs>>): Prisma__ServicioDisponibilidadClient<$Result.GetResult<Prisma.$ServicioDisponibilidadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServicioDisponibilidads.
     * @param {ServicioDisponibilidadCreateManyArgs} args - Arguments to create many ServicioDisponibilidads.
     * @example
     * // Create many ServicioDisponibilidads
     * const servicioDisponibilidad = await prisma.servicioDisponibilidad.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicioDisponibilidadCreateManyArgs>(args?: SelectSubset<T, ServicioDisponibilidadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServicioDisponibilidads and returns the data saved in the database.
     * @param {ServicioDisponibilidadCreateManyAndReturnArgs} args - Arguments to create many ServicioDisponibilidads.
     * @example
     * // Create many ServicioDisponibilidads
     * const servicioDisponibilidad = await prisma.servicioDisponibilidad.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServicioDisponibilidads and only return the `id`
     * const servicioDisponibilidadWithIdOnly = await prisma.servicioDisponibilidad.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicioDisponibilidadCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicioDisponibilidadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioDisponibilidadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServicioDisponibilidad.
     * @param {ServicioDisponibilidadDeleteArgs} args - Arguments to delete one ServicioDisponibilidad.
     * @example
     * // Delete one ServicioDisponibilidad
     * const ServicioDisponibilidad = await prisma.servicioDisponibilidad.delete({
     *   where: {
     *     // ... filter to delete one ServicioDisponibilidad
     *   }
     * })
     * 
     */
    delete<T extends ServicioDisponibilidadDeleteArgs>(args: SelectSubset<T, ServicioDisponibilidadDeleteArgs<ExtArgs>>): Prisma__ServicioDisponibilidadClient<$Result.GetResult<Prisma.$ServicioDisponibilidadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServicioDisponibilidad.
     * @param {ServicioDisponibilidadUpdateArgs} args - Arguments to update one ServicioDisponibilidad.
     * @example
     * // Update one ServicioDisponibilidad
     * const servicioDisponibilidad = await prisma.servicioDisponibilidad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicioDisponibilidadUpdateArgs>(args: SelectSubset<T, ServicioDisponibilidadUpdateArgs<ExtArgs>>): Prisma__ServicioDisponibilidadClient<$Result.GetResult<Prisma.$ServicioDisponibilidadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServicioDisponibilidads.
     * @param {ServicioDisponibilidadDeleteManyArgs} args - Arguments to filter ServicioDisponibilidads to delete.
     * @example
     * // Delete a few ServicioDisponibilidads
     * const { count } = await prisma.servicioDisponibilidad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicioDisponibilidadDeleteManyArgs>(args?: SelectSubset<T, ServicioDisponibilidadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicioDisponibilidads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioDisponibilidadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicioDisponibilidads
     * const servicioDisponibilidad = await prisma.servicioDisponibilidad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicioDisponibilidadUpdateManyArgs>(args: SelectSubset<T, ServicioDisponibilidadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicioDisponibilidads and returns the data updated in the database.
     * @param {ServicioDisponibilidadUpdateManyAndReturnArgs} args - Arguments to update many ServicioDisponibilidads.
     * @example
     * // Update many ServicioDisponibilidads
     * const servicioDisponibilidad = await prisma.servicioDisponibilidad.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServicioDisponibilidads and only return the `id`
     * const servicioDisponibilidadWithIdOnly = await prisma.servicioDisponibilidad.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServicioDisponibilidadUpdateManyAndReturnArgs>(args: SelectSubset<T, ServicioDisponibilidadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicioDisponibilidadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServicioDisponibilidad.
     * @param {ServicioDisponibilidadUpsertArgs} args - Arguments to update or create a ServicioDisponibilidad.
     * @example
     * // Update or create a ServicioDisponibilidad
     * const servicioDisponibilidad = await prisma.servicioDisponibilidad.upsert({
     *   create: {
     *     // ... data to create a ServicioDisponibilidad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicioDisponibilidad we want to update
     *   }
     * })
     */
    upsert<T extends ServicioDisponibilidadUpsertArgs>(args: SelectSubset<T, ServicioDisponibilidadUpsertArgs<ExtArgs>>): Prisma__ServicioDisponibilidadClient<$Result.GetResult<Prisma.$ServicioDisponibilidadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServicioDisponibilidads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioDisponibilidadCountArgs} args - Arguments to filter ServicioDisponibilidads to count.
     * @example
     * // Count the number of ServicioDisponibilidads
     * const count = await prisma.servicioDisponibilidad.count({
     *   where: {
     *     // ... the filter for the ServicioDisponibilidads we want to count
     *   }
     * })
    **/
    count<T extends ServicioDisponibilidadCountArgs>(
      args?: Subset<T, ServicioDisponibilidadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicioDisponibilidadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicioDisponibilidad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioDisponibilidadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicioDisponibilidadAggregateArgs>(args: Subset<T, ServicioDisponibilidadAggregateArgs>): Prisma.PrismaPromise<GetServicioDisponibilidadAggregateType<T>>

    /**
     * Group by ServicioDisponibilidad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicioDisponibilidadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicioDisponibilidadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicioDisponibilidadGroupByArgs['orderBy'] }
        : { orderBy?: ServicioDisponibilidadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicioDisponibilidadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicioDisponibilidadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicioDisponibilidad model
   */
  readonly fields: ServicioDisponibilidadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicioDisponibilidad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicioDisponibilidadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    servicio<T extends ServicioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServicioDefaultArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicioDisponibilidad model
   */
  interface ServicioDisponibilidadFieldRefs {
    readonly id: FieldRef<"ServicioDisponibilidad", 'Int'>
    readonly servicioId: FieldRef<"ServicioDisponibilidad", 'Int'>
    readonly fecha: FieldRef<"ServicioDisponibilidad", 'DateTime'>
    readonly cuposDisponibles: FieldRef<"ServicioDisponibilidad", 'Int'>
    readonly precioEspecial: FieldRef<"ServicioDisponibilidad", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * ServicioDisponibilidad findUnique
   */
  export type ServicioDisponibilidadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioDisponibilidad
     */
    select?: ServicioDisponibilidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioDisponibilidad
     */
    omit?: ServicioDisponibilidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioDisponibilidadInclude<ExtArgs> | null
    /**
     * Filter, which ServicioDisponibilidad to fetch.
     */
    where: ServicioDisponibilidadWhereUniqueInput
  }

  /**
   * ServicioDisponibilidad findUniqueOrThrow
   */
  export type ServicioDisponibilidadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioDisponibilidad
     */
    select?: ServicioDisponibilidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioDisponibilidad
     */
    omit?: ServicioDisponibilidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioDisponibilidadInclude<ExtArgs> | null
    /**
     * Filter, which ServicioDisponibilidad to fetch.
     */
    where: ServicioDisponibilidadWhereUniqueInput
  }

  /**
   * ServicioDisponibilidad findFirst
   */
  export type ServicioDisponibilidadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioDisponibilidad
     */
    select?: ServicioDisponibilidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioDisponibilidad
     */
    omit?: ServicioDisponibilidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioDisponibilidadInclude<ExtArgs> | null
    /**
     * Filter, which ServicioDisponibilidad to fetch.
     */
    where?: ServicioDisponibilidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicioDisponibilidads to fetch.
     */
    orderBy?: ServicioDisponibilidadOrderByWithRelationInput | ServicioDisponibilidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicioDisponibilidads.
     */
    cursor?: ServicioDisponibilidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicioDisponibilidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicioDisponibilidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicioDisponibilidads.
     */
    distinct?: ServicioDisponibilidadScalarFieldEnum | ServicioDisponibilidadScalarFieldEnum[]
  }

  /**
   * ServicioDisponibilidad findFirstOrThrow
   */
  export type ServicioDisponibilidadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioDisponibilidad
     */
    select?: ServicioDisponibilidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioDisponibilidad
     */
    omit?: ServicioDisponibilidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioDisponibilidadInclude<ExtArgs> | null
    /**
     * Filter, which ServicioDisponibilidad to fetch.
     */
    where?: ServicioDisponibilidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicioDisponibilidads to fetch.
     */
    orderBy?: ServicioDisponibilidadOrderByWithRelationInput | ServicioDisponibilidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicioDisponibilidads.
     */
    cursor?: ServicioDisponibilidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicioDisponibilidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicioDisponibilidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicioDisponibilidads.
     */
    distinct?: ServicioDisponibilidadScalarFieldEnum | ServicioDisponibilidadScalarFieldEnum[]
  }

  /**
   * ServicioDisponibilidad findMany
   */
  export type ServicioDisponibilidadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioDisponibilidad
     */
    select?: ServicioDisponibilidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioDisponibilidad
     */
    omit?: ServicioDisponibilidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioDisponibilidadInclude<ExtArgs> | null
    /**
     * Filter, which ServicioDisponibilidads to fetch.
     */
    where?: ServicioDisponibilidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicioDisponibilidads to fetch.
     */
    orderBy?: ServicioDisponibilidadOrderByWithRelationInput | ServicioDisponibilidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicioDisponibilidads.
     */
    cursor?: ServicioDisponibilidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicioDisponibilidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicioDisponibilidads.
     */
    skip?: number
    distinct?: ServicioDisponibilidadScalarFieldEnum | ServicioDisponibilidadScalarFieldEnum[]
  }

  /**
   * ServicioDisponibilidad create
   */
  export type ServicioDisponibilidadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioDisponibilidad
     */
    select?: ServicioDisponibilidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioDisponibilidad
     */
    omit?: ServicioDisponibilidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioDisponibilidadInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicioDisponibilidad.
     */
    data: XOR<ServicioDisponibilidadCreateInput, ServicioDisponibilidadUncheckedCreateInput>
  }

  /**
   * ServicioDisponibilidad createMany
   */
  export type ServicioDisponibilidadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicioDisponibilidads.
     */
    data: ServicioDisponibilidadCreateManyInput | ServicioDisponibilidadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicioDisponibilidad createManyAndReturn
   */
  export type ServicioDisponibilidadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioDisponibilidad
     */
    select?: ServicioDisponibilidadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioDisponibilidad
     */
    omit?: ServicioDisponibilidadOmit<ExtArgs> | null
    /**
     * The data used to create many ServicioDisponibilidads.
     */
    data: ServicioDisponibilidadCreateManyInput | ServicioDisponibilidadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioDisponibilidadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicioDisponibilidad update
   */
  export type ServicioDisponibilidadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioDisponibilidad
     */
    select?: ServicioDisponibilidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioDisponibilidad
     */
    omit?: ServicioDisponibilidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioDisponibilidadInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicioDisponibilidad.
     */
    data: XOR<ServicioDisponibilidadUpdateInput, ServicioDisponibilidadUncheckedUpdateInput>
    /**
     * Choose, which ServicioDisponibilidad to update.
     */
    where: ServicioDisponibilidadWhereUniqueInput
  }

  /**
   * ServicioDisponibilidad updateMany
   */
  export type ServicioDisponibilidadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicioDisponibilidads.
     */
    data: XOR<ServicioDisponibilidadUpdateManyMutationInput, ServicioDisponibilidadUncheckedUpdateManyInput>
    /**
     * Filter which ServicioDisponibilidads to update
     */
    where?: ServicioDisponibilidadWhereInput
    /**
     * Limit how many ServicioDisponibilidads to update.
     */
    limit?: number
  }

  /**
   * ServicioDisponibilidad updateManyAndReturn
   */
  export type ServicioDisponibilidadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioDisponibilidad
     */
    select?: ServicioDisponibilidadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioDisponibilidad
     */
    omit?: ServicioDisponibilidadOmit<ExtArgs> | null
    /**
     * The data used to update ServicioDisponibilidads.
     */
    data: XOR<ServicioDisponibilidadUpdateManyMutationInput, ServicioDisponibilidadUncheckedUpdateManyInput>
    /**
     * Filter which ServicioDisponibilidads to update
     */
    where?: ServicioDisponibilidadWhereInput
    /**
     * Limit how many ServicioDisponibilidads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioDisponibilidadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicioDisponibilidad upsert
   */
  export type ServicioDisponibilidadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioDisponibilidad
     */
    select?: ServicioDisponibilidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioDisponibilidad
     */
    omit?: ServicioDisponibilidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioDisponibilidadInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicioDisponibilidad to update in case it exists.
     */
    where: ServicioDisponibilidadWhereUniqueInput
    /**
     * In case the ServicioDisponibilidad found by the `where` argument doesn't exist, create a new ServicioDisponibilidad with this data.
     */
    create: XOR<ServicioDisponibilidadCreateInput, ServicioDisponibilidadUncheckedCreateInput>
    /**
     * In case the ServicioDisponibilidad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicioDisponibilidadUpdateInput, ServicioDisponibilidadUncheckedUpdateInput>
  }

  /**
   * ServicioDisponibilidad delete
   */
  export type ServicioDisponibilidadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioDisponibilidad
     */
    select?: ServicioDisponibilidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioDisponibilidad
     */
    omit?: ServicioDisponibilidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioDisponibilidadInclude<ExtArgs> | null
    /**
     * Filter which ServicioDisponibilidad to delete.
     */
    where: ServicioDisponibilidadWhereUniqueInput
  }

  /**
   * ServicioDisponibilidad deleteMany
   */
  export type ServicioDisponibilidadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicioDisponibilidads to delete
     */
    where?: ServicioDisponibilidadWhereInput
    /**
     * Limit how many ServicioDisponibilidads to delete.
     */
    limit?: number
  }

  /**
   * ServicioDisponibilidad without action
   */
  export type ServicioDisponibilidadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicioDisponibilidad
     */
    select?: ServicioDisponibilidadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicioDisponibilidad
     */
    omit?: ServicioDisponibilidadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioDisponibilidadInclude<ExtArgs> | null
  }


  /**
   * Model Resena
   */

  export type AggregateResena = {
    _count: ResenaCountAggregateOutputType | null
    _avg: ResenaAvgAggregateOutputType | null
    _sum: ResenaSumAggregateOutputType | null
    _min: ResenaMinAggregateOutputType | null
    _max: ResenaMaxAggregateOutputType | null
  }

  export type ResenaAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    calificacion: number | null
  }

  export type ResenaSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    calificacion: number | null
  }

  export type ResenaMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    tipoObjeto: string | null
    calificacion: number | null
    comentario: string | null
    fechaExperiencia: Date | null
    respuestaOwner: string | null
    fechaRespuesta: Date | null
    estado: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResenaMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    tipoObjeto: string | null
    calificacion: number | null
    comentario: string | null
    fechaExperiencia: Date | null
    respuestaOwner: string | null
    fechaRespuesta: Date | null
    estado: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResenaCountAggregateOutputType = {
    id: number
    usuarioId: number
    tipoObjeto: number
    calificacion: number
    comentario: number
    fechaExperiencia: number
    respuestaOwner: number
    fechaRespuesta: number
    estado: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResenaAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    calificacion?: true
  }

  export type ResenaSumAggregateInputType = {
    id?: true
    usuarioId?: true
    calificacion?: true
  }

  export type ResenaMinAggregateInputType = {
    id?: true
    usuarioId?: true
    tipoObjeto?: true
    calificacion?: true
    comentario?: true
    fechaExperiencia?: true
    respuestaOwner?: true
    fechaRespuesta?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResenaMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    tipoObjeto?: true
    calificacion?: true
    comentario?: true
    fechaExperiencia?: true
    respuestaOwner?: true
    fechaRespuesta?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResenaCountAggregateInputType = {
    id?: true
    usuarioId?: true
    tipoObjeto?: true
    calificacion?: true
    comentario?: true
    fechaExperiencia?: true
    respuestaOwner?: true
    fechaRespuesta?: true
    estado?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResenaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resena to aggregate.
     */
    where?: ResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resenas
    **/
    _count?: true | ResenaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResenaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResenaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResenaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResenaMaxAggregateInputType
  }

  export type GetResenaAggregateType<T extends ResenaAggregateArgs> = {
        [P in keyof T & keyof AggregateResena]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResena[P]>
      : GetScalarType<T[P], AggregateResena[P]>
  }




  export type ResenaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResenaWhereInput
    orderBy?: ResenaOrderByWithAggregationInput | ResenaOrderByWithAggregationInput[]
    by: ResenaScalarFieldEnum[] | ResenaScalarFieldEnum
    having?: ResenaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResenaCountAggregateInputType | true
    _avg?: ResenaAvgAggregateInputType
    _sum?: ResenaSumAggregateInputType
    _min?: ResenaMinAggregateInputType
    _max?: ResenaMaxAggregateInputType
  }

  export type ResenaGroupByOutputType = {
    id: number
    usuarioId: number
    tipoObjeto: string
    calificacion: number
    comentario: string | null
    fechaExperiencia: Date | null
    respuestaOwner: string | null
    fechaRespuesta: Date | null
    estado: string
    createdAt: Date
    updatedAt: Date
    _count: ResenaCountAggregateOutputType | null
    _avg: ResenaAvgAggregateOutputType | null
    _sum: ResenaSumAggregateOutputType | null
    _min: ResenaMinAggregateOutputType | null
    _max: ResenaMaxAggregateOutputType | null
  }

  type GetResenaGroupByPayload<T extends ResenaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResenaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResenaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResenaGroupByOutputType[P]>
            : GetScalarType<T[P], ResenaGroupByOutputType[P]>
        }
      >
    >


  export type ResenaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    tipoObjeto?: boolean
    calificacion?: boolean
    comentario?: boolean
    fechaExperiencia?: boolean
    respuestaOwner?: boolean
    fechaRespuesta?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resena"]>

  export type ResenaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    tipoObjeto?: boolean
    calificacion?: boolean
    comentario?: boolean
    fechaExperiencia?: boolean
    respuestaOwner?: boolean
    fechaRespuesta?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resena"]>

  export type ResenaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    tipoObjeto?: boolean
    calificacion?: boolean
    comentario?: boolean
    fechaExperiencia?: boolean
    respuestaOwner?: boolean
    fechaRespuesta?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resena"]>

  export type ResenaSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    tipoObjeto?: boolean
    calificacion?: boolean
    comentario?: boolean
    fechaExperiencia?: boolean
    respuestaOwner?: boolean
    fechaRespuesta?: boolean
    estado?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResenaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "tipoObjeto" | "calificacion" | "comentario" | "fechaExperiencia" | "respuestaOwner" | "fechaRespuesta" | "estado" | "createdAt" | "updatedAt", ExtArgs["result"]["resena"]>
  export type ResenaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ResenaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type ResenaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ResenaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resena"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      tipoObjeto: string
      calificacion: number
      comentario: string | null
      fechaExperiencia: Date | null
      respuestaOwner: string | null
      fechaRespuesta: Date | null
      estado: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resena"]>
    composites: {}
  }

  type ResenaGetPayload<S extends boolean | null | undefined | ResenaDefaultArgs> = $Result.GetResult<Prisma.$ResenaPayload, S>

  type ResenaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResenaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResenaCountAggregateInputType | true
    }

  export interface ResenaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resena'], meta: { name: 'Resena' } }
    /**
     * Find zero or one Resena that matches the filter.
     * @param {ResenaFindUniqueArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResenaFindUniqueArgs>(args: SelectSubset<T, ResenaFindUniqueArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resena that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResenaFindUniqueOrThrowArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResenaFindUniqueOrThrowArgs>(args: SelectSubset<T, ResenaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resena that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaFindFirstArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResenaFindFirstArgs>(args?: SelectSubset<T, ResenaFindFirstArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resena that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaFindFirstOrThrowArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResenaFindFirstOrThrowArgs>(args?: SelectSubset<T, ResenaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resenas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resenas
     * const resenas = await prisma.resena.findMany()
     * 
     * // Get first 10 Resenas
     * const resenas = await prisma.resena.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resenaWithIdOnly = await prisma.resena.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResenaFindManyArgs>(args?: SelectSubset<T, ResenaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resena.
     * @param {ResenaCreateArgs} args - Arguments to create a Resena.
     * @example
     * // Create one Resena
     * const Resena = await prisma.resena.create({
     *   data: {
     *     // ... data to create a Resena
     *   }
     * })
     * 
     */
    create<T extends ResenaCreateArgs>(args: SelectSubset<T, ResenaCreateArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resenas.
     * @param {ResenaCreateManyArgs} args - Arguments to create many Resenas.
     * @example
     * // Create many Resenas
     * const resena = await prisma.resena.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResenaCreateManyArgs>(args?: SelectSubset<T, ResenaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resenas and returns the data saved in the database.
     * @param {ResenaCreateManyAndReturnArgs} args - Arguments to create many Resenas.
     * @example
     * // Create many Resenas
     * const resena = await prisma.resena.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resenas and only return the `id`
     * const resenaWithIdOnly = await prisma.resena.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResenaCreateManyAndReturnArgs>(args?: SelectSubset<T, ResenaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resena.
     * @param {ResenaDeleteArgs} args - Arguments to delete one Resena.
     * @example
     * // Delete one Resena
     * const Resena = await prisma.resena.delete({
     *   where: {
     *     // ... filter to delete one Resena
     *   }
     * })
     * 
     */
    delete<T extends ResenaDeleteArgs>(args: SelectSubset<T, ResenaDeleteArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resena.
     * @param {ResenaUpdateArgs} args - Arguments to update one Resena.
     * @example
     * // Update one Resena
     * const resena = await prisma.resena.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResenaUpdateArgs>(args: SelectSubset<T, ResenaUpdateArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resenas.
     * @param {ResenaDeleteManyArgs} args - Arguments to filter Resenas to delete.
     * @example
     * // Delete a few Resenas
     * const { count } = await prisma.resena.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResenaDeleteManyArgs>(args?: SelectSubset<T, ResenaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resenas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resenas
     * const resena = await prisma.resena.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResenaUpdateManyArgs>(args: SelectSubset<T, ResenaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resenas and returns the data updated in the database.
     * @param {ResenaUpdateManyAndReturnArgs} args - Arguments to update many Resenas.
     * @example
     * // Update many Resenas
     * const resena = await prisma.resena.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resenas and only return the `id`
     * const resenaWithIdOnly = await prisma.resena.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResenaUpdateManyAndReturnArgs>(args: SelectSubset<T, ResenaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resena.
     * @param {ResenaUpsertArgs} args - Arguments to update or create a Resena.
     * @example
     * // Update or create a Resena
     * const resena = await prisma.resena.upsert({
     *   create: {
     *     // ... data to create a Resena
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resena we want to update
     *   }
     * })
     */
    upsert<T extends ResenaUpsertArgs>(args: SelectSubset<T, ResenaUpsertArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resenas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaCountArgs} args - Arguments to filter Resenas to count.
     * @example
     * // Count the number of Resenas
     * const count = await prisma.resena.count({
     *   where: {
     *     // ... the filter for the Resenas we want to count
     *   }
     * })
    **/
    count<T extends ResenaCountArgs>(
      args?: Subset<T, ResenaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResenaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resena.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResenaAggregateArgs>(args: Subset<T, ResenaAggregateArgs>): Prisma.PrismaPromise<GetResenaAggregateType<T>>

    /**
     * Group by Resena.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResenaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResenaGroupByArgs['orderBy'] }
        : { orderBy?: ResenaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResenaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResenaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resena model
   */
  readonly fields: ResenaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resena.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResenaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resena model
   */
  interface ResenaFieldRefs {
    readonly id: FieldRef<"Resena", 'Int'>
    readonly usuarioId: FieldRef<"Resena", 'Int'>
    readonly tipoObjeto: FieldRef<"Resena", 'String'>
    readonly calificacion: FieldRef<"Resena", 'Int'>
    readonly comentario: FieldRef<"Resena", 'String'>
    readonly fechaExperiencia: FieldRef<"Resena", 'DateTime'>
    readonly respuestaOwner: FieldRef<"Resena", 'String'>
    readonly fechaRespuesta: FieldRef<"Resena", 'DateTime'>
    readonly estado: FieldRef<"Resena", 'String'>
    readonly createdAt: FieldRef<"Resena", 'DateTime'>
    readonly updatedAt: FieldRef<"Resena", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resena findUnique
   */
  export type ResenaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resena to fetch.
     */
    where: ResenaWhereUniqueInput
  }

  /**
   * Resena findUniqueOrThrow
   */
  export type ResenaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resena to fetch.
     */
    where: ResenaWhereUniqueInput
  }

  /**
   * Resena findFirst
   */
  export type ResenaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resena to fetch.
     */
    where?: ResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resenas.
     */
    cursor?: ResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resenas.
     */
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Resena findFirstOrThrow
   */
  export type ResenaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resena to fetch.
     */
    where?: ResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resenas.
     */
    cursor?: ResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resenas.
     */
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Resena findMany
   */
  export type ResenaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resenas to fetch.
     */
    where?: ResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resenas.
     */
    cursor?: ResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resenas.
     */
    skip?: number
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Resena create
   */
  export type ResenaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * The data needed to create a Resena.
     */
    data: XOR<ResenaCreateInput, ResenaUncheckedCreateInput>
  }

  /**
   * Resena createMany
   */
  export type ResenaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resenas.
     */
    data: ResenaCreateManyInput | ResenaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resena createManyAndReturn
   */
  export type ResenaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * The data used to create many Resenas.
     */
    data: ResenaCreateManyInput | ResenaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resena update
   */
  export type ResenaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * The data needed to update a Resena.
     */
    data: XOR<ResenaUpdateInput, ResenaUncheckedUpdateInput>
    /**
     * Choose, which Resena to update.
     */
    where: ResenaWhereUniqueInput
  }

  /**
   * Resena updateMany
   */
  export type ResenaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resenas.
     */
    data: XOR<ResenaUpdateManyMutationInput, ResenaUncheckedUpdateManyInput>
    /**
     * Filter which Resenas to update
     */
    where?: ResenaWhereInput
    /**
     * Limit how many Resenas to update.
     */
    limit?: number
  }

  /**
   * Resena updateManyAndReturn
   */
  export type ResenaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * The data used to update Resenas.
     */
    data: XOR<ResenaUpdateManyMutationInput, ResenaUncheckedUpdateManyInput>
    /**
     * Filter which Resenas to update
     */
    where?: ResenaWhereInput
    /**
     * Limit how many Resenas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resena upsert
   */
  export type ResenaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * The filter to search for the Resena to update in case it exists.
     */
    where: ResenaWhereUniqueInput
    /**
     * In case the Resena found by the `where` argument doesn't exist, create a new Resena with this data.
     */
    create: XOR<ResenaCreateInput, ResenaUncheckedCreateInput>
    /**
     * In case the Resena was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResenaUpdateInput, ResenaUncheckedUpdateInput>
  }

  /**
   * Resena delete
   */
  export type ResenaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter which Resena to delete.
     */
    where: ResenaWhereUniqueInput
  }

  /**
   * Resena deleteMany
   */
  export type ResenaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resenas to delete
     */
    where?: ResenaWhereInput
    /**
     * Limit how many Resenas to delete.
     */
    limit?: number
  }

  /**
   * Resena without action
   */
  export type ResenaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resena
     */
    omit?: ResenaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
  }


  /**
   * Model Favorito
   */

  export type AggregateFavorito = {
    _count: FavoritoCountAggregateOutputType | null
    _avg: FavoritoAvgAggregateOutputType | null
    _sum: FavoritoSumAggregateOutputType | null
    _min: FavoritoMinAggregateOutputType | null
    _max: FavoritoMaxAggregateOutputType | null
  }

  export type FavoritoAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    emprendimientoId: number | null
  }

  export type FavoritoSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    emprendimientoId: number | null
  }

  export type FavoritoMinAggregateOutputType = {
    id: number | null
    estado: string | null
    usuarioId: number | null
    emprendimientoId: number | null
    createdAt: Date | null
  }

  export type FavoritoMaxAggregateOutputType = {
    id: number | null
    estado: string | null
    usuarioId: number | null
    emprendimientoId: number | null
    createdAt: Date | null
  }

  export type FavoritoCountAggregateOutputType = {
    id: number
    estado: number
    usuarioId: number
    emprendimientoId: number
    createdAt: number
    _all: number
  }


  export type FavoritoAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    emprendimientoId?: true
  }

  export type FavoritoSumAggregateInputType = {
    id?: true
    usuarioId?: true
    emprendimientoId?: true
  }

  export type FavoritoMinAggregateInputType = {
    id?: true
    estado?: true
    usuarioId?: true
    emprendimientoId?: true
    createdAt?: true
  }

  export type FavoritoMaxAggregateInputType = {
    id?: true
    estado?: true
    usuarioId?: true
    emprendimientoId?: true
    createdAt?: true
  }

  export type FavoritoCountAggregateInputType = {
    id?: true
    estado?: true
    usuarioId?: true
    emprendimientoId?: true
    createdAt?: true
    _all?: true
  }

  export type FavoritoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorito to aggregate.
     */
    where?: FavoritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favoritos to fetch.
     */
    orderBy?: FavoritoOrderByWithRelationInput | FavoritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favoritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favoritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favoritos
    **/
    _count?: true | FavoritoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FavoritoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FavoritoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoritoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoritoMaxAggregateInputType
  }

  export type GetFavoritoAggregateType<T extends FavoritoAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorito[P]>
      : GetScalarType<T[P], AggregateFavorito[P]>
  }




  export type FavoritoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoritoWhereInput
    orderBy?: FavoritoOrderByWithAggregationInput | FavoritoOrderByWithAggregationInput[]
    by: FavoritoScalarFieldEnum[] | FavoritoScalarFieldEnum
    having?: FavoritoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoritoCountAggregateInputType | true
    _avg?: FavoritoAvgAggregateInputType
    _sum?: FavoritoSumAggregateInputType
    _min?: FavoritoMinAggregateInputType
    _max?: FavoritoMaxAggregateInputType
  }

  export type FavoritoGroupByOutputType = {
    id: number
    estado: string
    usuarioId: number
    emprendimientoId: number
    createdAt: Date
    _count: FavoritoCountAggregateOutputType | null
    _avg: FavoritoAvgAggregateOutputType | null
    _sum: FavoritoSumAggregateOutputType | null
    _min: FavoritoMinAggregateOutputType | null
    _max: FavoritoMaxAggregateOutputType | null
  }

  type GetFavoritoGroupByPayload<T extends FavoritoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoritoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoritoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoritoGroupByOutputType[P]>
            : GetScalarType<T[P], FavoritoGroupByOutputType[P]>
        }
      >
    >


  export type FavoritoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estado?: boolean
    usuarioId?: boolean
    emprendimientoId?: boolean
    createdAt?: boolean
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorito"]>

  export type FavoritoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estado?: boolean
    usuarioId?: boolean
    emprendimientoId?: boolean
    createdAt?: boolean
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorito"]>

  export type FavoritoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    estado?: boolean
    usuarioId?: boolean
    emprendimientoId?: boolean
    createdAt?: boolean
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorito"]>

  export type FavoritoSelectScalar = {
    id?: boolean
    estado?: boolean
    usuarioId?: boolean
    emprendimientoId?: boolean
    createdAt?: boolean
  }

  export type FavoritoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "estado" | "usuarioId" | "emprendimientoId" | "createdAt", ExtArgs["result"]["favorito"]>
  export type FavoritoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type FavoritoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type FavoritoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $FavoritoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorito"
    objects: {
      emprendimiento: Prisma.$EmprendimientoPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      estado: string
      usuarioId: number
      emprendimientoId: number
      createdAt: Date
    }, ExtArgs["result"]["favorito"]>
    composites: {}
  }

  type FavoritoGetPayload<S extends boolean | null | undefined | FavoritoDefaultArgs> = $Result.GetResult<Prisma.$FavoritoPayload, S>

  type FavoritoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoritoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoritoCountAggregateInputType | true
    }

  export interface FavoritoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorito'], meta: { name: 'Favorito' } }
    /**
     * Find zero or one Favorito that matches the filter.
     * @param {FavoritoFindUniqueArgs} args - Arguments to find a Favorito
     * @example
     * // Get one Favorito
     * const favorito = await prisma.favorito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoritoFindUniqueArgs>(args: SelectSubset<T, FavoritoFindUniqueArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Favorito that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoritoFindUniqueOrThrowArgs} args - Arguments to find a Favorito
     * @example
     * // Get one Favorito
     * const favorito = await prisma.favorito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoritoFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoritoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoFindFirstArgs} args - Arguments to find a Favorito
     * @example
     * // Get one Favorito
     * const favorito = await prisma.favorito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoritoFindFirstArgs>(args?: SelectSubset<T, FavoritoFindFirstArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoFindFirstOrThrowArgs} args - Arguments to find a Favorito
     * @example
     * // Get one Favorito
     * const favorito = await prisma.favorito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoritoFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoritoFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Favoritos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favoritos
     * const favoritos = await prisma.favorito.findMany()
     * 
     * // Get first 10 Favoritos
     * const favoritos = await prisma.favorito.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoritoWithIdOnly = await prisma.favorito.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoritoFindManyArgs>(args?: SelectSubset<T, FavoritoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Favorito.
     * @param {FavoritoCreateArgs} args - Arguments to create a Favorito.
     * @example
     * // Create one Favorito
     * const Favorito = await prisma.favorito.create({
     *   data: {
     *     // ... data to create a Favorito
     *   }
     * })
     * 
     */
    create<T extends FavoritoCreateArgs>(args: SelectSubset<T, FavoritoCreateArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Favoritos.
     * @param {FavoritoCreateManyArgs} args - Arguments to create many Favoritos.
     * @example
     * // Create many Favoritos
     * const favorito = await prisma.favorito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoritoCreateManyArgs>(args?: SelectSubset<T, FavoritoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favoritos and returns the data saved in the database.
     * @param {FavoritoCreateManyAndReturnArgs} args - Arguments to create many Favoritos.
     * @example
     * // Create many Favoritos
     * const favorito = await prisma.favorito.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favoritos and only return the `id`
     * const favoritoWithIdOnly = await prisma.favorito.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoritoCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoritoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Favorito.
     * @param {FavoritoDeleteArgs} args - Arguments to delete one Favorito.
     * @example
     * // Delete one Favorito
     * const Favorito = await prisma.favorito.delete({
     *   where: {
     *     // ... filter to delete one Favorito
     *   }
     * })
     * 
     */
    delete<T extends FavoritoDeleteArgs>(args: SelectSubset<T, FavoritoDeleteArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Favorito.
     * @param {FavoritoUpdateArgs} args - Arguments to update one Favorito.
     * @example
     * // Update one Favorito
     * const favorito = await prisma.favorito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoritoUpdateArgs>(args: SelectSubset<T, FavoritoUpdateArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Favoritos.
     * @param {FavoritoDeleteManyArgs} args - Arguments to filter Favoritos to delete.
     * @example
     * // Delete a few Favoritos
     * const { count } = await prisma.favorito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoritoDeleteManyArgs>(args?: SelectSubset<T, FavoritoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favoritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favoritos
     * const favorito = await prisma.favorito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoritoUpdateManyArgs>(args: SelectSubset<T, FavoritoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favoritos and returns the data updated in the database.
     * @param {FavoritoUpdateManyAndReturnArgs} args - Arguments to update many Favoritos.
     * @example
     * // Update many Favoritos
     * const favorito = await prisma.favorito.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Favoritos and only return the `id`
     * const favoritoWithIdOnly = await prisma.favorito.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavoritoUpdateManyAndReturnArgs>(args: SelectSubset<T, FavoritoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Favorito.
     * @param {FavoritoUpsertArgs} args - Arguments to update or create a Favorito.
     * @example
     * // Update or create a Favorito
     * const favorito = await prisma.favorito.upsert({
     *   create: {
     *     // ... data to create a Favorito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorito we want to update
     *   }
     * })
     */
    upsert<T extends FavoritoUpsertArgs>(args: SelectSubset<T, FavoritoUpsertArgs<ExtArgs>>): Prisma__FavoritoClient<$Result.GetResult<Prisma.$FavoritoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Favoritos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoCountArgs} args - Arguments to filter Favoritos to count.
     * @example
     * // Count the number of Favoritos
     * const count = await prisma.favorito.count({
     *   where: {
     *     // ... the filter for the Favoritos we want to count
     *   }
     * })
    **/
    count<T extends FavoritoCountArgs>(
      args?: Subset<T, FavoritoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoritoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoritoAggregateArgs>(args: Subset<T, FavoritoAggregateArgs>): Prisma.PrismaPromise<GetFavoritoAggregateType<T>>

    /**
     * Group by Favorito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoritoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoritoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoritoGroupByArgs['orderBy'] }
        : { orderBy?: FavoritoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoritoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoritoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorito model
   */
  readonly fields: FavoritoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoritoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emprendimiento<T extends EmprendimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmprendimientoDefaultArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorito model
   */
  interface FavoritoFieldRefs {
    readonly id: FieldRef<"Favorito", 'Int'>
    readonly estado: FieldRef<"Favorito", 'String'>
    readonly usuarioId: FieldRef<"Favorito", 'Int'>
    readonly emprendimientoId: FieldRef<"Favorito", 'Int'>
    readonly createdAt: FieldRef<"Favorito", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorito findUnique
   */
  export type FavoritoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * Filter, which Favorito to fetch.
     */
    where: FavoritoWhereUniqueInput
  }

  /**
   * Favorito findUniqueOrThrow
   */
  export type FavoritoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * Filter, which Favorito to fetch.
     */
    where: FavoritoWhereUniqueInput
  }

  /**
   * Favorito findFirst
   */
  export type FavoritoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * Filter, which Favorito to fetch.
     */
    where?: FavoritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favoritos to fetch.
     */
    orderBy?: FavoritoOrderByWithRelationInput | FavoritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favoritos.
     */
    cursor?: FavoritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favoritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favoritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favoritos.
     */
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[]
  }

  /**
   * Favorito findFirstOrThrow
   */
  export type FavoritoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * Filter, which Favorito to fetch.
     */
    where?: FavoritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favoritos to fetch.
     */
    orderBy?: FavoritoOrderByWithRelationInput | FavoritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favoritos.
     */
    cursor?: FavoritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favoritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favoritos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favoritos.
     */
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[]
  }

  /**
   * Favorito findMany
   */
  export type FavoritoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * Filter, which Favoritos to fetch.
     */
    where?: FavoritoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favoritos to fetch.
     */
    orderBy?: FavoritoOrderByWithRelationInput | FavoritoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favoritos.
     */
    cursor?: FavoritoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favoritos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favoritos.
     */
    skip?: number
    distinct?: FavoritoScalarFieldEnum | FavoritoScalarFieldEnum[]
  }

  /**
   * Favorito create
   */
  export type FavoritoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorito.
     */
    data: XOR<FavoritoCreateInput, FavoritoUncheckedCreateInput>
  }

  /**
   * Favorito createMany
   */
  export type FavoritoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favoritos.
     */
    data: FavoritoCreateManyInput | FavoritoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorito createManyAndReturn
   */
  export type FavoritoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * The data used to create many Favoritos.
     */
    data: FavoritoCreateManyInput | FavoritoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorito update
   */
  export type FavoritoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorito.
     */
    data: XOR<FavoritoUpdateInput, FavoritoUncheckedUpdateInput>
    /**
     * Choose, which Favorito to update.
     */
    where: FavoritoWhereUniqueInput
  }

  /**
   * Favorito updateMany
   */
  export type FavoritoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favoritos.
     */
    data: XOR<FavoritoUpdateManyMutationInput, FavoritoUncheckedUpdateManyInput>
    /**
     * Filter which Favoritos to update
     */
    where?: FavoritoWhereInput
    /**
     * Limit how many Favoritos to update.
     */
    limit?: number
  }

  /**
   * Favorito updateManyAndReturn
   */
  export type FavoritoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * The data used to update Favoritos.
     */
    data: XOR<FavoritoUpdateManyMutationInput, FavoritoUncheckedUpdateManyInput>
    /**
     * Filter which Favoritos to update
     */
    where?: FavoritoWhereInput
    /**
     * Limit how many Favoritos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorito upsert
   */
  export type FavoritoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorito to update in case it exists.
     */
    where: FavoritoWhereUniqueInput
    /**
     * In case the Favorito found by the `where` argument doesn't exist, create a new Favorito with this data.
     */
    create: XOR<FavoritoCreateInput, FavoritoUncheckedCreateInput>
    /**
     * In case the Favorito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoritoUpdateInput, FavoritoUncheckedUpdateInput>
  }

  /**
   * Favorito delete
   */
  export type FavoritoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
    /**
     * Filter which Favorito to delete.
     */
    where: FavoritoWhereUniqueInput
  }

  /**
   * Favorito deleteMany
   */
  export type FavoritoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favoritos to delete
     */
    where?: FavoritoWhereInput
    /**
     * Limit how many Favoritos to delete.
     */
    limit?: number
  }

  /**
   * Favorito without action
   */
  export type FavoritoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorito
     */
    select?: FavoritoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorito
     */
    omit?: FavoritoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoritoInclude<ExtArgs> | null
  }


  /**
   * Model Reserva
   */

  export type AggregateReserva = {
    _count: ReservaCountAggregateOutputType | null
    _avg: ReservaAvgAggregateOutputType | null
    _sum: ReservaSumAggregateOutputType | null
    _min: ReservaMinAggregateOutputType | null
    _max: ReservaMaxAggregateOutputType | null
  }

  export type ReservaAvgAggregateOutputType = {
    id: number | null
    turistaId: number | null
    cantidadPersonas: number | null
    precioTotal: Decimal | null
  }

  export type ReservaSumAggregateOutputType = {
    id: number | null
    turistaId: number | null
    cantidadPersonas: number | null
    precioTotal: Decimal | null
  }

  export type ReservaMinAggregateOutputType = {
    id: number | null
    codigoReserva: string | null
    turistaId: number | null
    tipoReserva: string | null
    fechaReserva: Date | null
    fechaInicio: Date | null
    hora: string | null
    fechaFin: Date | null
    cantidadPersonas: number | null
    precioTotal: Decimal | null
    moneda: string | null
    estado: string | null
    metodoPago: string | null
    notas: string | null
    motivoCancelacion: string | null
    fechaCancelacion: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReservaMaxAggregateOutputType = {
    id: number | null
    codigoReserva: string | null
    turistaId: number | null
    tipoReserva: string | null
    fechaReserva: Date | null
    fechaInicio: Date | null
    hora: string | null
    fechaFin: Date | null
    cantidadPersonas: number | null
    precioTotal: Decimal | null
    moneda: string | null
    estado: string | null
    metodoPago: string | null
    notas: string | null
    motivoCancelacion: string | null
    fechaCancelacion: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReservaCountAggregateOutputType = {
    id: number
    codigoReserva: number
    turistaId: number
    tipoReserva: number
    fechaReserva: number
    fechaInicio: number
    hora: number
    fechaFin: number
    cantidadPersonas: number
    precioTotal: number
    moneda: number
    estado: number
    metodoPago: number
    datosPago: number
    notas: number
    motivoCancelacion: number
    fechaCancelacion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReservaAvgAggregateInputType = {
    id?: true
    turistaId?: true
    cantidadPersonas?: true
    precioTotal?: true
  }

  export type ReservaSumAggregateInputType = {
    id?: true
    turistaId?: true
    cantidadPersonas?: true
    precioTotal?: true
  }

  export type ReservaMinAggregateInputType = {
    id?: true
    codigoReserva?: true
    turistaId?: true
    tipoReserva?: true
    fechaReserva?: true
    fechaInicio?: true
    hora?: true
    fechaFin?: true
    cantidadPersonas?: true
    precioTotal?: true
    moneda?: true
    estado?: true
    metodoPago?: true
    notas?: true
    motivoCancelacion?: true
    fechaCancelacion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReservaMaxAggregateInputType = {
    id?: true
    codigoReserva?: true
    turistaId?: true
    tipoReserva?: true
    fechaReserva?: true
    fechaInicio?: true
    hora?: true
    fechaFin?: true
    cantidadPersonas?: true
    precioTotal?: true
    moneda?: true
    estado?: true
    metodoPago?: true
    notas?: true
    motivoCancelacion?: true
    fechaCancelacion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReservaCountAggregateInputType = {
    id?: true
    codigoReserva?: true
    turistaId?: true
    tipoReserva?: true
    fechaReserva?: true
    fechaInicio?: true
    hora?: true
    fechaFin?: true
    cantidadPersonas?: true
    precioTotal?: true
    moneda?: true
    estado?: true
    metodoPago?: true
    datosPago?: true
    notas?: true
    motivoCancelacion?: true
    fechaCancelacion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReservaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reserva to aggregate.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservas
    **/
    _count?: true | ReservaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservaMaxAggregateInputType
  }

  export type GetReservaAggregateType<T extends ReservaAggregateArgs> = {
        [P in keyof T & keyof AggregateReserva]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReserva[P]>
      : GetScalarType<T[P], AggregateReserva[P]>
  }




  export type ReservaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservaWhereInput
    orderBy?: ReservaOrderByWithAggregationInput | ReservaOrderByWithAggregationInput[]
    by: ReservaScalarFieldEnum[] | ReservaScalarFieldEnum
    having?: ReservaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservaCountAggregateInputType | true
    _avg?: ReservaAvgAggregateInputType
    _sum?: ReservaSumAggregateInputType
    _min?: ReservaMinAggregateInputType
    _max?: ReservaMaxAggregateInputType
  }

  export type ReservaGroupByOutputType = {
    id: number
    codigoReserva: string
    turistaId: number
    tipoReserva: string
    fechaReserva: Date
    fechaInicio: Date
    hora: string | null
    fechaFin: Date | null
    cantidadPersonas: number
    precioTotal: Decimal
    moneda: string
    estado: string
    metodoPago: string | null
    datosPago: JsonValue | null
    notas: string | null
    motivoCancelacion: string | null
    fechaCancelacion: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ReservaCountAggregateOutputType | null
    _avg: ReservaAvgAggregateOutputType | null
    _sum: ReservaSumAggregateOutputType | null
    _min: ReservaMinAggregateOutputType | null
    _max: ReservaMaxAggregateOutputType | null
  }

  type GetReservaGroupByPayload<T extends ReservaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservaGroupByOutputType[P]>
            : GetScalarType<T[P], ReservaGroupByOutputType[P]>
        }
      >
    >


  export type ReservaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoReserva?: boolean
    turistaId?: boolean
    tipoReserva?: boolean
    fechaReserva?: boolean
    fechaInicio?: boolean
    hora?: boolean
    fechaFin?: boolean
    cantidadPersonas?: boolean
    precioTotal?: boolean
    moneda?: boolean
    estado?: boolean
    metodoPago?: boolean
    datosPago?: boolean
    notas?: boolean
    motivoCancelacion?: boolean
    fechaCancelacion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itinerarios?: boolean | Reserva$itinerariosArgs<ExtArgs>
    pagos?: boolean | Reserva$pagosArgs<ExtArgs>
    turista?: boolean | TuristaDefaultArgs<ExtArgs>
    _count?: boolean | ReservaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reserva"]>

  export type ReservaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoReserva?: boolean
    turistaId?: boolean
    tipoReserva?: boolean
    fechaReserva?: boolean
    fechaInicio?: boolean
    hora?: boolean
    fechaFin?: boolean
    cantidadPersonas?: boolean
    precioTotal?: boolean
    moneda?: boolean
    estado?: boolean
    metodoPago?: boolean
    datosPago?: boolean
    notas?: boolean
    motivoCancelacion?: boolean
    fechaCancelacion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    turista?: boolean | TuristaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reserva"]>

  export type ReservaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigoReserva?: boolean
    turistaId?: boolean
    tipoReserva?: boolean
    fechaReserva?: boolean
    fechaInicio?: boolean
    hora?: boolean
    fechaFin?: boolean
    cantidadPersonas?: boolean
    precioTotal?: boolean
    moneda?: boolean
    estado?: boolean
    metodoPago?: boolean
    datosPago?: boolean
    notas?: boolean
    motivoCancelacion?: boolean
    fechaCancelacion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    turista?: boolean | TuristaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reserva"]>

  export type ReservaSelectScalar = {
    id?: boolean
    codigoReserva?: boolean
    turistaId?: boolean
    tipoReserva?: boolean
    fechaReserva?: boolean
    fechaInicio?: boolean
    hora?: boolean
    fechaFin?: boolean
    cantidadPersonas?: boolean
    precioTotal?: boolean
    moneda?: boolean
    estado?: boolean
    metodoPago?: boolean
    datosPago?: boolean
    notas?: boolean
    motivoCancelacion?: boolean
    fechaCancelacion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReservaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigoReserva" | "turistaId" | "tipoReserva" | "fechaReserva" | "fechaInicio" | "hora" | "fechaFin" | "cantidadPersonas" | "precioTotal" | "moneda" | "estado" | "metodoPago" | "datosPago" | "notas" | "motivoCancelacion" | "fechaCancelacion" | "createdAt" | "updatedAt", ExtArgs["result"]["reserva"]>
  export type ReservaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerarios?: boolean | Reserva$itinerariosArgs<ExtArgs>
    pagos?: boolean | Reserva$pagosArgs<ExtArgs>
    turista?: boolean | TuristaDefaultArgs<ExtArgs>
    _count?: boolean | ReservaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReservaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    turista?: boolean | TuristaDefaultArgs<ExtArgs>
  }
  export type ReservaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    turista?: boolean | TuristaDefaultArgs<ExtArgs>
  }

  export type $ReservaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reserva"
    objects: {
      itinerarios: Prisma.$ItinerarioReservaPayload<ExtArgs>[]
      pagos: Prisma.$PagoPayload<ExtArgs>[]
      turista: Prisma.$TuristaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigoReserva: string
      turistaId: number
      tipoReserva: string
      fechaReserva: Date
      fechaInicio: Date
      hora: string | null
      fechaFin: Date | null
      cantidadPersonas: number
      precioTotal: Prisma.Decimal
      moneda: string
      estado: string
      metodoPago: string | null
      datosPago: Prisma.JsonValue | null
      notas: string | null
      motivoCancelacion: string | null
      fechaCancelacion: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reserva"]>
    composites: {}
  }

  type ReservaGetPayload<S extends boolean | null | undefined | ReservaDefaultArgs> = $Result.GetResult<Prisma.$ReservaPayload, S>

  type ReservaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReservaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReservaCountAggregateInputType | true
    }

  export interface ReservaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reserva'], meta: { name: 'Reserva' } }
    /**
     * Find zero or one Reserva that matches the filter.
     * @param {ReservaFindUniqueArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservaFindUniqueArgs>(args: SelectSubset<T, ReservaFindUniqueArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reserva that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReservaFindUniqueOrThrowArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservaFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reserva that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaFindFirstArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservaFindFirstArgs>(args?: SelectSubset<T, ReservaFindFirstArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reserva that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaFindFirstOrThrowArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservaFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reservas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservas
     * const reservas = await prisma.reserva.findMany()
     * 
     * // Get first 10 Reservas
     * const reservas = await prisma.reserva.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservaWithIdOnly = await prisma.reserva.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservaFindManyArgs>(args?: SelectSubset<T, ReservaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reserva.
     * @param {ReservaCreateArgs} args - Arguments to create a Reserva.
     * @example
     * // Create one Reserva
     * const Reserva = await prisma.reserva.create({
     *   data: {
     *     // ... data to create a Reserva
     *   }
     * })
     * 
     */
    create<T extends ReservaCreateArgs>(args: SelectSubset<T, ReservaCreateArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reservas.
     * @param {ReservaCreateManyArgs} args - Arguments to create many Reservas.
     * @example
     * // Create many Reservas
     * const reserva = await prisma.reserva.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservaCreateManyArgs>(args?: SelectSubset<T, ReservaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservas and returns the data saved in the database.
     * @param {ReservaCreateManyAndReturnArgs} args - Arguments to create many Reservas.
     * @example
     * // Create many Reservas
     * const reserva = await prisma.reserva.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservas and only return the `id`
     * const reservaWithIdOnly = await prisma.reserva.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservaCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reserva.
     * @param {ReservaDeleteArgs} args - Arguments to delete one Reserva.
     * @example
     * // Delete one Reserva
     * const Reserva = await prisma.reserva.delete({
     *   where: {
     *     // ... filter to delete one Reserva
     *   }
     * })
     * 
     */
    delete<T extends ReservaDeleteArgs>(args: SelectSubset<T, ReservaDeleteArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reserva.
     * @param {ReservaUpdateArgs} args - Arguments to update one Reserva.
     * @example
     * // Update one Reserva
     * const reserva = await prisma.reserva.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservaUpdateArgs>(args: SelectSubset<T, ReservaUpdateArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reservas.
     * @param {ReservaDeleteManyArgs} args - Arguments to filter Reservas to delete.
     * @example
     * // Delete a few Reservas
     * const { count } = await prisma.reserva.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservaDeleteManyArgs>(args?: SelectSubset<T, ReservaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservas
     * const reserva = await prisma.reserva.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservaUpdateManyArgs>(args: SelectSubset<T, ReservaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservas and returns the data updated in the database.
     * @param {ReservaUpdateManyAndReturnArgs} args - Arguments to update many Reservas.
     * @example
     * // Update many Reservas
     * const reserva = await prisma.reserva.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reservas and only return the `id`
     * const reservaWithIdOnly = await prisma.reserva.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReservaUpdateManyAndReturnArgs>(args: SelectSubset<T, ReservaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reserva.
     * @param {ReservaUpsertArgs} args - Arguments to update or create a Reserva.
     * @example
     * // Update or create a Reserva
     * const reserva = await prisma.reserva.upsert({
     *   create: {
     *     // ... data to create a Reserva
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reserva we want to update
     *   }
     * })
     */
    upsert<T extends ReservaUpsertArgs>(args: SelectSubset<T, ReservaUpsertArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaCountArgs} args - Arguments to filter Reservas to count.
     * @example
     * // Count the number of Reservas
     * const count = await prisma.reserva.count({
     *   where: {
     *     // ... the filter for the Reservas we want to count
     *   }
     * })
    **/
    count<T extends ReservaCountArgs>(
      args?: Subset<T, ReservaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservaAggregateArgs>(args: Subset<T, ReservaAggregateArgs>): Prisma.PrismaPromise<GetReservaAggregateType<T>>

    /**
     * Group by Reserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservaGroupByArgs['orderBy'] }
        : { orderBy?: ReservaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reserva model
   */
  readonly fields: ReservaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reserva.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itinerarios<T extends Reserva$itinerariosArgs<ExtArgs> = {}>(args?: Subset<T, Reserva$itinerariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pagos<T extends Reserva$pagosArgs<ExtArgs> = {}>(args?: Subset<T, Reserva$pagosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    turista<T extends TuristaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TuristaDefaultArgs<ExtArgs>>): Prisma__TuristaClient<$Result.GetResult<Prisma.$TuristaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reserva model
   */
  interface ReservaFieldRefs {
    readonly id: FieldRef<"Reserva", 'Int'>
    readonly codigoReserva: FieldRef<"Reserva", 'String'>
    readonly turistaId: FieldRef<"Reserva", 'Int'>
    readonly tipoReserva: FieldRef<"Reserva", 'String'>
    readonly fechaReserva: FieldRef<"Reserva", 'DateTime'>
    readonly fechaInicio: FieldRef<"Reserva", 'DateTime'>
    readonly hora: FieldRef<"Reserva", 'String'>
    readonly fechaFin: FieldRef<"Reserva", 'DateTime'>
    readonly cantidadPersonas: FieldRef<"Reserva", 'Int'>
    readonly precioTotal: FieldRef<"Reserva", 'Decimal'>
    readonly moneda: FieldRef<"Reserva", 'String'>
    readonly estado: FieldRef<"Reserva", 'String'>
    readonly metodoPago: FieldRef<"Reserva", 'String'>
    readonly datosPago: FieldRef<"Reserva", 'Json'>
    readonly notas: FieldRef<"Reserva", 'String'>
    readonly motivoCancelacion: FieldRef<"Reserva", 'String'>
    readonly fechaCancelacion: FieldRef<"Reserva", 'DateTime'>
    readonly createdAt: FieldRef<"Reserva", 'DateTime'>
    readonly updatedAt: FieldRef<"Reserva", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reserva findUnique
   */
  export type ReservaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reserva
     */
    omit?: ReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reserva to fetch.
     */
    where: ReservaWhereUniqueInput
  }

  /**
   * Reserva findUniqueOrThrow
   */
  export type ReservaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reserva
     */
    omit?: ReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reserva to fetch.
     */
    where: ReservaWhereUniqueInput
  }

  /**
   * Reserva findFirst
   */
  export type ReservaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reserva
     */
    omit?: ReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reserva to fetch.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservas.
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservas.
     */
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * Reserva findFirstOrThrow
   */
  export type ReservaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reserva
     */
    omit?: ReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reserva to fetch.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservas.
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservas.
     */
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * Reserva findMany
   */
  export type ReservaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reserva
     */
    omit?: ReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reservas to fetch.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservas.
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * Reserva create
   */
  export type ReservaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reserva
     */
    omit?: ReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * The data needed to create a Reserva.
     */
    data: XOR<ReservaCreateInput, ReservaUncheckedCreateInput>
  }

  /**
   * Reserva createMany
   */
  export type ReservaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservas.
     */
    data: ReservaCreateManyInput | ReservaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reserva createManyAndReturn
   */
  export type ReservaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reserva
     */
    omit?: ReservaOmit<ExtArgs> | null
    /**
     * The data used to create many Reservas.
     */
    data: ReservaCreateManyInput | ReservaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reserva update
   */
  export type ReservaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reserva
     */
    omit?: ReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * The data needed to update a Reserva.
     */
    data: XOR<ReservaUpdateInput, ReservaUncheckedUpdateInput>
    /**
     * Choose, which Reserva to update.
     */
    where: ReservaWhereUniqueInput
  }

  /**
   * Reserva updateMany
   */
  export type ReservaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservas.
     */
    data: XOR<ReservaUpdateManyMutationInput, ReservaUncheckedUpdateManyInput>
    /**
     * Filter which Reservas to update
     */
    where?: ReservaWhereInput
    /**
     * Limit how many Reservas to update.
     */
    limit?: number
  }

  /**
   * Reserva updateManyAndReturn
   */
  export type ReservaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reserva
     */
    omit?: ReservaOmit<ExtArgs> | null
    /**
     * The data used to update Reservas.
     */
    data: XOR<ReservaUpdateManyMutationInput, ReservaUncheckedUpdateManyInput>
    /**
     * Filter which Reservas to update
     */
    where?: ReservaWhereInput
    /**
     * Limit how many Reservas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reserva upsert
   */
  export type ReservaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reserva
     */
    omit?: ReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * The filter to search for the Reserva to update in case it exists.
     */
    where: ReservaWhereUniqueInput
    /**
     * In case the Reserva found by the `where` argument doesn't exist, create a new Reserva with this data.
     */
    create: XOR<ReservaCreateInput, ReservaUncheckedCreateInput>
    /**
     * In case the Reserva was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservaUpdateInput, ReservaUncheckedUpdateInput>
  }

  /**
   * Reserva delete
   */
  export type ReservaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reserva
     */
    omit?: ReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter which Reserva to delete.
     */
    where: ReservaWhereUniqueInput
  }

  /**
   * Reserva deleteMany
   */
  export type ReservaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservas to delete
     */
    where?: ReservaWhereInput
    /**
     * Limit how many Reservas to delete.
     */
    limit?: number
  }

  /**
   * Reserva.itinerarios
   */
  export type Reserva$itinerariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaInclude<ExtArgs> | null
    where?: ItinerarioReservaWhereInput
    orderBy?: ItinerarioReservaOrderByWithRelationInput | ItinerarioReservaOrderByWithRelationInput[]
    cursor?: ItinerarioReservaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItinerarioReservaScalarFieldEnum | ItinerarioReservaScalarFieldEnum[]
  }

  /**
   * Reserva.pagos
   */
  export type Reserva$pagosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    where?: PagoWhereInput
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    cursor?: PagoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Reserva without action
   */
  export type ReservaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reserva
     */
    omit?: ReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
  }


  /**
   * Model ItinerarioReserva
   */

  export type AggregateItinerarioReserva = {
    _count: ItinerarioReservaCountAggregateOutputType | null
    _avg: ItinerarioReservaAvgAggregateOutputType | null
    _sum: ItinerarioReservaSumAggregateOutputType | null
    _min: ItinerarioReservaMinAggregateOutputType | null
    _max: ItinerarioReservaMaxAggregateOutputType | null
  }

  export type ItinerarioReservaAvgAggregateOutputType = {
    id: number | null
    duracion: number | null
    reservaId: number | null
    servicioId: number | null
  }

  export type ItinerarioReservaSumAggregateOutputType = {
    id: number | null
    duracion: number | null
    reservaId: number | null
    servicioId: number | null
  }

  export type ItinerarioReservaMinAggregateOutputType = {
    id: number | null
    fecha: Date | null
    hora: Date | null
    tipoEvento: string | null
    descripcion: string | null
    notas: string | null
    duracion: number | null
    reservaId: number | null
    servicioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItinerarioReservaMaxAggregateOutputType = {
    id: number | null
    fecha: Date | null
    hora: Date | null
    tipoEvento: string | null
    descripcion: string | null
    notas: string | null
    duracion: number | null
    reservaId: number | null
    servicioId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItinerarioReservaCountAggregateOutputType = {
    id: number
    fecha: number
    hora: number
    tipoEvento: number
    descripcion: number
    notas: number
    duracion: number
    reservaId: number
    servicioId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItinerarioReservaAvgAggregateInputType = {
    id?: true
    duracion?: true
    reservaId?: true
    servicioId?: true
  }

  export type ItinerarioReservaSumAggregateInputType = {
    id?: true
    duracion?: true
    reservaId?: true
    servicioId?: true
  }

  export type ItinerarioReservaMinAggregateInputType = {
    id?: true
    fecha?: true
    hora?: true
    tipoEvento?: true
    descripcion?: true
    notas?: true
    duracion?: true
    reservaId?: true
    servicioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItinerarioReservaMaxAggregateInputType = {
    id?: true
    fecha?: true
    hora?: true
    tipoEvento?: true
    descripcion?: true
    notas?: true
    duracion?: true
    reservaId?: true
    servicioId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItinerarioReservaCountAggregateInputType = {
    id?: true
    fecha?: true
    hora?: true
    tipoEvento?: true
    descripcion?: true
    notas?: true
    duracion?: true
    reservaId?: true
    servicioId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItinerarioReservaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItinerarioReserva to aggregate.
     */
    where?: ItinerarioReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItinerarioReservas to fetch.
     */
    orderBy?: ItinerarioReservaOrderByWithRelationInput | ItinerarioReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItinerarioReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItinerarioReservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItinerarioReservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItinerarioReservas
    **/
    _count?: true | ItinerarioReservaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItinerarioReservaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItinerarioReservaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItinerarioReservaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItinerarioReservaMaxAggregateInputType
  }

  export type GetItinerarioReservaAggregateType<T extends ItinerarioReservaAggregateArgs> = {
        [P in keyof T & keyof AggregateItinerarioReserva]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItinerarioReserva[P]>
      : GetScalarType<T[P], AggregateItinerarioReserva[P]>
  }




  export type ItinerarioReservaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItinerarioReservaWhereInput
    orderBy?: ItinerarioReservaOrderByWithAggregationInput | ItinerarioReservaOrderByWithAggregationInput[]
    by: ItinerarioReservaScalarFieldEnum[] | ItinerarioReservaScalarFieldEnum
    having?: ItinerarioReservaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItinerarioReservaCountAggregateInputType | true
    _avg?: ItinerarioReservaAvgAggregateInputType
    _sum?: ItinerarioReservaSumAggregateInputType
    _min?: ItinerarioReservaMinAggregateInputType
    _max?: ItinerarioReservaMaxAggregateInputType
  }

  export type ItinerarioReservaGroupByOutputType = {
    id: number
    fecha: Date
    hora: Date | null
    tipoEvento: string
    descripcion: string
    notas: string | null
    duracion: number | null
    reservaId: number
    servicioId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ItinerarioReservaCountAggregateOutputType | null
    _avg: ItinerarioReservaAvgAggregateOutputType | null
    _sum: ItinerarioReservaSumAggregateOutputType | null
    _min: ItinerarioReservaMinAggregateOutputType | null
    _max: ItinerarioReservaMaxAggregateOutputType | null
  }

  type GetItinerarioReservaGroupByPayload<T extends ItinerarioReservaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItinerarioReservaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItinerarioReservaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItinerarioReservaGroupByOutputType[P]>
            : GetScalarType<T[P], ItinerarioReservaGroupByOutputType[P]>
        }
      >
    >


  export type ItinerarioReservaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    hora?: boolean
    tipoEvento?: boolean
    descripcion?: boolean
    notas?: boolean
    duracion?: boolean
    reservaId?: boolean
    servicioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itinerarioLugares?: boolean | ItinerarioReserva$itinerarioLugaresArgs<ExtArgs>
    reserva?: boolean | ReservaDefaultArgs<ExtArgs>
    servicio?: boolean | ItinerarioReserva$servicioArgs<ExtArgs>
    _count?: boolean | ItinerarioReservaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerarioReserva"]>

  export type ItinerarioReservaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    hora?: boolean
    tipoEvento?: boolean
    descripcion?: boolean
    notas?: boolean
    duracion?: boolean
    reservaId?: boolean
    servicioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reserva?: boolean | ReservaDefaultArgs<ExtArgs>
    servicio?: boolean | ItinerarioReserva$servicioArgs<ExtArgs>
  }, ExtArgs["result"]["itinerarioReserva"]>

  export type ItinerarioReservaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha?: boolean
    hora?: boolean
    tipoEvento?: boolean
    descripcion?: boolean
    notas?: boolean
    duracion?: boolean
    reservaId?: boolean
    servicioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reserva?: boolean | ReservaDefaultArgs<ExtArgs>
    servicio?: boolean | ItinerarioReserva$servicioArgs<ExtArgs>
  }, ExtArgs["result"]["itinerarioReserva"]>

  export type ItinerarioReservaSelectScalar = {
    id?: boolean
    fecha?: boolean
    hora?: boolean
    tipoEvento?: boolean
    descripcion?: boolean
    notas?: boolean
    duracion?: boolean
    reservaId?: boolean
    servicioId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItinerarioReservaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fecha" | "hora" | "tipoEvento" | "descripcion" | "notas" | "duracion" | "reservaId" | "servicioId" | "createdAt" | "updatedAt", ExtArgs["result"]["itinerarioReserva"]>
  export type ItinerarioReservaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerarioLugares?: boolean | ItinerarioReserva$itinerarioLugaresArgs<ExtArgs>
    reserva?: boolean | ReservaDefaultArgs<ExtArgs>
    servicio?: boolean | ItinerarioReserva$servicioArgs<ExtArgs>
    _count?: boolean | ItinerarioReservaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItinerarioReservaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reserva?: boolean | ReservaDefaultArgs<ExtArgs>
    servicio?: boolean | ItinerarioReserva$servicioArgs<ExtArgs>
  }
  export type ItinerarioReservaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reserva?: boolean | ReservaDefaultArgs<ExtArgs>
    servicio?: boolean | ItinerarioReserva$servicioArgs<ExtArgs>
  }

  export type $ItinerarioReservaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItinerarioReserva"
    objects: {
      itinerarioLugares: Prisma.$ItinerarioLugarPayload<ExtArgs>[]
      reserva: Prisma.$ReservaPayload<ExtArgs>
      servicio: Prisma.$ServicioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fecha: Date
      hora: Date | null
      tipoEvento: string
      descripcion: string
      notas: string | null
      duracion: number | null
      reservaId: number
      servicioId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["itinerarioReserva"]>
    composites: {}
  }

  type ItinerarioReservaGetPayload<S extends boolean | null | undefined | ItinerarioReservaDefaultArgs> = $Result.GetResult<Prisma.$ItinerarioReservaPayload, S>

  type ItinerarioReservaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItinerarioReservaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItinerarioReservaCountAggregateInputType | true
    }

  export interface ItinerarioReservaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItinerarioReserva'], meta: { name: 'ItinerarioReserva' } }
    /**
     * Find zero or one ItinerarioReserva that matches the filter.
     * @param {ItinerarioReservaFindUniqueArgs} args - Arguments to find a ItinerarioReserva
     * @example
     * // Get one ItinerarioReserva
     * const itinerarioReserva = await prisma.itinerarioReserva.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItinerarioReservaFindUniqueArgs>(args: SelectSubset<T, ItinerarioReservaFindUniqueArgs<ExtArgs>>): Prisma__ItinerarioReservaClient<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItinerarioReserva that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItinerarioReservaFindUniqueOrThrowArgs} args - Arguments to find a ItinerarioReserva
     * @example
     * // Get one ItinerarioReserva
     * const itinerarioReserva = await prisma.itinerarioReserva.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItinerarioReservaFindUniqueOrThrowArgs>(args: SelectSubset<T, ItinerarioReservaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItinerarioReservaClient<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItinerarioReserva that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioReservaFindFirstArgs} args - Arguments to find a ItinerarioReserva
     * @example
     * // Get one ItinerarioReserva
     * const itinerarioReserva = await prisma.itinerarioReserva.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItinerarioReservaFindFirstArgs>(args?: SelectSubset<T, ItinerarioReservaFindFirstArgs<ExtArgs>>): Prisma__ItinerarioReservaClient<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItinerarioReserva that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioReservaFindFirstOrThrowArgs} args - Arguments to find a ItinerarioReserva
     * @example
     * // Get one ItinerarioReserva
     * const itinerarioReserva = await prisma.itinerarioReserva.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItinerarioReservaFindFirstOrThrowArgs>(args?: SelectSubset<T, ItinerarioReservaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItinerarioReservaClient<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItinerarioReservas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioReservaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItinerarioReservas
     * const itinerarioReservas = await prisma.itinerarioReserva.findMany()
     * 
     * // Get first 10 ItinerarioReservas
     * const itinerarioReservas = await prisma.itinerarioReserva.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itinerarioReservaWithIdOnly = await prisma.itinerarioReserva.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItinerarioReservaFindManyArgs>(args?: SelectSubset<T, ItinerarioReservaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItinerarioReserva.
     * @param {ItinerarioReservaCreateArgs} args - Arguments to create a ItinerarioReserva.
     * @example
     * // Create one ItinerarioReserva
     * const ItinerarioReserva = await prisma.itinerarioReserva.create({
     *   data: {
     *     // ... data to create a ItinerarioReserva
     *   }
     * })
     * 
     */
    create<T extends ItinerarioReservaCreateArgs>(args: SelectSubset<T, ItinerarioReservaCreateArgs<ExtArgs>>): Prisma__ItinerarioReservaClient<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItinerarioReservas.
     * @param {ItinerarioReservaCreateManyArgs} args - Arguments to create many ItinerarioReservas.
     * @example
     * // Create many ItinerarioReservas
     * const itinerarioReserva = await prisma.itinerarioReserva.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItinerarioReservaCreateManyArgs>(args?: SelectSubset<T, ItinerarioReservaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItinerarioReservas and returns the data saved in the database.
     * @param {ItinerarioReservaCreateManyAndReturnArgs} args - Arguments to create many ItinerarioReservas.
     * @example
     * // Create many ItinerarioReservas
     * const itinerarioReserva = await prisma.itinerarioReserva.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItinerarioReservas and only return the `id`
     * const itinerarioReservaWithIdOnly = await prisma.itinerarioReserva.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItinerarioReservaCreateManyAndReturnArgs>(args?: SelectSubset<T, ItinerarioReservaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItinerarioReserva.
     * @param {ItinerarioReservaDeleteArgs} args - Arguments to delete one ItinerarioReserva.
     * @example
     * // Delete one ItinerarioReserva
     * const ItinerarioReserva = await prisma.itinerarioReserva.delete({
     *   where: {
     *     // ... filter to delete one ItinerarioReserva
     *   }
     * })
     * 
     */
    delete<T extends ItinerarioReservaDeleteArgs>(args: SelectSubset<T, ItinerarioReservaDeleteArgs<ExtArgs>>): Prisma__ItinerarioReservaClient<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItinerarioReserva.
     * @param {ItinerarioReservaUpdateArgs} args - Arguments to update one ItinerarioReserva.
     * @example
     * // Update one ItinerarioReserva
     * const itinerarioReserva = await prisma.itinerarioReserva.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItinerarioReservaUpdateArgs>(args: SelectSubset<T, ItinerarioReservaUpdateArgs<ExtArgs>>): Prisma__ItinerarioReservaClient<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItinerarioReservas.
     * @param {ItinerarioReservaDeleteManyArgs} args - Arguments to filter ItinerarioReservas to delete.
     * @example
     * // Delete a few ItinerarioReservas
     * const { count } = await prisma.itinerarioReserva.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItinerarioReservaDeleteManyArgs>(args?: SelectSubset<T, ItinerarioReservaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItinerarioReservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioReservaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItinerarioReservas
     * const itinerarioReserva = await prisma.itinerarioReserva.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItinerarioReservaUpdateManyArgs>(args: SelectSubset<T, ItinerarioReservaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItinerarioReservas and returns the data updated in the database.
     * @param {ItinerarioReservaUpdateManyAndReturnArgs} args - Arguments to update many ItinerarioReservas.
     * @example
     * // Update many ItinerarioReservas
     * const itinerarioReserva = await prisma.itinerarioReserva.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItinerarioReservas and only return the `id`
     * const itinerarioReservaWithIdOnly = await prisma.itinerarioReserva.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItinerarioReservaUpdateManyAndReturnArgs>(args: SelectSubset<T, ItinerarioReservaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItinerarioReserva.
     * @param {ItinerarioReservaUpsertArgs} args - Arguments to update or create a ItinerarioReserva.
     * @example
     * // Update or create a ItinerarioReserva
     * const itinerarioReserva = await prisma.itinerarioReserva.upsert({
     *   create: {
     *     // ... data to create a ItinerarioReserva
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItinerarioReserva we want to update
     *   }
     * })
     */
    upsert<T extends ItinerarioReservaUpsertArgs>(args: SelectSubset<T, ItinerarioReservaUpsertArgs<ExtArgs>>): Prisma__ItinerarioReservaClient<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItinerarioReservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioReservaCountArgs} args - Arguments to filter ItinerarioReservas to count.
     * @example
     * // Count the number of ItinerarioReservas
     * const count = await prisma.itinerarioReserva.count({
     *   where: {
     *     // ... the filter for the ItinerarioReservas we want to count
     *   }
     * })
    **/
    count<T extends ItinerarioReservaCountArgs>(
      args?: Subset<T, ItinerarioReservaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItinerarioReservaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItinerarioReserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioReservaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItinerarioReservaAggregateArgs>(args: Subset<T, ItinerarioReservaAggregateArgs>): Prisma.PrismaPromise<GetItinerarioReservaAggregateType<T>>

    /**
     * Group by ItinerarioReserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioReservaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItinerarioReservaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItinerarioReservaGroupByArgs['orderBy'] }
        : { orderBy?: ItinerarioReservaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItinerarioReservaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItinerarioReservaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItinerarioReserva model
   */
  readonly fields: ItinerarioReservaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItinerarioReserva.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItinerarioReservaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itinerarioLugares<T extends ItinerarioReserva$itinerarioLugaresArgs<ExtArgs> = {}>(args?: Subset<T, ItinerarioReserva$itinerarioLugaresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItinerarioLugarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reserva<T extends ReservaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReservaDefaultArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    servicio<T extends ItinerarioReserva$servicioArgs<ExtArgs> = {}>(args?: Subset<T, ItinerarioReserva$servicioArgs<ExtArgs>>): Prisma__ServicioClient<$Result.GetResult<Prisma.$ServicioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItinerarioReserva model
   */
  interface ItinerarioReservaFieldRefs {
    readonly id: FieldRef<"ItinerarioReserva", 'Int'>
    readonly fecha: FieldRef<"ItinerarioReserva", 'DateTime'>
    readonly hora: FieldRef<"ItinerarioReserva", 'DateTime'>
    readonly tipoEvento: FieldRef<"ItinerarioReserva", 'String'>
    readonly descripcion: FieldRef<"ItinerarioReserva", 'String'>
    readonly notas: FieldRef<"ItinerarioReserva", 'String'>
    readonly duracion: FieldRef<"ItinerarioReserva", 'Int'>
    readonly reservaId: FieldRef<"ItinerarioReserva", 'Int'>
    readonly servicioId: FieldRef<"ItinerarioReserva", 'Int'>
    readonly createdAt: FieldRef<"ItinerarioReserva", 'DateTime'>
    readonly updatedAt: FieldRef<"ItinerarioReserva", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItinerarioReserva findUnique
   */
  export type ItinerarioReservaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaInclude<ExtArgs> | null
    /**
     * Filter, which ItinerarioReserva to fetch.
     */
    where: ItinerarioReservaWhereUniqueInput
  }

  /**
   * ItinerarioReserva findUniqueOrThrow
   */
  export type ItinerarioReservaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaInclude<ExtArgs> | null
    /**
     * Filter, which ItinerarioReserva to fetch.
     */
    where: ItinerarioReservaWhereUniqueInput
  }

  /**
   * ItinerarioReserva findFirst
   */
  export type ItinerarioReservaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaInclude<ExtArgs> | null
    /**
     * Filter, which ItinerarioReserva to fetch.
     */
    where?: ItinerarioReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItinerarioReservas to fetch.
     */
    orderBy?: ItinerarioReservaOrderByWithRelationInput | ItinerarioReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItinerarioReservas.
     */
    cursor?: ItinerarioReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItinerarioReservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItinerarioReservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItinerarioReservas.
     */
    distinct?: ItinerarioReservaScalarFieldEnum | ItinerarioReservaScalarFieldEnum[]
  }

  /**
   * ItinerarioReserva findFirstOrThrow
   */
  export type ItinerarioReservaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaInclude<ExtArgs> | null
    /**
     * Filter, which ItinerarioReserva to fetch.
     */
    where?: ItinerarioReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItinerarioReservas to fetch.
     */
    orderBy?: ItinerarioReservaOrderByWithRelationInput | ItinerarioReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItinerarioReservas.
     */
    cursor?: ItinerarioReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItinerarioReservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItinerarioReservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItinerarioReservas.
     */
    distinct?: ItinerarioReservaScalarFieldEnum | ItinerarioReservaScalarFieldEnum[]
  }

  /**
   * ItinerarioReserva findMany
   */
  export type ItinerarioReservaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaInclude<ExtArgs> | null
    /**
     * Filter, which ItinerarioReservas to fetch.
     */
    where?: ItinerarioReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItinerarioReservas to fetch.
     */
    orderBy?: ItinerarioReservaOrderByWithRelationInput | ItinerarioReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItinerarioReservas.
     */
    cursor?: ItinerarioReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItinerarioReservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItinerarioReservas.
     */
    skip?: number
    distinct?: ItinerarioReservaScalarFieldEnum | ItinerarioReservaScalarFieldEnum[]
  }

  /**
   * ItinerarioReserva create
   */
  export type ItinerarioReservaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaInclude<ExtArgs> | null
    /**
     * The data needed to create a ItinerarioReserva.
     */
    data: XOR<ItinerarioReservaCreateInput, ItinerarioReservaUncheckedCreateInput>
  }

  /**
   * ItinerarioReserva createMany
   */
  export type ItinerarioReservaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItinerarioReservas.
     */
    data: ItinerarioReservaCreateManyInput | ItinerarioReservaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItinerarioReserva createManyAndReturn
   */
  export type ItinerarioReservaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * The data used to create many ItinerarioReservas.
     */
    data: ItinerarioReservaCreateManyInput | ItinerarioReservaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItinerarioReserva update
   */
  export type ItinerarioReservaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaInclude<ExtArgs> | null
    /**
     * The data needed to update a ItinerarioReserva.
     */
    data: XOR<ItinerarioReservaUpdateInput, ItinerarioReservaUncheckedUpdateInput>
    /**
     * Choose, which ItinerarioReserva to update.
     */
    where: ItinerarioReservaWhereUniqueInput
  }

  /**
   * ItinerarioReserva updateMany
   */
  export type ItinerarioReservaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItinerarioReservas.
     */
    data: XOR<ItinerarioReservaUpdateManyMutationInput, ItinerarioReservaUncheckedUpdateManyInput>
    /**
     * Filter which ItinerarioReservas to update
     */
    where?: ItinerarioReservaWhereInput
    /**
     * Limit how many ItinerarioReservas to update.
     */
    limit?: number
  }

  /**
   * ItinerarioReserva updateManyAndReturn
   */
  export type ItinerarioReservaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * The data used to update ItinerarioReservas.
     */
    data: XOR<ItinerarioReservaUpdateManyMutationInput, ItinerarioReservaUncheckedUpdateManyInput>
    /**
     * Filter which ItinerarioReservas to update
     */
    where?: ItinerarioReservaWhereInput
    /**
     * Limit how many ItinerarioReservas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItinerarioReserva upsert
   */
  export type ItinerarioReservaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaInclude<ExtArgs> | null
    /**
     * The filter to search for the ItinerarioReserva to update in case it exists.
     */
    where: ItinerarioReservaWhereUniqueInput
    /**
     * In case the ItinerarioReserva found by the `where` argument doesn't exist, create a new ItinerarioReserva with this data.
     */
    create: XOR<ItinerarioReservaCreateInput, ItinerarioReservaUncheckedCreateInput>
    /**
     * In case the ItinerarioReserva was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItinerarioReservaUpdateInput, ItinerarioReservaUncheckedUpdateInput>
  }

  /**
   * ItinerarioReserva delete
   */
  export type ItinerarioReservaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaInclude<ExtArgs> | null
    /**
     * Filter which ItinerarioReserva to delete.
     */
    where: ItinerarioReservaWhereUniqueInput
  }

  /**
   * ItinerarioReserva deleteMany
   */
  export type ItinerarioReservaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItinerarioReservas to delete
     */
    where?: ItinerarioReservaWhereInput
    /**
     * Limit how many ItinerarioReservas to delete.
     */
    limit?: number
  }

  /**
   * ItinerarioReserva.itinerarioLugares
   */
  export type ItinerarioReserva$itinerarioLugaresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarInclude<ExtArgs> | null
    where?: ItinerarioLugarWhereInput
    orderBy?: ItinerarioLugarOrderByWithRelationInput | ItinerarioLugarOrderByWithRelationInput[]
    cursor?: ItinerarioLugarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItinerarioLugarScalarFieldEnum | ItinerarioLugarScalarFieldEnum[]
  }

  /**
   * ItinerarioReserva.servicio
   */
  export type ItinerarioReserva$servicioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Servicio
     */
    select?: ServicioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Servicio
     */
    omit?: ServicioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicioInclude<ExtArgs> | null
    where?: ServicioWhereInput
  }

  /**
   * ItinerarioReserva without action
   */
  export type ItinerarioReservaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioReserva
     */
    select?: ItinerarioReservaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioReserva
     */
    omit?: ItinerarioReservaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioReservaInclude<ExtArgs> | null
  }


  /**
   * Model ItinerarioLugar
   */

  export type AggregateItinerarioLugar = {
    _count: ItinerarioLugarCountAggregateOutputType | null
    _avg: ItinerarioLugarAvgAggregateOutputType | null
    _sum: ItinerarioLugarSumAggregateOutputType | null
    _min: ItinerarioLugarMinAggregateOutputType | null
    _max: ItinerarioLugarMaxAggregateOutputType | null
  }

  export type ItinerarioLugarAvgAggregateOutputType = {
    id: number | null
    itinerarioReservaId: number | null
    lugarTuristicoId: number | null
  }

  export type ItinerarioLugarSumAggregateOutputType = {
    id: number | null
    itinerarioReservaId: number | null
    lugarTuristicoId: number | null
  }

  export type ItinerarioLugarMinAggregateOutputType = {
    id: number | null
    itinerarioReservaId: number | null
    lugarTuristicoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItinerarioLugarMaxAggregateOutputType = {
    id: number | null
    itinerarioReservaId: number | null
    lugarTuristicoId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItinerarioLugarCountAggregateOutputType = {
    id: number
    itinerarioReservaId: number
    lugarTuristicoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItinerarioLugarAvgAggregateInputType = {
    id?: true
    itinerarioReservaId?: true
    lugarTuristicoId?: true
  }

  export type ItinerarioLugarSumAggregateInputType = {
    id?: true
    itinerarioReservaId?: true
    lugarTuristicoId?: true
  }

  export type ItinerarioLugarMinAggregateInputType = {
    id?: true
    itinerarioReservaId?: true
    lugarTuristicoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItinerarioLugarMaxAggregateInputType = {
    id?: true
    itinerarioReservaId?: true
    lugarTuristicoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItinerarioLugarCountAggregateInputType = {
    id?: true
    itinerarioReservaId?: true
    lugarTuristicoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItinerarioLugarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItinerarioLugar to aggregate.
     */
    where?: ItinerarioLugarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItinerarioLugars to fetch.
     */
    orderBy?: ItinerarioLugarOrderByWithRelationInput | ItinerarioLugarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItinerarioLugarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItinerarioLugars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItinerarioLugars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ItinerarioLugars
    **/
    _count?: true | ItinerarioLugarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItinerarioLugarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItinerarioLugarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItinerarioLugarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItinerarioLugarMaxAggregateInputType
  }

  export type GetItinerarioLugarAggregateType<T extends ItinerarioLugarAggregateArgs> = {
        [P in keyof T & keyof AggregateItinerarioLugar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItinerarioLugar[P]>
      : GetScalarType<T[P], AggregateItinerarioLugar[P]>
  }




  export type ItinerarioLugarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItinerarioLugarWhereInput
    orderBy?: ItinerarioLugarOrderByWithAggregationInput | ItinerarioLugarOrderByWithAggregationInput[]
    by: ItinerarioLugarScalarFieldEnum[] | ItinerarioLugarScalarFieldEnum
    having?: ItinerarioLugarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItinerarioLugarCountAggregateInputType | true
    _avg?: ItinerarioLugarAvgAggregateInputType
    _sum?: ItinerarioLugarSumAggregateInputType
    _min?: ItinerarioLugarMinAggregateInputType
    _max?: ItinerarioLugarMaxAggregateInputType
  }

  export type ItinerarioLugarGroupByOutputType = {
    id: number
    itinerarioReservaId: number
    lugarTuristicoId: number
    createdAt: Date
    updatedAt: Date
    _count: ItinerarioLugarCountAggregateOutputType | null
    _avg: ItinerarioLugarAvgAggregateOutputType | null
    _sum: ItinerarioLugarSumAggregateOutputType | null
    _min: ItinerarioLugarMinAggregateOutputType | null
    _max: ItinerarioLugarMaxAggregateOutputType | null
  }

  type GetItinerarioLugarGroupByPayload<T extends ItinerarioLugarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItinerarioLugarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItinerarioLugarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItinerarioLugarGroupByOutputType[P]>
            : GetScalarType<T[P], ItinerarioLugarGroupByOutputType[P]>
        }
      >
    >


  export type ItinerarioLugarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itinerarioReservaId?: boolean
    lugarTuristicoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itinerarioReserva?: boolean | ItinerarioReservaDefaultArgs<ExtArgs>
    lugarTuristico?: boolean | LugarTuristicoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerarioLugar"]>

  export type ItinerarioLugarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itinerarioReservaId?: boolean
    lugarTuristicoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itinerarioReserva?: boolean | ItinerarioReservaDefaultArgs<ExtArgs>
    lugarTuristico?: boolean | LugarTuristicoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerarioLugar"]>

  export type ItinerarioLugarSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itinerarioReservaId?: boolean
    lugarTuristicoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    itinerarioReserva?: boolean | ItinerarioReservaDefaultArgs<ExtArgs>
    lugarTuristico?: boolean | LugarTuristicoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["itinerarioLugar"]>

  export type ItinerarioLugarSelectScalar = {
    id?: boolean
    itinerarioReservaId?: boolean
    lugarTuristicoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItinerarioLugarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "itinerarioReservaId" | "lugarTuristicoId" | "createdAt" | "updatedAt", ExtArgs["result"]["itinerarioLugar"]>
  export type ItinerarioLugarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerarioReserva?: boolean | ItinerarioReservaDefaultArgs<ExtArgs>
    lugarTuristico?: boolean | LugarTuristicoDefaultArgs<ExtArgs>
  }
  export type ItinerarioLugarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerarioReserva?: boolean | ItinerarioReservaDefaultArgs<ExtArgs>
    lugarTuristico?: boolean | LugarTuristicoDefaultArgs<ExtArgs>
  }
  export type ItinerarioLugarIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    itinerarioReserva?: boolean | ItinerarioReservaDefaultArgs<ExtArgs>
    lugarTuristico?: boolean | LugarTuristicoDefaultArgs<ExtArgs>
  }

  export type $ItinerarioLugarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ItinerarioLugar"
    objects: {
      itinerarioReserva: Prisma.$ItinerarioReservaPayload<ExtArgs>
      lugarTuristico: Prisma.$LugarTuristicoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      itinerarioReservaId: number
      lugarTuristicoId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["itinerarioLugar"]>
    composites: {}
  }

  type ItinerarioLugarGetPayload<S extends boolean | null | undefined | ItinerarioLugarDefaultArgs> = $Result.GetResult<Prisma.$ItinerarioLugarPayload, S>

  type ItinerarioLugarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ItinerarioLugarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ItinerarioLugarCountAggregateInputType | true
    }

  export interface ItinerarioLugarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ItinerarioLugar'], meta: { name: 'ItinerarioLugar' } }
    /**
     * Find zero or one ItinerarioLugar that matches the filter.
     * @param {ItinerarioLugarFindUniqueArgs} args - Arguments to find a ItinerarioLugar
     * @example
     * // Get one ItinerarioLugar
     * const itinerarioLugar = await prisma.itinerarioLugar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItinerarioLugarFindUniqueArgs>(args: SelectSubset<T, ItinerarioLugarFindUniqueArgs<ExtArgs>>): Prisma__ItinerarioLugarClient<$Result.GetResult<Prisma.$ItinerarioLugarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ItinerarioLugar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ItinerarioLugarFindUniqueOrThrowArgs} args - Arguments to find a ItinerarioLugar
     * @example
     * // Get one ItinerarioLugar
     * const itinerarioLugar = await prisma.itinerarioLugar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItinerarioLugarFindUniqueOrThrowArgs>(args: SelectSubset<T, ItinerarioLugarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItinerarioLugarClient<$Result.GetResult<Prisma.$ItinerarioLugarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItinerarioLugar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioLugarFindFirstArgs} args - Arguments to find a ItinerarioLugar
     * @example
     * // Get one ItinerarioLugar
     * const itinerarioLugar = await prisma.itinerarioLugar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItinerarioLugarFindFirstArgs>(args?: SelectSubset<T, ItinerarioLugarFindFirstArgs<ExtArgs>>): Prisma__ItinerarioLugarClient<$Result.GetResult<Prisma.$ItinerarioLugarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ItinerarioLugar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioLugarFindFirstOrThrowArgs} args - Arguments to find a ItinerarioLugar
     * @example
     * // Get one ItinerarioLugar
     * const itinerarioLugar = await prisma.itinerarioLugar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItinerarioLugarFindFirstOrThrowArgs>(args?: SelectSubset<T, ItinerarioLugarFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItinerarioLugarClient<$Result.GetResult<Prisma.$ItinerarioLugarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ItinerarioLugars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioLugarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ItinerarioLugars
     * const itinerarioLugars = await prisma.itinerarioLugar.findMany()
     * 
     * // Get first 10 ItinerarioLugars
     * const itinerarioLugars = await prisma.itinerarioLugar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itinerarioLugarWithIdOnly = await prisma.itinerarioLugar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItinerarioLugarFindManyArgs>(args?: SelectSubset<T, ItinerarioLugarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItinerarioLugarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ItinerarioLugar.
     * @param {ItinerarioLugarCreateArgs} args - Arguments to create a ItinerarioLugar.
     * @example
     * // Create one ItinerarioLugar
     * const ItinerarioLugar = await prisma.itinerarioLugar.create({
     *   data: {
     *     // ... data to create a ItinerarioLugar
     *   }
     * })
     * 
     */
    create<T extends ItinerarioLugarCreateArgs>(args: SelectSubset<T, ItinerarioLugarCreateArgs<ExtArgs>>): Prisma__ItinerarioLugarClient<$Result.GetResult<Prisma.$ItinerarioLugarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ItinerarioLugars.
     * @param {ItinerarioLugarCreateManyArgs} args - Arguments to create many ItinerarioLugars.
     * @example
     * // Create many ItinerarioLugars
     * const itinerarioLugar = await prisma.itinerarioLugar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItinerarioLugarCreateManyArgs>(args?: SelectSubset<T, ItinerarioLugarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ItinerarioLugars and returns the data saved in the database.
     * @param {ItinerarioLugarCreateManyAndReturnArgs} args - Arguments to create many ItinerarioLugars.
     * @example
     * // Create many ItinerarioLugars
     * const itinerarioLugar = await prisma.itinerarioLugar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ItinerarioLugars and only return the `id`
     * const itinerarioLugarWithIdOnly = await prisma.itinerarioLugar.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItinerarioLugarCreateManyAndReturnArgs>(args?: SelectSubset<T, ItinerarioLugarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItinerarioLugarPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ItinerarioLugar.
     * @param {ItinerarioLugarDeleteArgs} args - Arguments to delete one ItinerarioLugar.
     * @example
     * // Delete one ItinerarioLugar
     * const ItinerarioLugar = await prisma.itinerarioLugar.delete({
     *   where: {
     *     // ... filter to delete one ItinerarioLugar
     *   }
     * })
     * 
     */
    delete<T extends ItinerarioLugarDeleteArgs>(args: SelectSubset<T, ItinerarioLugarDeleteArgs<ExtArgs>>): Prisma__ItinerarioLugarClient<$Result.GetResult<Prisma.$ItinerarioLugarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ItinerarioLugar.
     * @param {ItinerarioLugarUpdateArgs} args - Arguments to update one ItinerarioLugar.
     * @example
     * // Update one ItinerarioLugar
     * const itinerarioLugar = await prisma.itinerarioLugar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItinerarioLugarUpdateArgs>(args: SelectSubset<T, ItinerarioLugarUpdateArgs<ExtArgs>>): Prisma__ItinerarioLugarClient<$Result.GetResult<Prisma.$ItinerarioLugarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ItinerarioLugars.
     * @param {ItinerarioLugarDeleteManyArgs} args - Arguments to filter ItinerarioLugars to delete.
     * @example
     * // Delete a few ItinerarioLugars
     * const { count } = await prisma.itinerarioLugar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItinerarioLugarDeleteManyArgs>(args?: SelectSubset<T, ItinerarioLugarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItinerarioLugars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioLugarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ItinerarioLugars
     * const itinerarioLugar = await prisma.itinerarioLugar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItinerarioLugarUpdateManyArgs>(args: SelectSubset<T, ItinerarioLugarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ItinerarioLugars and returns the data updated in the database.
     * @param {ItinerarioLugarUpdateManyAndReturnArgs} args - Arguments to update many ItinerarioLugars.
     * @example
     * // Update many ItinerarioLugars
     * const itinerarioLugar = await prisma.itinerarioLugar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ItinerarioLugars and only return the `id`
     * const itinerarioLugarWithIdOnly = await prisma.itinerarioLugar.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ItinerarioLugarUpdateManyAndReturnArgs>(args: SelectSubset<T, ItinerarioLugarUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItinerarioLugarPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ItinerarioLugar.
     * @param {ItinerarioLugarUpsertArgs} args - Arguments to update or create a ItinerarioLugar.
     * @example
     * // Update or create a ItinerarioLugar
     * const itinerarioLugar = await prisma.itinerarioLugar.upsert({
     *   create: {
     *     // ... data to create a ItinerarioLugar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ItinerarioLugar we want to update
     *   }
     * })
     */
    upsert<T extends ItinerarioLugarUpsertArgs>(args: SelectSubset<T, ItinerarioLugarUpsertArgs<ExtArgs>>): Prisma__ItinerarioLugarClient<$Result.GetResult<Prisma.$ItinerarioLugarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ItinerarioLugars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioLugarCountArgs} args - Arguments to filter ItinerarioLugars to count.
     * @example
     * // Count the number of ItinerarioLugars
     * const count = await prisma.itinerarioLugar.count({
     *   where: {
     *     // ... the filter for the ItinerarioLugars we want to count
     *   }
     * })
    **/
    count<T extends ItinerarioLugarCountArgs>(
      args?: Subset<T, ItinerarioLugarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItinerarioLugarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ItinerarioLugar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioLugarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItinerarioLugarAggregateArgs>(args: Subset<T, ItinerarioLugarAggregateArgs>): Prisma.PrismaPromise<GetItinerarioLugarAggregateType<T>>

    /**
     * Group by ItinerarioLugar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItinerarioLugarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItinerarioLugarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItinerarioLugarGroupByArgs['orderBy'] }
        : { orderBy?: ItinerarioLugarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItinerarioLugarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItinerarioLugarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ItinerarioLugar model
   */
  readonly fields: ItinerarioLugarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ItinerarioLugar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItinerarioLugarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    itinerarioReserva<T extends ItinerarioReservaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItinerarioReservaDefaultArgs<ExtArgs>>): Prisma__ItinerarioReservaClient<$Result.GetResult<Prisma.$ItinerarioReservaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lugarTuristico<T extends LugarTuristicoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LugarTuristicoDefaultArgs<ExtArgs>>): Prisma__LugarTuristicoClient<$Result.GetResult<Prisma.$LugarTuristicoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ItinerarioLugar model
   */
  interface ItinerarioLugarFieldRefs {
    readonly id: FieldRef<"ItinerarioLugar", 'Int'>
    readonly itinerarioReservaId: FieldRef<"ItinerarioLugar", 'Int'>
    readonly lugarTuristicoId: FieldRef<"ItinerarioLugar", 'Int'>
    readonly createdAt: FieldRef<"ItinerarioLugar", 'DateTime'>
    readonly updatedAt: FieldRef<"ItinerarioLugar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ItinerarioLugar findUnique
   */
  export type ItinerarioLugarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarInclude<ExtArgs> | null
    /**
     * Filter, which ItinerarioLugar to fetch.
     */
    where: ItinerarioLugarWhereUniqueInput
  }

  /**
   * ItinerarioLugar findUniqueOrThrow
   */
  export type ItinerarioLugarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarInclude<ExtArgs> | null
    /**
     * Filter, which ItinerarioLugar to fetch.
     */
    where: ItinerarioLugarWhereUniqueInput
  }

  /**
   * ItinerarioLugar findFirst
   */
  export type ItinerarioLugarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarInclude<ExtArgs> | null
    /**
     * Filter, which ItinerarioLugar to fetch.
     */
    where?: ItinerarioLugarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItinerarioLugars to fetch.
     */
    orderBy?: ItinerarioLugarOrderByWithRelationInput | ItinerarioLugarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItinerarioLugars.
     */
    cursor?: ItinerarioLugarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItinerarioLugars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItinerarioLugars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItinerarioLugars.
     */
    distinct?: ItinerarioLugarScalarFieldEnum | ItinerarioLugarScalarFieldEnum[]
  }

  /**
   * ItinerarioLugar findFirstOrThrow
   */
  export type ItinerarioLugarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarInclude<ExtArgs> | null
    /**
     * Filter, which ItinerarioLugar to fetch.
     */
    where?: ItinerarioLugarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItinerarioLugars to fetch.
     */
    orderBy?: ItinerarioLugarOrderByWithRelationInput | ItinerarioLugarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ItinerarioLugars.
     */
    cursor?: ItinerarioLugarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItinerarioLugars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItinerarioLugars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ItinerarioLugars.
     */
    distinct?: ItinerarioLugarScalarFieldEnum | ItinerarioLugarScalarFieldEnum[]
  }

  /**
   * ItinerarioLugar findMany
   */
  export type ItinerarioLugarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarInclude<ExtArgs> | null
    /**
     * Filter, which ItinerarioLugars to fetch.
     */
    where?: ItinerarioLugarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ItinerarioLugars to fetch.
     */
    orderBy?: ItinerarioLugarOrderByWithRelationInput | ItinerarioLugarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ItinerarioLugars.
     */
    cursor?: ItinerarioLugarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ItinerarioLugars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ItinerarioLugars.
     */
    skip?: number
    distinct?: ItinerarioLugarScalarFieldEnum | ItinerarioLugarScalarFieldEnum[]
  }

  /**
   * ItinerarioLugar create
   */
  export type ItinerarioLugarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarInclude<ExtArgs> | null
    /**
     * The data needed to create a ItinerarioLugar.
     */
    data: XOR<ItinerarioLugarCreateInput, ItinerarioLugarUncheckedCreateInput>
  }

  /**
   * ItinerarioLugar createMany
   */
  export type ItinerarioLugarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ItinerarioLugars.
     */
    data: ItinerarioLugarCreateManyInput | ItinerarioLugarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ItinerarioLugar createManyAndReturn
   */
  export type ItinerarioLugarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * The data used to create many ItinerarioLugars.
     */
    data: ItinerarioLugarCreateManyInput | ItinerarioLugarCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItinerarioLugar update
   */
  export type ItinerarioLugarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarInclude<ExtArgs> | null
    /**
     * The data needed to update a ItinerarioLugar.
     */
    data: XOR<ItinerarioLugarUpdateInput, ItinerarioLugarUncheckedUpdateInput>
    /**
     * Choose, which ItinerarioLugar to update.
     */
    where: ItinerarioLugarWhereUniqueInput
  }

  /**
   * ItinerarioLugar updateMany
   */
  export type ItinerarioLugarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ItinerarioLugars.
     */
    data: XOR<ItinerarioLugarUpdateManyMutationInput, ItinerarioLugarUncheckedUpdateManyInput>
    /**
     * Filter which ItinerarioLugars to update
     */
    where?: ItinerarioLugarWhereInput
    /**
     * Limit how many ItinerarioLugars to update.
     */
    limit?: number
  }

  /**
   * ItinerarioLugar updateManyAndReturn
   */
  export type ItinerarioLugarUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * The data used to update ItinerarioLugars.
     */
    data: XOR<ItinerarioLugarUpdateManyMutationInput, ItinerarioLugarUncheckedUpdateManyInput>
    /**
     * Filter which ItinerarioLugars to update
     */
    where?: ItinerarioLugarWhereInput
    /**
     * Limit how many ItinerarioLugars to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ItinerarioLugar upsert
   */
  export type ItinerarioLugarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarInclude<ExtArgs> | null
    /**
     * The filter to search for the ItinerarioLugar to update in case it exists.
     */
    where: ItinerarioLugarWhereUniqueInput
    /**
     * In case the ItinerarioLugar found by the `where` argument doesn't exist, create a new ItinerarioLugar with this data.
     */
    create: XOR<ItinerarioLugarCreateInput, ItinerarioLugarUncheckedCreateInput>
    /**
     * In case the ItinerarioLugar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItinerarioLugarUpdateInput, ItinerarioLugarUncheckedUpdateInput>
  }

  /**
   * ItinerarioLugar delete
   */
  export type ItinerarioLugarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarInclude<ExtArgs> | null
    /**
     * Filter which ItinerarioLugar to delete.
     */
    where: ItinerarioLugarWhereUniqueInput
  }

  /**
   * ItinerarioLugar deleteMany
   */
  export type ItinerarioLugarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ItinerarioLugars to delete
     */
    where?: ItinerarioLugarWhereInput
    /**
     * Limit how many ItinerarioLugars to delete.
     */
    limit?: number
  }

  /**
   * ItinerarioLugar without action
   */
  export type ItinerarioLugarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItinerarioLugar
     */
    select?: ItinerarioLugarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ItinerarioLugar
     */
    omit?: ItinerarioLugarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItinerarioLugarInclude<ExtArgs> | null
  }


  /**
   * Model Pago
   */

  export type AggregatePago = {
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  export type PagoAvgAggregateOutputType = {
    id: number | null
    reservaId: number | null
    montoTotal: Decimal | null
  }

  export type PagoSumAggregateOutputType = {
    id: number | null
    reservaId: number | null
    montoTotal: Decimal | null
  }

  export type PagoMinAggregateOutputType = {
    id: number | null
    reservaId: number | null
    codigoTransaccion: string | null
    montoTotal: Decimal | null
    moneda: string | null
    estado: string | null
    fechaPago: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PagoMaxAggregateOutputType = {
    id: number | null
    reservaId: number | null
    codigoTransaccion: string | null
    montoTotal: Decimal | null
    moneda: string | null
    estado: string | null
    fechaPago: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PagoCountAggregateOutputType = {
    id: number
    reservaId: number
    codigoTransaccion: number
    montoTotal: number
    moneda: number
    estado: number
    fechaPago: number
    datosMetodoPago: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PagoAvgAggregateInputType = {
    id?: true
    reservaId?: true
    montoTotal?: true
  }

  export type PagoSumAggregateInputType = {
    id?: true
    reservaId?: true
    montoTotal?: true
  }

  export type PagoMinAggregateInputType = {
    id?: true
    reservaId?: true
    codigoTransaccion?: true
    montoTotal?: true
    moneda?: true
    estado?: true
    fechaPago?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PagoMaxAggregateInputType = {
    id?: true
    reservaId?: true
    codigoTransaccion?: true
    montoTotal?: true
    moneda?: true
    estado?: true
    fechaPago?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PagoCountAggregateInputType = {
    id?: true
    reservaId?: true
    codigoTransaccion?: true
    montoTotal?: true
    moneda?: true
    estado?: true
    fechaPago?: true
    datosMetodoPago?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PagoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pago to aggregate.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pagos
    **/
    _count?: true | PagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagoMaxAggregateInputType
  }

  export type GetPagoAggregateType<T extends PagoAggregateArgs> = {
        [P in keyof T & keyof AggregatePago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePago[P]>
      : GetScalarType<T[P], AggregatePago[P]>
  }




  export type PagoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoWhereInput
    orderBy?: PagoOrderByWithAggregationInput | PagoOrderByWithAggregationInput[]
    by: PagoScalarFieldEnum[] | PagoScalarFieldEnum
    having?: PagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagoCountAggregateInputType | true
    _avg?: PagoAvgAggregateInputType
    _sum?: PagoSumAggregateInputType
    _min?: PagoMinAggregateInputType
    _max?: PagoMaxAggregateInputType
  }

  export type PagoGroupByOutputType = {
    id: number
    reservaId: number
    codigoTransaccion: string | null
    montoTotal: Decimal
    moneda: string
    estado: string
    fechaPago: Date | null
    datosMetodoPago: JsonValue | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PagoCountAggregateOutputType | null
    _avg: PagoAvgAggregateOutputType | null
    _sum: PagoSumAggregateOutputType | null
    _min: PagoMinAggregateOutputType | null
    _max: PagoMaxAggregateOutputType | null
  }

  type GetPagoGroupByPayload<T extends PagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagoGroupByOutputType[P]>
            : GetScalarType<T[P], PagoGroupByOutputType[P]>
        }
      >
    >


  export type PagoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reservaId?: boolean
    codigoTransaccion?: boolean
    montoTotal?: boolean
    moneda?: boolean
    estado?: boolean
    fechaPago?: boolean
    datosMetodoPago?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comprobante?: boolean | Pago$comprobanteArgs<ExtArgs>
    reserva?: boolean | ReservaDefaultArgs<ExtArgs>
    detalles?: boolean | Pago$detallesArgs<ExtArgs>
    _count?: boolean | PagoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type PagoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reservaId?: boolean
    codigoTransaccion?: boolean
    montoTotal?: boolean
    moneda?: boolean
    estado?: boolean
    fechaPago?: boolean
    datosMetodoPago?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reserva?: boolean | ReservaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type PagoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reservaId?: boolean
    codigoTransaccion?: boolean
    montoTotal?: boolean
    moneda?: boolean
    estado?: boolean
    fechaPago?: boolean
    datosMetodoPago?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reserva?: boolean | ReservaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pago"]>

  export type PagoSelectScalar = {
    id?: boolean
    reservaId?: boolean
    codigoTransaccion?: boolean
    montoTotal?: boolean
    moneda?: boolean
    estado?: boolean
    fechaPago?: boolean
    datosMetodoPago?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PagoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reservaId" | "codigoTransaccion" | "montoTotal" | "moneda" | "estado" | "fechaPago" | "datosMetodoPago" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["pago"]>
  export type PagoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comprobante?: boolean | Pago$comprobanteArgs<ExtArgs>
    reserva?: boolean | ReservaDefaultArgs<ExtArgs>
    detalles?: boolean | Pago$detallesArgs<ExtArgs>
    _count?: boolean | PagoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PagoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reserva?: boolean | ReservaDefaultArgs<ExtArgs>
  }
  export type PagoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reserva?: boolean | ReservaDefaultArgs<ExtArgs>
  }

  export type $PagoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pago"
    objects: {
      comprobante: Prisma.$ComprobantePayload<ExtArgs> | null
      reserva: Prisma.$ReservaPayload<ExtArgs>
      detalles: Prisma.$PagoDetallePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reservaId: number
      codigoTransaccion: string | null
      montoTotal: Prisma.Decimal
      moneda: string
      estado: string
      fechaPago: Date | null
      datosMetodoPago: Prisma.JsonValue | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pago"]>
    composites: {}
  }

  type PagoGetPayload<S extends boolean | null | undefined | PagoDefaultArgs> = $Result.GetResult<Prisma.$PagoPayload, S>

  type PagoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PagoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PagoCountAggregateInputType | true
    }

  export interface PagoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pago'], meta: { name: 'Pago' } }
    /**
     * Find zero or one Pago that matches the filter.
     * @param {PagoFindUniqueArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagoFindUniqueArgs>(args: SelectSubset<T, PagoFindUniqueArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pago that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PagoFindUniqueOrThrowArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagoFindUniqueOrThrowArgs>(args: SelectSubset<T, PagoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoFindFirstArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagoFindFirstArgs>(args?: SelectSubset<T, PagoFindFirstArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pago that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoFindFirstOrThrowArgs} args - Arguments to find a Pago
     * @example
     * // Get one Pago
     * const pago = await prisma.pago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagoFindFirstOrThrowArgs>(args?: SelectSubset<T, PagoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagos
     * const pagos = await prisma.pago.findMany()
     * 
     * // Get first 10 Pagos
     * const pagos = await prisma.pago.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagoWithIdOnly = await prisma.pago.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagoFindManyArgs>(args?: SelectSubset<T, PagoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pago.
     * @param {PagoCreateArgs} args - Arguments to create a Pago.
     * @example
     * // Create one Pago
     * const Pago = await prisma.pago.create({
     *   data: {
     *     // ... data to create a Pago
     *   }
     * })
     * 
     */
    create<T extends PagoCreateArgs>(args: SelectSubset<T, PagoCreateArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pagos.
     * @param {PagoCreateManyArgs} args - Arguments to create many Pagos.
     * @example
     * // Create many Pagos
     * const pago = await prisma.pago.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagoCreateManyArgs>(args?: SelectSubset<T, PagoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pagos and returns the data saved in the database.
     * @param {PagoCreateManyAndReturnArgs} args - Arguments to create many Pagos.
     * @example
     * // Create many Pagos
     * const pago = await prisma.pago.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pagos and only return the `id`
     * const pagoWithIdOnly = await prisma.pago.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PagoCreateManyAndReturnArgs>(args?: SelectSubset<T, PagoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pago.
     * @param {PagoDeleteArgs} args - Arguments to delete one Pago.
     * @example
     * // Delete one Pago
     * const Pago = await prisma.pago.delete({
     *   where: {
     *     // ... filter to delete one Pago
     *   }
     * })
     * 
     */
    delete<T extends PagoDeleteArgs>(args: SelectSubset<T, PagoDeleteArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pago.
     * @param {PagoUpdateArgs} args - Arguments to update one Pago.
     * @example
     * // Update one Pago
     * const pago = await prisma.pago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagoUpdateArgs>(args: SelectSubset<T, PagoUpdateArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pagos.
     * @param {PagoDeleteManyArgs} args - Arguments to filter Pagos to delete.
     * @example
     * // Delete a few Pagos
     * const { count } = await prisma.pago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagoDeleteManyArgs>(args?: SelectSubset<T, PagoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagos
     * const pago = await prisma.pago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagoUpdateManyArgs>(args: SelectSubset<T, PagoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagos and returns the data updated in the database.
     * @param {PagoUpdateManyAndReturnArgs} args - Arguments to update many Pagos.
     * @example
     * // Update many Pagos
     * const pago = await prisma.pago.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pagos and only return the `id`
     * const pagoWithIdOnly = await prisma.pago.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PagoUpdateManyAndReturnArgs>(args: SelectSubset<T, PagoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pago.
     * @param {PagoUpsertArgs} args - Arguments to update or create a Pago.
     * @example
     * // Update or create a Pago
     * const pago = await prisma.pago.upsert({
     *   create: {
     *     // ... data to create a Pago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pago we want to update
     *   }
     * })
     */
    upsert<T extends PagoUpsertArgs>(args: SelectSubset<T, PagoUpsertArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoCountArgs} args - Arguments to filter Pagos to count.
     * @example
     * // Count the number of Pagos
     * const count = await prisma.pago.count({
     *   where: {
     *     // ... the filter for the Pagos we want to count
     *   }
     * })
    **/
    count<T extends PagoCountArgs>(
      args?: Subset<T, PagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagoAggregateArgs>(args: Subset<T, PagoAggregateArgs>): Prisma.PrismaPromise<GetPagoAggregateType<T>>

    /**
     * Group by Pago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagoGroupByArgs['orderBy'] }
        : { orderBy?: PagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pago model
   */
  readonly fields: PagoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comprobante<T extends Pago$comprobanteArgs<ExtArgs> = {}>(args?: Subset<T, Pago$comprobanteArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reserva<T extends ReservaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReservaDefaultArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    detalles<T extends Pago$detallesArgs<ExtArgs> = {}>(args?: Subset<T, Pago$detallesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoDetallePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pago model
   */
  interface PagoFieldRefs {
    readonly id: FieldRef<"Pago", 'Int'>
    readonly reservaId: FieldRef<"Pago", 'Int'>
    readonly codigoTransaccion: FieldRef<"Pago", 'String'>
    readonly montoTotal: FieldRef<"Pago", 'Decimal'>
    readonly moneda: FieldRef<"Pago", 'String'>
    readonly estado: FieldRef<"Pago", 'String'>
    readonly fechaPago: FieldRef<"Pago", 'DateTime'>
    readonly datosMetodoPago: FieldRef<"Pago", 'Json'>
    readonly metadata: FieldRef<"Pago", 'Json'>
    readonly createdAt: FieldRef<"Pago", 'DateTime'>
    readonly updatedAt: FieldRef<"Pago", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pago findUnique
   */
  export type PagoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago findUniqueOrThrow
   */
  export type PagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago findFirst
   */
  export type PagoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagos.
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagos.
     */
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Pago findFirstOrThrow
   */
  export type PagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pago to fetch.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagos.
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagos.
     */
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Pago findMany
   */
  export type PagoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter, which Pagos to fetch.
     */
    where?: PagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagos to fetch.
     */
    orderBy?: PagoOrderByWithRelationInput | PagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pagos.
     */
    cursor?: PagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagos.
     */
    skip?: number
    distinct?: PagoScalarFieldEnum | PagoScalarFieldEnum[]
  }

  /**
   * Pago create
   */
  export type PagoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pago.
     */
    data: XOR<PagoCreateInput, PagoUncheckedCreateInput>
  }

  /**
   * Pago createMany
   */
  export type PagoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pagos.
     */
    data: PagoCreateManyInput | PagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pago createManyAndReturn
   */
  export type PagoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * The data used to create many Pagos.
     */
    data: PagoCreateManyInput | PagoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pago update
   */
  export type PagoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pago.
     */
    data: XOR<PagoUpdateInput, PagoUncheckedUpdateInput>
    /**
     * Choose, which Pago to update.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago updateMany
   */
  export type PagoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pagos.
     */
    data: XOR<PagoUpdateManyMutationInput, PagoUncheckedUpdateManyInput>
    /**
     * Filter which Pagos to update
     */
    where?: PagoWhereInput
    /**
     * Limit how many Pagos to update.
     */
    limit?: number
  }

  /**
   * Pago updateManyAndReturn
   */
  export type PagoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * The data used to update Pagos.
     */
    data: XOR<PagoUpdateManyMutationInput, PagoUncheckedUpdateManyInput>
    /**
     * Filter which Pagos to update
     */
    where?: PagoWhereInput
    /**
     * Limit how many Pagos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pago upsert
   */
  export type PagoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pago to update in case it exists.
     */
    where: PagoWhereUniqueInput
    /**
     * In case the Pago found by the `where` argument doesn't exist, create a new Pago with this data.
     */
    create: XOR<PagoCreateInput, PagoUncheckedCreateInput>
    /**
     * In case the Pago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagoUpdateInput, PagoUncheckedUpdateInput>
  }

  /**
   * Pago delete
   */
  export type PagoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
    /**
     * Filter which Pago to delete.
     */
    where: PagoWhereUniqueInput
  }

  /**
   * Pago deleteMany
   */
  export type PagoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagos to delete
     */
    where?: PagoWhereInput
    /**
     * Limit how many Pagos to delete.
     */
    limit?: number
  }

  /**
   * Pago.comprobante
   */
  export type Pago$comprobanteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comprobante
     */
    omit?: ComprobanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    where?: ComprobanteWhereInput
  }

  /**
   * Pago.detalles
   */
  export type Pago$detallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleInclude<ExtArgs> | null
    where?: PagoDetalleWhereInput
    orderBy?: PagoDetalleOrderByWithRelationInput | PagoDetalleOrderByWithRelationInput[]
    cursor?: PagoDetalleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoDetalleScalarFieldEnum | PagoDetalleScalarFieldEnum[]
  }

  /**
   * Pago without action
   */
  export type PagoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pago
     */
    select?: PagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pago
     */
    omit?: PagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoInclude<ExtArgs> | null
  }


  /**
   * Model PagoDetalle
   */

  export type AggregatePagoDetalle = {
    _count: PagoDetalleCountAggregateOutputType | null
    _avg: PagoDetalleAvgAggregateOutputType | null
    _sum: PagoDetalleSumAggregateOutputType | null
    _min: PagoDetalleMinAggregateOutputType | null
    _max: PagoDetalleMaxAggregateOutputType | null
  }

  export type PagoDetalleAvgAggregateOutputType = {
    id: number | null
    pagoId: number | null
    tipoPagoId: number | null
    monto: Decimal | null
    porcentajeImpuesto: Decimal | null
    cantidad: number | null
  }

  export type PagoDetalleSumAggregateOutputType = {
    id: number | null
    pagoId: number | null
    tipoPagoId: number | null
    monto: Decimal | null
    porcentajeImpuesto: Decimal | null
    cantidad: number | null
  }

  export type PagoDetalleMinAggregateOutputType = {
    id: number | null
    pagoId: number | null
    tipoPagoId: number | null
    concepto: string | null
    monto: Decimal | null
    porcentajeImpuesto: Decimal | null
    cantidad: number | null
    descripcion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PagoDetalleMaxAggregateOutputType = {
    id: number | null
    pagoId: number | null
    tipoPagoId: number | null
    concepto: string | null
    monto: Decimal | null
    porcentajeImpuesto: Decimal | null
    cantidad: number | null
    descripcion: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PagoDetalleCountAggregateOutputType = {
    id: number
    pagoId: number
    tipoPagoId: number
    concepto: number
    monto: number
    porcentajeImpuesto: number
    cantidad: number
    descripcion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PagoDetalleAvgAggregateInputType = {
    id?: true
    pagoId?: true
    tipoPagoId?: true
    monto?: true
    porcentajeImpuesto?: true
    cantidad?: true
  }

  export type PagoDetalleSumAggregateInputType = {
    id?: true
    pagoId?: true
    tipoPagoId?: true
    monto?: true
    porcentajeImpuesto?: true
    cantidad?: true
  }

  export type PagoDetalleMinAggregateInputType = {
    id?: true
    pagoId?: true
    tipoPagoId?: true
    concepto?: true
    monto?: true
    porcentajeImpuesto?: true
    cantidad?: true
    descripcion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PagoDetalleMaxAggregateInputType = {
    id?: true
    pagoId?: true
    tipoPagoId?: true
    concepto?: true
    monto?: true
    porcentajeImpuesto?: true
    cantidad?: true
    descripcion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PagoDetalleCountAggregateInputType = {
    id?: true
    pagoId?: true
    tipoPagoId?: true
    concepto?: true
    monto?: true
    porcentajeImpuesto?: true
    cantidad?: true
    descripcion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PagoDetalleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PagoDetalle to aggregate.
     */
    where?: PagoDetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagoDetalles to fetch.
     */
    orderBy?: PagoDetalleOrderByWithRelationInput | PagoDetalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagoDetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagoDetalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagoDetalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PagoDetalles
    **/
    _count?: true | PagoDetalleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagoDetalleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagoDetalleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagoDetalleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagoDetalleMaxAggregateInputType
  }

  export type GetPagoDetalleAggregateType<T extends PagoDetalleAggregateArgs> = {
        [P in keyof T & keyof AggregatePagoDetalle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagoDetalle[P]>
      : GetScalarType<T[P], AggregatePagoDetalle[P]>
  }




  export type PagoDetalleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagoDetalleWhereInput
    orderBy?: PagoDetalleOrderByWithAggregationInput | PagoDetalleOrderByWithAggregationInput[]
    by: PagoDetalleScalarFieldEnum[] | PagoDetalleScalarFieldEnum
    having?: PagoDetalleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagoDetalleCountAggregateInputType | true
    _avg?: PagoDetalleAvgAggregateInputType
    _sum?: PagoDetalleSumAggregateInputType
    _min?: PagoDetalleMinAggregateInputType
    _max?: PagoDetalleMaxAggregateInputType
  }

  export type PagoDetalleGroupByOutputType = {
    id: number
    pagoId: number
    tipoPagoId: number
    concepto: string
    monto: Decimal
    porcentajeImpuesto: Decimal
    cantidad: number
    descripcion: string | null
    createdAt: Date
    updatedAt: Date
    _count: PagoDetalleCountAggregateOutputType | null
    _avg: PagoDetalleAvgAggregateOutputType | null
    _sum: PagoDetalleSumAggregateOutputType | null
    _min: PagoDetalleMinAggregateOutputType | null
    _max: PagoDetalleMaxAggregateOutputType | null
  }

  type GetPagoDetalleGroupByPayload<T extends PagoDetalleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagoDetalleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagoDetalleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagoDetalleGroupByOutputType[P]>
            : GetScalarType<T[P], PagoDetalleGroupByOutputType[P]>
        }
      >
    >


  export type PagoDetalleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pagoId?: boolean
    tipoPagoId?: boolean
    concepto?: boolean
    monto?: boolean
    porcentajeImpuesto?: boolean
    cantidad?: boolean
    descripcion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pago?: boolean | PagoDefaultArgs<ExtArgs>
    tipoPago?: boolean | TipoPagoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagoDetalle"]>

  export type PagoDetalleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pagoId?: boolean
    tipoPagoId?: boolean
    concepto?: boolean
    monto?: boolean
    porcentajeImpuesto?: boolean
    cantidad?: boolean
    descripcion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pago?: boolean | PagoDefaultArgs<ExtArgs>
    tipoPago?: boolean | TipoPagoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagoDetalle"]>

  export type PagoDetalleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pagoId?: boolean
    tipoPagoId?: boolean
    concepto?: boolean
    monto?: boolean
    porcentajeImpuesto?: boolean
    cantidad?: boolean
    descripcion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pago?: boolean | PagoDefaultArgs<ExtArgs>
    tipoPago?: boolean | TipoPagoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagoDetalle"]>

  export type PagoDetalleSelectScalar = {
    id?: boolean
    pagoId?: boolean
    tipoPagoId?: boolean
    concepto?: boolean
    monto?: boolean
    porcentajeImpuesto?: boolean
    cantidad?: boolean
    descripcion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PagoDetalleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pagoId" | "tipoPagoId" | "concepto" | "monto" | "porcentajeImpuesto" | "cantidad" | "descripcion" | "createdAt" | "updatedAt", ExtArgs["result"]["pagoDetalle"]>
  export type PagoDetalleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pago?: boolean | PagoDefaultArgs<ExtArgs>
    tipoPago?: boolean | TipoPagoDefaultArgs<ExtArgs>
  }
  export type PagoDetalleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pago?: boolean | PagoDefaultArgs<ExtArgs>
    tipoPago?: boolean | TipoPagoDefaultArgs<ExtArgs>
  }
  export type PagoDetalleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pago?: boolean | PagoDefaultArgs<ExtArgs>
    tipoPago?: boolean | TipoPagoDefaultArgs<ExtArgs>
  }

  export type $PagoDetallePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PagoDetalle"
    objects: {
      pago: Prisma.$PagoPayload<ExtArgs>
      tipoPago: Prisma.$TipoPagoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pagoId: number
      tipoPagoId: number
      concepto: string
      monto: Prisma.Decimal
      porcentajeImpuesto: Prisma.Decimal
      cantidad: number
      descripcion: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pagoDetalle"]>
    composites: {}
  }

  type PagoDetalleGetPayload<S extends boolean | null | undefined | PagoDetalleDefaultArgs> = $Result.GetResult<Prisma.$PagoDetallePayload, S>

  type PagoDetalleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PagoDetalleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PagoDetalleCountAggregateInputType | true
    }

  export interface PagoDetalleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PagoDetalle'], meta: { name: 'PagoDetalle' } }
    /**
     * Find zero or one PagoDetalle that matches the filter.
     * @param {PagoDetalleFindUniqueArgs} args - Arguments to find a PagoDetalle
     * @example
     * // Get one PagoDetalle
     * const pagoDetalle = await prisma.pagoDetalle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagoDetalleFindUniqueArgs>(args: SelectSubset<T, PagoDetalleFindUniqueArgs<ExtArgs>>): Prisma__PagoDetalleClient<$Result.GetResult<Prisma.$PagoDetallePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PagoDetalle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PagoDetalleFindUniqueOrThrowArgs} args - Arguments to find a PagoDetalle
     * @example
     * // Get one PagoDetalle
     * const pagoDetalle = await prisma.pagoDetalle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagoDetalleFindUniqueOrThrowArgs>(args: SelectSubset<T, PagoDetalleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagoDetalleClient<$Result.GetResult<Prisma.$PagoDetallePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PagoDetalle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDetalleFindFirstArgs} args - Arguments to find a PagoDetalle
     * @example
     * // Get one PagoDetalle
     * const pagoDetalle = await prisma.pagoDetalle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagoDetalleFindFirstArgs>(args?: SelectSubset<T, PagoDetalleFindFirstArgs<ExtArgs>>): Prisma__PagoDetalleClient<$Result.GetResult<Prisma.$PagoDetallePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PagoDetalle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDetalleFindFirstOrThrowArgs} args - Arguments to find a PagoDetalle
     * @example
     * // Get one PagoDetalle
     * const pagoDetalle = await prisma.pagoDetalle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagoDetalleFindFirstOrThrowArgs>(args?: SelectSubset<T, PagoDetalleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagoDetalleClient<$Result.GetResult<Prisma.$PagoDetallePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PagoDetalles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDetalleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PagoDetalles
     * const pagoDetalles = await prisma.pagoDetalle.findMany()
     * 
     * // Get first 10 PagoDetalles
     * const pagoDetalles = await prisma.pagoDetalle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagoDetalleWithIdOnly = await prisma.pagoDetalle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagoDetalleFindManyArgs>(args?: SelectSubset<T, PagoDetalleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoDetallePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PagoDetalle.
     * @param {PagoDetalleCreateArgs} args - Arguments to create a PagoDetalle.
     * @example
     * // Create one PagoDetalle
     * const PagoDetalle = await prisma.pagoDetalle.create({
     *   data: {
     *     // ... data to create a PagoDetalle
     *   }
     * })
     * 
     */
    create<T extends PagoDetalleCreateArgs>(args: SelectSubset<T, PagoDetalleCreateArgs<ExtArgs>>): Prisma__PagoDetalleClient<$Result.GetResult<Prisma.$PagoDetallePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PagoDetalles.
     * @param {PagoDetalleCreateManyArgs} args - Arguments to create many PagoDetalles.
     * @example
     * // Create many PagoDetalles
     * const pagoDetalle = await prisma.pagoDetalle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagoDetalleCreateManyArgs>(args?: SelectSubset<T, PagoDetalleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PagoDetalles and returns the data saved in the database.
     * @param {PagoDetalleCreateManyAndReturnArgs} args - Arguments to create many PagoDetalles.
     * @example
     * // Create many PagoDetalles
     * const pagoDetalle = await prisma.pagoDetalle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PagoDetalles and only return the `id`
     * const pagoDetalleWithIdOnly = await prisma.pagoDetalle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PagoDetalleCreateManyAndReturnArgs>(args?: SelectSubset<T, PagoDetalleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoDetallePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PagoDetalle.
     * @param {PagoDetalleDeleteArgs} args - Arguments to delete one PagoDetalle.
     * @example
     * // Delete one PagoDetalle
     * const PagoDetalle = await prisma.pagoDetalle.delete({
     *   where: {
     *     // ... filter to delete one PagoDetalle
     *   }
     * })
     * 
     */
    delete<T extends PagoDetalleDeleteArgs>(args: SelectSubset<T, PagoDetalleDeleteArgs<ExtArgs>>): Prisma__PagoDetalleClient<$Result.GetResult<Prisma.$PagoDetallePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PagoDetalle.
     * @param {PagoDetalleUpdateArgs} args - Arguments to update one PagoDetalle.
     * @example
     * // Update one PagoDetalle
     * const pagoDetalle = await prisma.pagoDetalle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagoDetalleUpdateArgs>(args: SelectSubset<T, PagoDetalleUpdateArgs<ExtArgs>>): Prisma__PagoDetalleClient<$Result.GetResult<Prisma.$PagoDetallePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PagoDetalles.
     * @param {PagoDetalleDeleteManyArgs} args - Arguments to filter PagoDetalles to delete.
     * @example
     * // Delete a few PagoDetalles
     * const { count } = await prisma.pagoDetalle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagoDetalleDeleteManyArgs>(args?: SelectSubset<T, PagoDetalleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PagoDetalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDetalleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PagoDetalles
     * const pagoDetalle = await prisma.pagoDetalle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagoDetalleUpdateManyArgs>(args: SelectSubset<T, PagoDetalleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PagoDetalles and returns the data updated in the database.
     * @param {PagoDetalleUpdateManyAndReturnArgs} args - Arguments to update many PagoDetalles.
     * @example
     * // Update many PagoDetalles
     * const pagoDetalle = await prisma.pagoDetalle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PagoDetalles and only return the `id`
     * const pagoDetalleWithIdOnly = await prisma.pagoDetalle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PagoDetalleUpdateManyAndReturnArgs>(args: SelectSubset<T, PagoDetalleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoDetallePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PagoDetalle.
     * @param {PagoDetalleUpsertArgs} args - Arguments to update or create a PagoDetalle.
     * @example
     * // Update or create a PagoDetalle
     * const pagoDetalle = await prisma.pagoDetalle.upsert({
     *   create: {
     *     // ... data to create a PagoDetalle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PagoDetalle we want to update
     *   }
     * })
     */
    upsert<T extends PagoDetalleUpsertArgs>(args: SelectSubset<T, PagoDetalleUpsertArgs<ExtArgs>>): Prisma__PagoDetalleClient<$Result.GetResult<Prisma.$PagoDetallePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PagoDetalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDetalleCountArgs} args - Arguments to filter PagoDetalles to count.
     * @example
     * // Count the number of PagoDetalles
     * const count = await prisma.pagoDetalle.count({
     *   where: {
     *     // ... the filter for the PagoDetalles we want to count
     *   }
     * })
    **/
    count<T extends PagoDetalleCountArgs>(
      args?: Subset<T, PagoDetalleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagoDetalleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PagoDetalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDetalleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagoDetalleAggregateArgs>(args: Subset<T, PagoDetalleAggregateArgs>): Prisma.PrismaPromise<GetPagoDetalleAggregateType<T>>

    /**
     * Group by PagoDetalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagoDetalleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagoDetalleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagoDetalleGroupByArgs['orderBy'] }
        : { orderBy?: PagoDetalleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagoDetalleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagoDetalleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PagoDetalle model
   */
  readonly fields: PagoDetalleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PagoDetalle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagoDetalleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pago<T extends PagoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PagoDefaultArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tipoPago<T extends TipoPagoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TipoPagoDefaultArgs<ExtArgs>>): Prisma__TipoPagoClient<$Result.GetResult<Prisma.$TipoPagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PagoDetalle model
   */
  interface PagoDetalleFieldRefs {
    readonly id: FieldRef<"PagoDetalle", 'Int'>
    readonly pagoId: FieldRef<"PagoDetalle", 'Int'>
    readonly tipoPagoId: FieldRef<"PagoDetalle", 'Int'>
    readonly concepto: FieldRef<"PagoDetalle", 'String'>
    readonly monto: FieldRef<"PagoDetalle", 'Decimal'>
    readonly porcentajeImpuesto: FieldRef<"PagoDetalle", 'Decimal'>
    readonly cantidad: FieldRef<"PagoDetalle", 'Int'>
    readonly descripcion: FieldRef<"PagoDetalle", 'String'>
    readonly createdAt: FieldRef<"PagoDetalle", 'DateTime'>
    readonly updatedAt: FieldRef<"PagoDetalle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PagoDetalle findUnique
   */
  export type PagoDetalleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleInclude<ExtArgs> | null
    /**
     * Filter, which PagoDetalle to fetch.
     */
    where: PagoDetalleWhereUniqueInput
  }

  /**
   * PagoDetalle findUniqueOrThrow
   */
  export type PagoDetalleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleInclude<ExtArgs> | null
    /**
     * Filter, which PagoDetalle to fetch.
     */
    where: PagoDetalleWhereUniqueInput
  }

  /**
   * PagoDetalle findFirst
   */
  export type PagoDetalleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleInclude<ExtArgs> | null
    /**
     * Filter, which PagoDetalle to fetch.
     */
    where?: PagoDetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagoDetalles to fetch.
     */
    orderBy?: PagoDetalleOrderByWithRelationInput | PagoDetalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PagoDetalles.
     */
    cursor?: PagoDetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagoDetalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagoDetalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PagoDetalles.
     */
    distinct?: PagoDetalleScalarFieldEnum | PagoDetalleScalarFieldEnum[]
  }

  /**
   * PagoDetalle findFirstOrThrow
   */
  export type PagoDetalleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleInclude<ExtArgs> | null
    /**
     * Filter, which PagoDetalle to fetch.
     */
    where?: PagoDetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagoDetalles to fetch.
     */
    orderBy?: PagoDetalleOrderByWithRelationInput | PagoDetalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PagoDetalles.
     */
    cursor?: PagoDetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagoDetalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagoDetalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PagoDetalles.
     */
    distinct?: PagoDetalleScalarFieldEnum | PagoDetalleScalarFieldEnum[]
  }

  /**
   * PagoDetalle findMany
   */
  export type PagoDetalleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleInclude<ExtArgs> | null
    /**
     * Filter, which PagoDetalles to fetch.
     */
    where?: PagoDetalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PagoDetalles to fetch.
     */
    orderBy?: PagoDetalleOrderByWithRelationInput | PagoDetalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PagoDetalles.
     */
    cursor?: PagoDetalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PagoDetalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PagoDetalles.
     */
    skip?: number
    distinct?: PagoDetalleScalarFieldEnum | PagoDetalleScalarFieldEnum[]
  }

  /**
   * PagoDetalle create
   */
  export type PagoDetalleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleInclude<ExtArgs> | null
    /**
     * The data needed to create a PagoDetalle.
     */
    data: XOR<PagoDetalleCreateInput, PagoDetalleUncheckedCreateInput>
  }

  /**
   * PagoDetalle createMany
   */
  export type PagoDetalleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PagoDetalles.
     */
    data: PagoDetalleCreateManyInput | PagoDetalleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PagoDetalle createManyAndReturn
   */
  export type PagoDetalleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * The data used to create many PagoDetalles.
     */
    data: PagoDetalleCreateManyInput | PagoDetalleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PagoDetalle update
   */
  export type PagoDetalleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleInclude<ExtArgs> | null
    /**
     * The data needed to update a PagoDetalle.
     */
    data: XOR<PagoDetalleUpdateInput, PagoDetalleUncheckedUpdateInput>
    /**
     * Choose, which PagoDetalle to update.
     */
    where: PagoDetalleWhereUniqueInput
  }

  /**
   * PagoDetalle updateMany
   */
  export type PagoDetalleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PagoDetalles.
     */
    data: XOR<PagoDetalleUpdateManyMutationInput, PagoDetalleUncheckedUpdateManyInput>
    /**
     * Filter which PagoDetalles to update
     */
    where?: PagoDetalleWhereInput
    /**
     * Limit how many PagoDetalles to update.
     */
    limit?: number
  }

  /**
   * PagoDetalle updateManyAndReturn
   */
  export type PagoDetalleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * The data used to update PagoDetalles.
     */
    data: XOR<PagoDetalleUpdateManyMutationInput, PagoDetalleUncheckedUpdateManyInput>
    /**
     * Filter which PagoDetalles to update
     */
    where?: PagoDetalleWhereInput
    /**
     * Limit how many PagoDetalles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PagoDetalle upsert
   */
  export type PagoDetalleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleInclude<ExtArgs> | null
    /**
     * The filter to search for the PagoDetalle to update in case it exists.
     */
    where: PagoDetalleWhereUniqueInput
    /**
     * In case the PagoDetalle found by the `where` argument doesn't exist, create a new PagoDetalle with this data.
     */
    create: XOR<PagoDetalleCreateInput, PagoDetalleUncheckedCreateInput>
    /**
     * In case the PagoDetalle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagoDetalleUpdateInput, PagoDetalleUncheckedUpdateInput>
  }

  /**
   * PagoDetalle delete
   */
  export type PagoDetalleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleInclude<ExtArgs> | null
    /**
     * Filter which PagoDetalle to delete.
     */
    where: PagoDetalleWhereUniqueInput
  }

  /**
   * PagoDetalle deleteMany
   */
  export type PagoDetalleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PagoDetalles to delete
     */
    where?: PagoDetalleWhereInput
    /**
     * Limit how many PagoDetalles to delete.
     */
    limit?: number
  }

  /**
   * PagoDetalle without action
   */
  export type PagoDetalleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleInclude<ExtArgs> | null
  }


  /**
   * Model TipoPago
   */

  export type AggregateTipoPago = {
    _count: TipoPagoCountAggregateOutputType | null
    _avg: TipoPagoAvgAggregateOutputType | null
    _sum: TipoPagoSumAggregateOutputType | null
    _min: TipoPagoMinAggregateOutputType | null
    _max: TipoPagoMaxAggregateOutputType | null
  }

  export type TipoPagoAvgAggregateOutputType = {
    id: number | null
    comisionPorcentaje: Decimal | null
  }

  export type TipoPagoSumAggregateOutputType = {
    id: number | null
    comisionPorcentaje: Decimal | null
  }

  export type TipoPagoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    requiereVerificacion: boolean | null
    comisionPorcentaje: Decimal | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TipoPagoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    requiereVerificacion: boolean | null
    comisionPorcentaje: Decimal | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TipoPagoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    requiereVerificacion: number
    comisionPorcentaje: number
    activo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TipoPagoAvgAggregateInputType = {
    id?: true
    comisionPorcentaje?: true
  }

  export type TipoPagoSumAggregateInputType = {
    id?: true
    comisionPorcentaje?: true
  }

  export type TipoPagoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    requiereVerificacion?: true
    comisionPorcentaje?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TipoPagoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    requiereVerificacion?: true
    comisionPorcentaje?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TipoPagoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    requiereVerificacion?: true
    comisionPorcentaje?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TipoPagoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoPago to aggregate.
     */
    where?: TipoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoPagos to fetch.
     */
    orderBy?: TipoPagoOrderByWithRelationInput | TipoPagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoPagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoPagos
    **/
    _count?: true | TipoPagoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoPagoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoPagoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoPagoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoPagoMaxAggregateInputType
  }

  export type GetTipoPagoAggregateType<T extends TipoPagoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoPago]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoPago[P]>
      : GetScalarType<T[P], AggregateTipoPago[P]>
  }




  export type TipoPagoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoPagoWhereInput
    orderBy?: TipoPagoOrderByWithAggregationInput | TipoPagoOrderByWithAggregationInput[]
    by: TipoPagoScalarFieldEnum[] | TipoPagoScalarFieldEnum
    having?: TipoPagoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoPagoCountAggregateInputType | true
    _avg?: TipoPagoAvgAggregateInputType
    _sum?: TipoPagoSumAggregateInputType
    _min?: TipoPagoMinAggregateInputType
    _max?: TipoPagoMaxAggregateInputType
  }

  export type TipoPagoGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    requiereVerificacion: boolean
    comisionPorcentaje: Decimal
    activo: boolean
    createdAt: Date
    updatedAt: Date
    _count: TipoPagoCountAggregateOutputType | null
    _avg: TipoPagoAvgAggregateOutputType | null
    _sum: TipoPagoSumAggregateOutputType | null
    _min: TipoPagoMinAggregateOutputType | null
    _max: TipoPagoMaxAggregateOutputType | null
  }

  type GetTipoPagoGroupByPayload<T extends TipoPagoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoPagoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoPagoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoPagoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoPagoGroupByOutputType[P]>
        }
      >
    >


  export type TipoPagoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    requiereVerificacion?: boolean
    comisionPorcentaje?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pagoDetalles?: boolean | TipoPago$pagoDetallesArgs<ExtArgs>
    _count?: boolean | TipoPagoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoPago"]>

  export type TipoPagoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    requiereVerificacion?: boolean
    comisionPorcentaje?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tipoPago"]>

  export type TipoPagoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    requiereVerificacion?: boolean
    comisionPorcentaje?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tipoPago"]>

  export type TipoPagoSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    requiereVerificacion?: boolean
    comisionPorcentaje?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TipoPagoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "requiereVerificacion" | "comisionPorcentaje" | "activo" | "createdAt" | "updatedAt", ExtArgs["result"]["tipoPago"]>
  export type TipoPagoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagoDetalles?: boolean | TipoPago$pagoDetallesArgs<ExtArgs>
    _count?: boolean | TipoPagoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipoPagoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TipoPagoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipoPagoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoPago"
    objects: {
      pagoDetalles: Prisma.$PagoDetallePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      requiereVerificacion: boolean
      comisionPorcentaje: Prisma.Decimal
      activo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tipoPago"]>
    composites: {}
  }

  type TipoPagoGetPayload<S extends boolean | null | undefined | TipoPagoDefaultArgs> = $Result.GetResult<Prisma.$TipoPagoPayload, S>

  type TipoPagoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoPagoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoPagoCountAggregateInputType | true
    }

  export interface TipoPagoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoPago'], meta: { name: 'TipoPago' } }
    /**
     * Find zero or one TipoPago that matches the filter.
     * @param {TipoPagoFindUniqueArgs} args - Arguments to find a TipoPago
     * @example
     * // Get one TipoPago
     * const tipoPago = await prisma.tipoPago.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoPagoFindUniqueArgs>(args: SelectSubset<T, TipoPagoFindUniqueArgs<ExtArgs>>): Prisma__TipoPagoClient<$Result.GetResult<Prisma.$TipoPagoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoPago that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoPagoFindUniqueOrThrowArgs} args - Arguments to find a TipoPago
     * @example
     * // Get one TipoPago
     * const tipoPago = await prisma.tipoPago.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoPagoFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoPagoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoPagoClient<$Result.GetResult<Prisma.$TipoPagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoPago that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoFindFirstArgs} args - Arguments to find a TipoPago
     * @example
     * // Get one TipoPago
     * const tipoPago = await prisma.tipoPago.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoPagoFindFirstArgs>(args?: SelectSubset<T, TipoPagoFindFirstArgs<ExtArgs>>): Prisma__TipoPagoClient<$Result.GetResult<Prisma.$TipoPagoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoPago that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoFindFirstOrThrowArgs} args - Arguments to find a TipoPago
     * @example
     * // Get one TipoPago
     * const tipoPago = await prisma.tipoPago.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoPagoFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoPagoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoPagoClient<$Result.GetResult<Prisma.$TipoPagoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoPagos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoPagos
     * const tipoPagos = await prisma.tipoPago.findMany()
     * 
     * // Get first 10 TipoPagos
     * const tipoPagos = await prisma.tipoPago.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoPagoWithIdOnly = await prisma.tipoPago.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoPagoFindManyArgs>(args?: SelectSubset<T, TipoPagoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoPagoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoPago.
     * @param {TipoPagoCreateArgs} args - Arguments to create a TipoPago.
     * @example
     * // Create one TipoPago
     * const TipoPago = await prisma.tipoPago.create({
     *   data: {
     *     // ... data to create a TipoPago
     *   }
     * })
     * 
     */
    create<T extends TipoPagoCreateArgs>(args: SelectSubset<T, TipoPagoCreateArgs<ExtArgs>>): Prisma__TipoPagoClient<$Result.GetResult<Prisma.$TipoPagoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoPagos.
     * @param {TipoPagoCreateManyArgs} args - Arguments to create many TipoPagos.
     * @example
     * // Create many TipoPagos
     * const tipoPago = await prisma.tipoPago.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoPagoCreateManyArgs>(args?: SelectSubset<T, TipoPagoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoPagos and returns the data saved in the database.
     * @param {TipoPagoCreateManyAndReturnArgs} args - Arguments to create many TipoPagos.
     * @example
     * // Create many TipoPagos
     * const tipoPago = await prisma.tipoPago.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoPagos and only return the `id`
     * const tipoPagoWithIdOnly = await prisma.tipoPago.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoPagoCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoPagoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoPagoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoPago.
     * @param {TipoPagoDeleteArgs} args - Arguments to delete one TipoPago.
     * @example
     * // Delete one TipoPago
     * const TipoPago = await prisma.tipoPago.delete({
     *   where: {
     *     // ... filter to delete one TipoPago
     *   }
     * })
     * 
     */
    delete<T extends TipoPagoDeleteArgs>(args: SelectSubset<T, TipoPagoDeleteArgs<ExtArgs>>): Prisma__TipoPagoClient<$Result.GetResult<Prisma.$TipoPagoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoPago.
     * @param {TipoPagoUpdateArgs} args - Arguments to update one TipoPago.
     * @example
     * // Update one TipoPago
     * const tipoPago = await prisma.tipoPago.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoPagoUpdateArgs>(args: SelectSubset<T, TipoPagoUpdateArgs<ExtArgs>>): Prisma__TipoPagoClient<$Result.GetResult<Prisma.$TipoPagoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoPagos.
     * @param {TipoPagoDeleteManyArgs} args - Arguments to filter TipoPagos to delete.
     * @example
     * // Delete a few TipoPagos
     * const { count } = await prisma.tipoPago.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoPagoDeleteManyArgs>(args?: SelectSubset<T, TipoPagoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoPagos
     * const tipoPago = await prisma.tipoPago.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoPagoUpdateManyArgs>(args: SelectSubset<T, TipoPagoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoPagos and returns the data updated in the database.
     * @param {TipoPagoUpdateManyAndReturnArgs} args - Arguments to update many TipoPagos.
     * @example
     * // Update many TipoPagos
     * const tipoPago = await prisma.tipoPago.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoPagos and only return the `id`
     * const tipoPagoWithIdOnly = await prisma.tipoPago.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoPagoUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoPagoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoPagoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoPago.
     * @param {TipoPagoUpsertArgs} args - Arguments to update or create a TipoPago.
     * @example
     * // Update or create a TipoPago
     * const tipoPago = await prisma.tipoPago.upsert({
     *   create: {
     *     // ... data to create a TipoPago
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoPago we want to update
     *   }
     * })
     */
    upsert<T extends TipoPagoUpsertArgs>(args: SelectSubset<T, TipoPagoUpsertArgs<ExtArgs>>): Prisma__TipoPagoClient<$Result.GetResult<Prisma.$TipoPagoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoPagos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoCountArgs} args - Arguments to filter TipoPagos to count.
     * @example
     * // Count the number of TipoPagos
     * const count = await prisma.tipoPago.count({
     *   where: {
     *     // ... the filter for the TipoPagos we want to count
     *   }
     * })
    **/
    count<T extends TipoPagoCountArgs>(
      args?: Subset<T, TipoPagoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoPagoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoPagoAggregateArgs>(args: Subset<T, TipoPagoAggregateArgs>): Prisma.PrismaPromise<GetTipoPagoAggregateType<T>>

    /**
     * Group by TipoPago.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPagoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoPagoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoPagoGroupByArgs['orderBy'] }
        : { orderBy?: TipoPagoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoPagoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoPagoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoPago model
   */
  readonly fields: TipoPagoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoPago.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoPagoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pagoDetalles<T extends TipoPago$pagoDetallesArgs<ExtArgs> = {}>(args?: Subset<T, TipoPago$pagoDetallesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagoDetallePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoPago model
   */
  interface TipoPagoFieldRefs {
    readonly id: FieldRef<"TipoPago", 'Int'>
    readonly nombre: FieldRef<"TipoPago", 'String'>
    readonly descripcion: FieldRef<"TipoPago", 'String'>
    readonly requiereVerificacion: FieldRef<"TipoPago", 'Boolean'>
    readonly comisionPorcentaje: FieldRef<"TipoPago", 'Decimal'>
    readonly activo: FieldRef<"TipoPago", 'Boolean'>
    readonly createdAt: FieldRef<"TipoPago", 'DateTime'>
    readonly updatedAt: FieldRef<"TipoPago", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TipoPago findUnique
   */
  export type TipoPagoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPago
     */
    select?: TipoPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoPago
     */
    omit?: TipoPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoPagoInclude<ExtArgs> | null
    /**
     * Filter, which TipoPago to fetch.
     */
    where: TipoPagoWhereUniqueInput
  }

  /**
   * TipoPago findUniqueOrThrow
   */
  export type TipoPagoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPago
     */
    select?: TipoPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoPago
     */
    omit?: TipoPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoPagoInclude<ExtArgs> | null
    /**
     * Filter, which TipoPago to fetch.
     */
    where: TipoPagoWhereUniqueInput
  }

  /**
   * TipoPago findFirst
   */
  export type TipoPagoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPago
     */
    select?: TipoPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoPago
     */
    omit?: TipoPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoPagoInclude<ExtArgs> | null
    /**
     * Filter, which TipoPago to fetch.
     */
    where?: TipoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoPagos to fetch.
     */
    orderBy?: TipoPagoOrderByWithRelationInput | TipoPagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoPagos.
     */
    cursor?: TipoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoPagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoPagos.
     */
    distinct?: TipoPagoScalarFieldEnum | TipoPagoScalarFieldEnum[]
  }

  /**
   * TipoPago findFirstOrThrow
   */
  export type TipoPagoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPago
     */
    select?: TipoPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoPago
     */
    omit?: TipoPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoPagoInclude<ExtArgs> | null
    /**
     * Filter, which TipoPago to fetch.
     */
    where?: TipoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoPagos to fetch.
     */
    orderBy?: TipoPagoOrderByWithRelationInput | TipoPagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoPagos.
     */
    cursor?: TipoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoPagos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoPagos.
     */
    distinct?: TipoPagoScalarFieldEnum | TipoPagoScalarFieldEnum[]
  }

  /**
   * TipoPago findMany
   */
  export type TipoPagoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPago
     */
    select?: TipoPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoPago
     */
    omit?: TipoPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoPagoInclude<ExtArgs> | null
    /**
     * Filter, which TipoPagos to fetch.
     */
    where?: TipoPagoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoPagos to fetch.
     */
    orderBy?: TipoPagoOrderByWithRelationInput | TipoPagoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoPagos.
     */
    cursor?: TipoPagoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoPagos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoPagos.
     */
    skip?: number
    distinct?: TipoPagoScalarFieldEnum | TipoPagoScalarFieldEnum[]
  }

  /**
   * TipoPago create
   */
  export type TipoPagoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPago
     */
    select?: TipoPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoPago
     */
    omit?: TipoPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoPagoInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoPago.
     */
    data: XOR<TipoPagoCreateInput, TipoPagoUncheckedCreateInput>
  }

  /**
   * TipoPago createMany
   */
  export type TipoPagoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoPagos.
     */
    data: TipoPagoCreateManyInput | TipoPagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoPago createManyAndReturn
   */
  export type TipoPagoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPago
     */
    select?: TipoPagoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoPago
     */
    omit?: TipoPagoOmit<ExtArgs> | null
    /**
     * The data used to create many TipoPagos.
     */
    data: TipoPagoCreateManyInput | TipoPagoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoPago update
   */
  export type TipoPagoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPago
     */
    select?: TipoPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoPago
     */
    omit?: TipoPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoPagoInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoPago.
     */
    data: XOR<TipoPagoUpdateInput, TipoPagoUncheckedUpdateInput>
    /**
     * Choose, which TipoPago to update.
     */
    where: TipoPagoWhereUniqueInput
  }

  /**
   * TipoPago updateMany
   */
  export type TipoPagoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoPagos.
     */
    data: XOR<TipoPagoUpdateManyMutationInput, TipoPagoUncheckedUpdateManyInput>
    /**
     * Filter which TipoPagos to update
     */
    where?: TipoPagoWhereInput
    /**
     * Limit how many TipoPagos to update.
     */
    limit?: number
  }

  /**
   * TipoPago updateManyAndReturn
   */
  export type TipoPagoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPago
     */
    select?: TipoPagoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoPago
     */
    omit?: TipoPagoOmit<ExtArgs> | null
    /**
     * The data used to update TipoPagos.
     */
    data: XOR<TipoPagoUpdateManyMutationInput, TipoPagoUncheckedUpdateManyInput>
    /**
     * Filter which TipoPagos to update
     */
    where?: TipoPagoWhereInput
    /**
     * Limit how many TipoPagos to update.
     */
    limit?: number
  }

  /**
   * TipoPago upsert
   */
  export type TipoPagoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPago
     */
    select?: TipoPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoPago
     */
    omit?: TipoPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoPagoInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoPago to update in case it exists.
     */
    where: TipoPagoWhereUniqueInput
    /**
     * In case the TipoPago found by the `where` argument doesn't exist, create a new TipoPago with this data.
     */
    create: XOR<TipoPagoCreateInput, TipoPagoUncheckedCreateInput>
    /**
     * In case the TipoPago was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoPagoUpdateInput, TipoPagoUncheckedUpdateInput>
  }

  /**
   * TipoPago delete
   */
  export type TipoPagoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPago
     */
    select?: TipoPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoPago
     */
    omit?: TipoPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoPagoInclude<ExtArgs> | null
    /**
     * Filter which TipoPago to delete.
     */
    where: TipoPagoWhereUniqueInput
  }

  /**
   * TipoPago deleteMany
   */
  export type TipoPagoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoPagos to delete
     */
    where?: TipoPagoWhereInput
    /**
     * Limit how many TipoPagos to delete.
     */
    limit?: number
  }

  /**
   * TipoPago.pagoDetalles
   */
  export type TipoPago$pagoDetallesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PagoDetalle
     */
    select?: PagoDetalleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PagoDetalle
     */
    omit?: PagoDetalleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagoDetalleInclude<ExtArgs> | null
    where?: PagoDetalleWhereInput
    orderBy?: PagoDetalleOrderByWithRelationInput | PagoDetalleOrderByWithRelationInput[]
    cursor?: PagoDetalleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagoDetalleScalarFieldEnum | PagoDetalleScalarFieldEnum[]
  }

  /**
   * TipoPago without action
   */
  export type TipoPagoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPago
     */
    select?: TipoPagoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoPago
     */
    omit?: TipoPagoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoPagoInclude<ExtArgs> | null
  }


  /**
   * Model Comprobante
   */

  export type AggregateComprobante = {
    _count: ComprobanteCountAggregateOutputType | null
    _avg: ComprobanteAvgAggregateOutputType | null
    _sum: ComprobanteSumAggregateOutputType | null
    _min: ComprobanteMinAggregateOutputType | null
    _max: ComprobanteMaxAggregateOutputType | null
  }

  export type ComprobanteAvgAggregateOutputType = {
    id: number | null
    pagoId: number | null
    numero: number | null
    subtotal: Decimal | null
    igv: Decimal | null
    total: Decimal | null
  }

  export type ComprobanteSumAggregateOutputType = {
    id: number | null
    pagoId: number | null
    numero: number | null
    subtotal: Decimal | null
    igv: Decimal | null
    total: Decimal | null
  }

  export type ComprobanteMinAggregateOutputType = {
    id: number | null
    pagoId: number | null
    tipoComprobante: string | null
    serie: string | null
    numero: number | null
    fechaEmision: Date | null
    rucCliente: string | null
    razonSocial: string | null
    direccionCliente: string | null
    subtotal: Decimal | null
    igv: Decimal | null
    total: Decimal | null
    moneda: string | null
    estado: string | null
    codigoSunat: string | null
    codigoHash: string | null
    xmlUrl: string | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComprobanteMaxAggregateOutputType = {
    id: number | null
    pagoId: number | null
    tipoComprobante: string | null
    serie: string | null
    numero: number | null
    fechaEmision: Date | null
    rucCliente: string | null
    razonSocial: string | null
    direccionCliente: string | null
    subtotal: Decimal | null
    igv: Decimal | null
    total: Decimal | null
    moneda: string | null
    estado: string | null
    codigoSunat: string | null
    codigoHash: string | null
    xmlUrl: string | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComprobanteCountAggregateOutputType = {
    id: number
    pagoId: number
    tipoComprobante: number
    serie: number
    numero: number
    fechaEmision: number
    rucCliente: number
    razonSocial: number
    direccionCliente: number
    subtotal: number
    igv: number
    total: number
    moneda: number
    estado: number
    codigoSunat: number
    codigoHash: number
    xmlUrl: number
    pdfUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComprobanteAvgAggregateInputType = {
    id?: true
    pagoId?: true
    numero?: true
    subtotal?: true
    igv?: true
    total?: true
  }

  export type ComprobanteSumAggregateInputType = {
    id?: true
    pagoId?: true
    numero?: true
    subtotal?: true
    igv?: true
    total?: true
  }

  export type ComprobanteMinAggregateInputType = {
    id?: true
    pagoId?: true
    tipoComprobante?: true
    serie?: true
    numero?: true
    fechaEmision?: true
    rucCliente?: true
    razonSocial?: true
    direccionCliente?: true
    subtotal?: true
    igv?: true
    total?: true
    moneda?: true
    estado?: true
    codigoSunat?: true
    codigoHash?: true
    xmlUrl?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComprobanteMaxAggregateInputType = {
    id?: true
    pagoId?: true
    tipoComprobante?: true
    serie?: true
    numero?: true
    fechaEmision?: true
    rucCliente?: true
    razonSocial?: true
    direccionCliente?: true
    subtotal?: true
    igv?: true
    total?: true
    moneda?: true
    estado?: true
    codigoSunat?: true
    codigoHash?: true
    xmlUrl?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComprobanteCountAggregateInputType = {
    id?: true
    pagoId?: true
    tipoComprobante?: true
    serie?: true
    numero?: true
    fechaEmision?: true
    rucCliente?: true
    razonSocial?: true
    direccionCliente?: true
    subtotal?: true
    igv?: true
    total?: true
    moneda?: true
    estado?: true
    codigoSunat?: true
    codigoHash?: true
    xmlUrl?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComprobanteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comprobante to aggregate.
     */
    where?: ComprobanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comprobantes to fetch.
     */
    orderBy?: ComprobanteOrderByWithRelationInput | ComprobanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComprobanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comprobantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comprobantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comprobantes
    **/
    _count?: true | ComprobanteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComprobanteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComprobanteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComprobanteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComprobanteMaxAggregateInputType
  }

  export type GetComprobanteAggregateType<T extends ComprobanteAggregateArgs> = {
        [P in keyof T & keyof AggregateComprobante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComprobante[P]>
      : GetScalarType<T[P], AggregateComprobante[P]>
  }




  export type ComprobanteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComprobanteWhereInput
    orderBy?: ComprobanteOrderByWithAggregationInput | ComprobanteOrderByWithAggregationInput[]
    by: ComprobanteScalarFieldEnum[] | ComprobanteScalarFieldEnum
    having?: ComprobanteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComprobanteCountAggregateInputType | true
    _avg?: ComprobanteAvgAggregateInputType
    _sum?: ComprobanteSumAggregateInputType
    _min?: ComprobanteMinAggregateInputType
    _max?: ComprobanteMaxAggregateInputType
  }

  export type ComprobanteGroupByOutputType = {
    id: number
    pagoId: number
    tipoComprobante: string
    serie: string
    numero: number
    fechaEmision: Date
    rucCliente: string | null
    razonSocial: string | null
    direccionCliente: string | null
    subtotal: Decimal
    igv: Decimal
    total: Decimal
    moneda: string
    estado: string
    codigoSunat: string | null
    codigoHash: string | null
    xmlUrl: string | null
    pdfUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: ComprobanteCountAggregateOutputType | null
    _avg: ComprobanteAvgAggregateOutputType | null
    _sum: ComprobanteSumAggregateOutputType | null
    _min: ComprobanteMinAggregateOutputType | null
    _max: ComprobanteMaxAggregateOutputType | null
  }

  type GetComprobanteGroupByPayload<T extends ComprobanteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComprobanteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComprobanteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComprobanteGroupByOutputType[P]>
            : GetScalarType<T[P], ComprobanteGroupByOutputType[P]>
        }
      >
    >


  export type ComprobanteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pagoId?: boolean
    tipoComprobante?: boolean
    serie?: boolean
    numero?: boolean
    fechaEmision?: boolean
    rucCliente?: boolean
    razonSocial?: boolean
    direccionCliente?: boolean
    subtotal?: boolean
    igv?: boolean
    total?: boolean
    moneda?: boolean
    estado?: boolean
    codigoSunat?: boolean
    codigoHash?: boolean
    xmlUrl?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pago?: boolean | PagoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comprobante"]>

  export type ComprobanteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pagoId?: boolean
    tipoComprobante?: boolean
    serie?: boolean
    numero?: boolean
    fechaEmision?: boolean
    rucCliente?: boolean
    razonSocial?: boolean
    direccionCliente?: boolean
    subtotal?: boolean
    igv?: boolean
    total?: boolean
    moneda?: boolean
    estado?: boolean
    codigoSunat?: boolean
    codigoHash?: boolean
    xmlUrl?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pago?: boolean | PagoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comprobante"]>

  export type ComprobanteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pagoId?: boolean
    tipoComprobante?: boolean
    serie?: boolean
    numero?: boolean
    fechaEmision?: boolean
    rucCliente?: boolean
    razonSocial?: boolean
    direccionCliente?: boolean
    subtotal?: boolean
    igv?: boolean
    total?: boolean
    moneda?: boolean
    estado?: boolean
    codigoSunat?: boolean
    codigoHash?: boolean
    xmlUrl?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pago?: boolean | PagoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comprobante"]>

  export type ComprobanteSelectScalar = {
    id?: boolean
    pagoId?: boolean
    tipoComprobante?: boolean
    serie?: boolean
    numero?: boolean
    fechaEmision?: boolean
    rucCliente?: boolean
    razonSocial?: boolean
    direccionCliente?: boolean
    subtotal?: boolean
    igv?: boolean
    total?: boolean
    moneda?: boolean
    estado?: boolean
    codigoSunat?: boolean
    codigoHash?: boolean
    xmlUrl?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComprobanteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pagoId" | "tipoComprobante" | "serie" | "numero" | "fechaEmision" | "rucCliente" | "razonSocial" | "direccionCliente" | "subtotal" | "igv" | "total" | "moneda" | "estado" | "codigoSunat" | "codigoHash" | "xmlUrl" | "pdfUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["comprobante"]>
  export type ComprobanteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pago?: boolean | PagoDefaultArgs<ExtArgs>
  }
  export type ComprobanteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pago?: boolean | PagoDefaultArgs<ExtArgs>
  }
  export type ComprobanteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pago?: boolean | PagoDefaultArgs<ExtArgs>
  }

  export type $ComprobantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comprobante"
    objects: {
      pago: Prisma.$PagoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pagoId: number
      tipoComprobante: string
      serie: string
      numero: number
      fechaEmision: Date
      rucCliente: string | null
      razonSocial: string | null
      direccionCliente: string | null
      subtotal: Prisma.Decimal
      igv: Prisma.Decimal
      total: Prisma.Decimal
      moneda: string
      estado: string
      codigoSunat: string | null
      codigoHash: string | null
      xmlUrl: string | null
      pdfUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comprobante"]>
    composites: {}
  }

  type ComprobanteGetPayload<S extends boolean | null | undefined | ComprobanteDefaultArgs> = $Result.GetResult<Prisma.$ComprobantePayload, S>

  type ComprobanteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComprobanteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComprobanteCountAggregateInputType | true
    }

  export interface ComprobanteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comprobante'], meta: { name: 'Comprobante' } }
    /**
     * Find zero or one Comprobante that matches the filter.
     * @param {ComprobanteFindUniqueArgs} args - Arguments to find a Comprobante
     * @example
     * // Get one Comprobante
     * const comprobante = await prisma.comprobante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComprobanteFindUniqueArgs>(args: SelectSubset<T, ComprobanteFindUniqueArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comprobante that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComprobanteFindUniqueOrThrowArgs} args - Arguments to find a Comprobante
     * @example
     * // Get one Comprobante
     * const comprobante = await prisma.comprobante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComprobanteFindUniqueOrThrowArgs>(args: SelectSubset<T, ComprobanteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comprobante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteFindFirstArgs} args - Arguments to find a Comprobante
     * @example
     * // Get one Comprobante
     * const comprobante = await prisma.comprobante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComprobanteFindFirstArgs>(args?: SelectSubset<T, ComprobanteFindFirstArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comprobante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteFindFirstOrThrowArgs} args - Arguments to find a Comprobante
     * @example
     * // Get one Comprobante
     * const comprobante = await prisma.comprobante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComprobanteFindFirstOrThrowArgs>(args?: SelectSubset<T, ComprobanteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comprobantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comprobantes
     * const comprobantes = await prisma.comprobante.findMany()
     * 
     * // Get first 10 Comprobantes
     * const comprobantes = await prisma.comprobante.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comprobanteWithIdOnly = await prisma.comprobante.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComprobanteFindManyArgs>(args?: SelectSubset<T, ComprobanteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comprobante.
     * @param {ComprobanteCreateArgs} args - Arguments to create a Comprobante.
     * @example
     * // Create one Comprobante
     * const Comprobante = await prisma.comprobante.create({
     *   data: {
     *     // ... data to create a Comprobante
     *   }
     * })
     * 
     */
    create<T extends ComprobanteCreateArgs>(args: SelectSubset<T, ComprobanteCreateArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comprobantes.
     * @param {ComprobanteCreateManyArgs} args - Arguments to create many Comprobantes.
     * @example
     * // Create many Comprobantes
     * const comprobante = await prisma.comprobante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComprobanteCreateManyArgs>(args?: SelectSubset<T, ComprobanteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comprobantes and returns the data saved in the database.
     * @param {ComprobanteCreateManyAndReturnArgs} args - Arguments to create many Comprobantes.
     * @example
     * // Create many Comprobantes
     * const comprobante = await prisma.comprobante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comprobantes and only return the `id`
     * const comprobanteWithIdOnly = await prisma.comprobante.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComprobanteCreateManyAndReturnArgs>(args?: SelectSubset<T, ComprobanteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comprobante.
     * @param {ComprobanteDeleteArgs} args - Arguments to delete one Comprobante.
     * @example
     * // Delete one Comprobante
     * const Comprobante = await prisma.comprobante.delete({
     *   where: {
     *     // ... filter to delete one Comprobante
     *   }
     * })
     * 
     */
    delete<T extends ComprobanteDeleteArgs>(args: SelectSubset<T, ComprobanteDeleteArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comprobante.
     * @param {ComprobanteUpdateArgs} args - Arguments to update one Comprobante.
     * @example
     * // Update one Comprobante
     * const comprobante = await prisma.comprobante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComprobanteUpdateArgs>(args: SelectSubset<T, ComprobanteUpdateArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comprobantes.
     * @param {ComprobanteDeleteManyArgs} args - Arguments to filter Comprobantes to delete.
     * @example
     * // Delete a few Comprobantes
     * const { count } = await prisma.comprobante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComprobanteDeleteManyArgs>(args?: SelectSubset<T, ComprobanteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comprobantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comprobantes
     * const comprobante = await prisma.comprobante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComprobanteUpdateManyArgs>(args: SelectSubset<T, ComprobanteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comprobantes and returns the data updated in the database.
     * @param {ComprobanteUpdateManyAndReturnArgs} args - Arguments to update many Comprobantes.
     * @example
     * // Update many Comprobantes
     * const comprobante = await prisma.comprobante.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comprobantes and only return the `id`
     * const comprobanteWithIdOnly = await prisma.comprobante.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComprobanteUpdateManyAndReturnArgs>(args: SelectSubset<T, ComprobanteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comprobante.
     * @param {ComprobanteUpsertArgs} args - Arguments to update or create a Comprobante.
     * @example
     * // Update or create a Comprobante
     * const comprobante = await prisma.comprobante.upsert({
     *   create: {
     *     // ... data to create a Comprobante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comprobante we want to update
     *   }
     * })
     */
    upsert<T extends ComprobanteUpsertArgs>(args: SelectSubset<T, ComprobanteUpsertArgs<ExtArgs>>): Prisma__ComprobanteClient<$Result.GetResult<Prisma.$ComprobantePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comprobantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteCountArgs} args - Arguments to filter Comprobantes to count.
     * @example
     * // Count the number of Comprobantes
     * const count = await prisma.comprobante.count({
     *   where: {
     *     // ... the filter for the Comprobantes we want to count
     *   }
     * })
    **/
    count<T extends ComprobanteCountArgs>(
      args?: Subset<T, ComprobanteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComprobanteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comprobante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComprobanteAggregateArgs>(args: Subset<T, ComprobanteAggregateArgs>): Prisma.PrismaPromise<GetComprobanteAggregateType<T>>

    /**
     * Group by Comprobante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprobanteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComprobanteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComprobanteGroupByArgs['orderBy'] }
        : { orderBy?: ComprobanteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComprobanteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComprobanteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comprobante model
   */
  readonly fields: ComprobanteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comprobante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComprobanteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pago<T extends PagoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PagoDefaultArgs<ExtArgs>>): Prisma__PagoClient<$Result.GetResult<Prisma.$PagoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comprobante model
   */
  interface ComprobanteFieldRefs {
    readonly id: FieldRef<"Comprobante", 'Int'>
    readonly pagoId: FieldRef<"Comprobante", 'Int'>
    readonly tipoComprobante: FieldRef<"Comprobante", 'String'>
    readonly serie: FieldRef<"Comprobante", 'String'>
    readonly numero: FieldRef<"Comprobante", 'Int'>
    readonly fechaEmision: FieldRef<"Comprobante", 'DateTime'>
    readonly rucCliente: FieldRef<"Comprobante", 'String'>
    readonly razonSocial: FieldRef<"Comprobante", 'String'>
    readonly direccionCliente: FieldRef<"Comprobante", 'String'>
    readonly subtotal: FieldRef<"Comprobante", 'Decimal'>
    readonly igv: FieldRef<"Comprobante", 'Decimal'>
    readonly total: FieldRef<"Comprobante", 'Decimal'>
    readonly moneda: FieldRef<"Comprobante", 'String'>
    readonly estado: FieldRef<"Comprobante", 'String'>
    readonly codigoSunat: FieldRef<"Comprobante", 'String'>
    readonly codigoHash: FieldRef<"Comprobante", 'String'>
    readonly xmlUrl: FieldRef<"Comprobante", 'String'>
    readonly pdfUrl: FieldRef<"Comprobante", 'String'>
    readonly createdAt: FieldRef<"Comprobante", 'DateTime'>
    readonly updatedAt: FieldRef<"Comprobante", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comprobante findUnique
   */
  export type ComprobanteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comprobante
     */
    omit?: ComprobanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * Filter, which Comprobante to fetch.
     */
    where: ComprobanteWhereUniqueInput
  }

  /**
   * Comprobante findUniqueOrThrow
   */
  export type ComprobanteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comprobante
     */
    omit?: ComprobanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * Filter, which Comprobante to fetch.
     */
    where: ComprobanteWhereUniqueInput
  }

  /**
   * Comprobante findFirst
   */
  export type ComprobanteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comprobante
     */
    omit?: ComprobanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * Filter, which Comprobante to fetch.
     */
    where?: ComprobanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comprobantes to fetch.
     */
    orderBy?: ComprobanteOrderByWithRelationInput | ComprobanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comprobantes.
     */
    cursor?: ComprobanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comprobantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comprobantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comprobantes.
     */
    distinct?: ComprobanteScalarFieldEnum | ComprobanteScalarFieldEnum[]
  }

  /**
   * Comprobante findFirstOrThrow
   */
  export type ComprobanteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comprobante
     */
    omit?: ComprobanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * Filter, which Comprobante to fetch.
     */
    where?: ComprobanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comprobantes to fetch.
     */
    orderBy?: ComprobanteOrderByWithRelationInput | ComprobanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comprobantes.
     */
    cursor?: ComprobanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comprobantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comprobantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comprobantes.
     */
    distinct?: ComprobanteScalarFieldEnum | ComprobanteScalarFieldEnum[]
  }

  /**
   * Comprobante findMany
   */
  export type ComprobanteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comprobante
     */
    omit?: ComprobanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * Filter, which Comprobantes to fetch.
     */
    where?: ComprobanteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comprobantes to fetch.
     */
    orderBy?: ComprobanteOrderByWithRelationInput | ComprobanteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comprobantes.
     */
    cursor?: ComprobanteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comprobantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comprobantes.
     */
    skip?: number
    distinct?: ComprobanteScalarFieldEnum | ComprobanteScalarFieldEnum[]
  }

  /**
   * Comprobante create
   */
  export type ComprobanteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comprobante
     */
    omit?: ComprobanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * The data needed to create a Comprobante.
     */
    data: XOR<ComprobanteCreateInput, ComprobanteUncheckedCreateInput>
  }

  /**
   * Comprobante createMany
   */
  export type ComprobanteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comprobantes.
     */
    data: ComprobanteCreateManyInput | ComprobanteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comprobante createManyAndReturn
   */
  export type ComprobanteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comprobante
     */
    omit?: ComprobanteOmit<ExtArgs> | null
    /**
     * The data used to create many Comprobantes.
     */
    data: ComprobanteCreateManyInput | ComprobanteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comprobante update
   */
  export type ComprobanteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comprobante
     */
    omit?: ComprobanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * The data needed to update a Comprobante.
     */
    data: XOR<ComprobanteUpdateInput, ComprobanteUncheckedUpdateInput>
    /**
     * Choose, which Comprobante to update.
     */
    where: ComprobanteWhereUniqueInput
  }

  /**
   * Comprobante updateMany
   */
  export type ComprobanteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comprobantes.
     */
    data: XOR<ComprobanteUpdateManyMutationInput, ComprobanteUncheckedUpdateManyInput>
    /**
     * Filter which Comprobantes to update
     */
    where?: ComprobanteWhereInput
    /**
     * Limit how many Comprobantes to update.
     */
    limit?: number
  }

  /**
   * Comprobante updateManyAndReturn
   */
  export type ComprobanteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comprobante
     */
    omit?: ComprobanteOmit<ExtArgs> | null
    /**
     * The data used to update Comprobantes.
     */
    data: XOR<ComprobanteUpdateManyMutationInput, ComprobanteUncheckedUpdateManyInput>
    /**
     * Filter which Comprobantes to update
     */
    where?: ComprobanteWhereInput
    /**
     * Limit how many Comprobantes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comprobante upsert
   */
  export type ComprobanteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comprobante
     */
    omit?: ComprobanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * The filter to search for the Comprobante to update in case it exists.
     */
    where: ComprobanteWhereUniqueInput
    /**
     * In case the Comprobante found by the `where` argument doesn't exist, create a new Comprobante with this data.
     */
    create: XOR<ComprobanteCreateInput, ComprobanteUncheckedCreateInput>
    /**
     * In case the Comprobante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComprobanteUpdateInput, ComprobanteUncheckedUpdateInput>
  }

  /**
   * Comprobante delete
   */
  export type ComprobanteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comprobante
     */
    omit?: ComprobanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
    /**
     * Filter which Comprobante to delete.
     */
    where: ComprobanteWhereUniqueInput
  }

  /**
   * Comprobante deleteMany
   */
  export type ComprobanteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comprobantes to delete
     */
    where?: ComprobanteWhereInput
    /**
     * Limit how many Comprobantes to delete.
     */
    limit?: number
  }

  /**
   * Comprobante without action
   */
  export type ComprobanteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comprobante
     */
    select?: ComprobanteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comprobante
     */
    omit?: ComprobanteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComprobanteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RoleScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermisoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermisoScalarFieldEnum = (typeof PermisoScalarFieldEnum)[keyof typeof PermisoScalarFieldEnum]


  export const RolesPermisosScalarFieldEnum: {
    id: 'id',
    rolId: 'rolId',
    permisoId: 'permisoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RolesPermisosScalarFieldEnum = (typeof RolesPermisosScalarFieldEnum)[keyof typeof RolesPermisosScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    codeIso: 'codeIso',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const SubdivisionScalarFieldEnum: {
    id: 'id',
    countryId: 'countryId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubdivisionScalarFieldEnum = (typeof SubdivisionScalarFieldEnum)[keyof typeof SubdivisionScalarFieldEnum]


  export const PersonaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellidos: 'apellidos',
    telefono: 'telefono',
    direccion: 'direccion',
    fotoPerfilUrl: 'fotoPerfilUrl',
    fechaNacimiento: 'fechaNacimiento',
    subdivisionId: 'subdivisionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PersonaScalarFieldEnum = (typeof PersonaScalarFieldEnum)[keyof typeof PersonaScalarFieldEnum]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    personaId: 'personaId',
    email: 'email',
    passwordHash: 'passwordHash',
    recoveryToken: 'recoveryToken',
    recoveryTokenExpiresAt: 'recoveryTokenExpiresAt',
    emailVerificationToken: 'emailVerificationToken',
    emailVerified: 'emailVerified',
    estaActivo: 'estaActivo',
    ultimoAcceso: 'ultimoAcceso',
    preferencias: 'preferencias',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const UsuariosRolesScalarFieldEnum: {
    id: 'id',
    rolId: 'rolId',
    usuarioId: 'usuarioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsuariosRolesScalarFieldEnum = (typeof UsuariosRolesScalarFieldEnum)[keyof typeof UsuariosRolesScalarFieldEnum]


  export const EmprendimientoScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    nombre: 'nombre',
    descripcion: 'descripcion',
    tipo: 'tipo',
    direccion: 'direccion',
    subdivisionId: 'subdivisionId',
    coordenadas: 'coordenadas',
    contactoTelefono: 'contactoTelefono',
    contactoEmail: 'contactoEmail',
    sitioWeb: 'sitioWeb',
    redesSociales: 'redesSociales',
    estado: 'estado',
    fechaAprobacion: 'fechaAprobacion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmprendimientoScalarFieldEnum = (typeof EmprendimientoScalarFieldEnum)[keyof typeof EmprendimientoScalarFieldEnum]


  export const RegistroAccesoScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    tipoEvento: 'tipoEvento',
    detalles: 'detalles',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RegistroAccesoScalarFieldEnum = (typeof RegistroAccesoScalarFieldEnum)[keyof typeof RegistroAccesoScalarFieldEnum]


  export const TokenInvalidadoScalarFieldEnum: {
    id: 'id',
    tokenHash: 'tokenHash',
    usuarioId: 'usuarioId',
    invalidadoEn: 'invalidadoEn',
    expiraEn: 'expiraEn',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type TokenInvalidadoScalarFieldEnum = (typeof TokenInvalidadoScalarFieldEnum)[keyof typeof TokenInvalidadoScalarFieldEnum]


  export const TuristaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellidos: 'apellidos',
    telefono: 'telefono',
    direccion: 'direccion',
    edad: 'edad',
    sexo: 'sexo',
    pais: 'pais',
    peticionesEspeciales: 'peticionesEspeciales',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TuristaScalarFieldEnum = (typeof TuristaScalarFieldEnum)[keyof typeof TuristaScalarFieldEnum]


  export const LugarTuristicoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    direccion: 'direccion',
    coordenadas: 'coordenadas',
    horarioApertura: 'horarioApertura',
    horarioCierre: 'horarioCierre',
    costoEntrada: 'costoEntrada',
    recomendaciones: 'recomendaciones',
    restricciones: 'restricciones',
    esDestacado: 'esDestacado',
    estado: 'estado',
    imagenUrl: 'imagenUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LugarTuristicoScalarFieldEnum = (typeof LugarTuristicoScalarFieldEnum)[keyof typeof LugarTuristicoScalarFieldEnum]


  export const ServicioEmprendedorScalarFieldEnum: {
    id: 'id',
    servicioId: 'servicioId',
    emprendimientoId: 'emprendimientoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServicioEmprendedorScalarFieldEnum = (typeof ServicioEmprendedorScalarFieldEnum)[keyof typeof ServicioEmprendedorScalarFieldEnum]


  export const ServicioScalarFieldEnum: {
    id: 'id',
    tipoServicioId: 'tipoServicioId',
    nombre: 'nombre',
    descripcion: 'descripcion',
    precioBase: 'precioBase',
    moneda: 'moneda',
    estado: 'estado',
    imagenUrl: 'imagenUrl',
    detallesServicio: 'detallesServicio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServicioScalarFieldEnum = (typeof ServicioScalarFieldEnum)[keyof typeof ServicioScalarFieldEnum]


  export const PaqueteTuristicoServicioScalarFieldEnum: {
    id: 'id',
    servicioId: 'servicioId',
    paqueteTuristicoId: 'paqueteTuristicoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaqueteTuristicoServicioScalarFieldEnum = (typeof PaqueteTuristicoServicioScalarFieldEnum)[keyof typeof PaqueteTuristicoServicioScalarFieldEnum]


  export const PaqueteTuristicoScalarFieldEnum: {
    id: 'id',
    emprendimientoId: 'emprendimientoId',
    nombre: 'nombre',
    descripcion: 'descripcion',
    duracionDias: 'duracionDias',
    duracionNoches: 'duracionNoches',
    precioPorPersona: 'precioPorPersona',
    moneda: 'moneda',
    capacidadMaxima: 'capacidadMaxima',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    lugaresVisitados: 'lugaresVisitados',
    requisitos: 'requisitos',
    incluye: 'incluye',
    noIncluye: 'noIncluye',
    estado: 'estado',
    esPersonalizable: 'esPersonalizable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaqueteTuristicoScalarFieldEnum = (typeof PaqueteTuristicoScalarFieldEnum)[keyof typeof PaqueteTuristicoScalarFieldEnum]


  export const DisponibilidadPaqueteScalarFieldEnum: {
    id: 'id',
    paqueteId: 'paqueteId',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    cuposDisponibles: 'cuposDisponibles',
    precioEspecial: 'precioEspecial',
    notas: 'notas',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DisponibilidadPaqueteScalarFieldEnum = (typeof DisponibilidadPaqueteScalarFieldEnum)[keyof typeof DisponibilidadPaqueteScalarFieldEnum]


  export const TipoServicioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    imagenUrl: 'imagenUrl',
    requiereCupo: 'requiereCupo',
    createdAt: 'createdAt'
  };

  export type TipoServicioScalarFieldEnum = (typeof TipoServicioScalarFieldEnum)[keyof typeof TipoServicioScalarFieldEnum]


  export const ServicioDisponibilidadScalarFieldEnum: {
    id: 'id',
    servicioId: 'servicioId',
    fecha: 'fecha',
    cuposDisponibles: 'cuposDisponibles',
    precioEspecial: 'precioEspecial'
  };

  export type ServicioDisponibilidadScalarFieldEnum = (typeof ServicioDisponibilidadScalarFieldEnum)[keyof typeof ServicioDisponibilidadScalarFieldEnum]


  export const ResenaScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    tipoObjeto: 'tipoObjeto',
    calificacion: 'calificacion',
    comentario: 'comentario',
    fechaExperiencia: 'fechaExperiencia',
    respuestaOwner: 'respuestaOwner',
    fechaRespuesta: 'fechaRespuesta',
    estado: 'estado',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResenaScalarFieldEnum = (typeof ResenaScalarFieldEnum)[keyof typeof ResenaScalarFieldEnum]


  export const FavoritoScalarFieldEnum: {
    id: 'id',
    estado: 'estado',
    usuarioId: 'usuarioId',
    emprendimientoId: 'emprendimientoId',
    createdAt: 'createdAt'
  };

  export type FavoritoScalarFieldEnum = (typeof FavoritoScalarFieldEnum)[keyof typeof FavoritoScalarFieldEnum]


  export const ReservaScalarFieldEnum: {
    id: 'id',
    codigoReserva: 'codigoReserva',
    turistaId: 'turistaId',
    tipoReserva: 'tipoReserva',
    fechaReserva: 'fechaReserva',
    fechaInicio: 'fechaInicio',
    hora: 'hora',
    fechaFin: 'fechaFin',
    cantidadPersonas: 'cantidadPersonas',
    precioTotal: 'precioTotal',
    moneda: 'moneda',
    estado: 'estado',
    metodoPago: 'metodoPago',
    datosPago: 'datosPago',
    notas: 'notas',
    motivoCancelacion: 'motivoCancelacion',
    fechaCancelacion: 'fechaCancelacion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReservaScalarFieldEnum = (typeof ReservaScalarFieldEnum)[keyof typeof ReservaScalarFieldEnum]


  export const ItinerarioReservaScalarFieldEnum: {
    id: 'id',
    fecha: 'fecha',
    hora: 'hora',
    tipoEvento: 'tipoEvento',
    descripcion: 'descripcion',
    notas: 'notas',
    duracion: 'duracion',
    reservaId: 'reservaId',
    servicioId: 'servicioId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItinerarioReservaScalarFieldEnum = (typeof ItinerarioReservaScalarFieldEnum)[keyof typeof ItinerarioReservaScalarFieldEnum]


  export const ItinerarioLugarScalarFieldEnum: {
    id: 'id',
    itinerarioReservaId: 'itinerarioReservaId',
    lugarTuristicoId: 'lugarTuristicoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItinerarioLugarScalarFieldEnum = (typeof ItinerarioLugarScalarFieldEnum)[keyof typeof ItinerarioLugarScalarFieldEnum]


  export const PagoScalarFieldEnum: {
    id: 'id',
    reservaId: 'reservaId',
    codigoTransaccion: 'codigoTransaccion',
    montoTotal: 'montoTotal',
    moneda: 'moneda',
    estado: 'estado',
    fechaPago: 'fechaPago',
    datosMetodoPago: 'datosMetodoPago',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PagoScalarFieldEnum = (typeof PagoScalarFieldEnum)[keyof typeof PagoScalarFieldEnum]


  export const PagoDetalleScalarFieldEnum: {
    id: 'id',
    pagoId: 'pagoId',
    tipoPagoId: 'tipoPagoId',
    concepto: 'concepto',
    monto: 'monto',
    porcentajeImpuesto: 'porcentajeImpuesto',
    cantidad: 'cantidad',
    descripcion: 'descripcion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PagoDetalleScalarFieldEnum = (typeof PagoDetalleScalarFieldEnum)[keyof typeof PagoDetalleScalarFieldEnum]


  export const TipoPagoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    requiereVerificacion: 'requiereVerificacion',
    comisionPorcentaje: 'comisionPorcentaje',
    activo: 'activo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TipoPagoScalarFieldEnum = (typeof TipoPagoScalarFieldEnum)[keyof typeof TipoPagoScalarFieldEnum]


  export const ComprobanteScalarFieldEnum: {
    id: 'id',
    pagoId: 'pagoId',
    tipoComprobante: 'tipoComprobante',
    serie: 'serie',
    numero: 'numero',
    fechaEmision: 'fechaEmision',
    rucCliente: 'rucCliente',
    razonSocial: 'razonSocial',
    direccionCliente: 'direccionCliente',
    subtotal: 'subtotal',
    igv: 'igv',
    total: 'total',
    moneda: 'moneda',
    estado: 'estado',
    codigoSunat: 'codigoSunat',
    codigoHash: 'codigoHash',
    xmlUrl: 'xmlUrl',
    pdfUrl: 'pdfUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComprobanteScalarFieldEnum = (typeof ComprobanteScalarFieldEnum)[keyof typeof ComprobanteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    nombre?: StringFilter<"Role"> | string
    descripcion?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    rolesPermisos?: RolesPermisosListRelationFilter
    usuariosRoles?: UsuariosRolesListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rolesPermisos?: RolesPermisosOrderByRelationAggregateInput
    usuariosRoles?: UsuariosRolesOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    descripcion?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    rolesPermisos?: RolesPermisosListRelationFilter
    usuariosRoles?: UsuariosRolesListRelationFilter
  }, "id" | "nombre">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    nombre?: StringWithAggregatesFilter<"Role"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PermisoWhereInput = {
    AND?: PermisoWhereInput | PermisoWhereInput[]
    OR?: PermisoWhereInput[]
    NOT?: PermisoWhereInput | PermisoWhereInput[]
    id?: IntFilter<"Permiso"> | number
    nombre?: StringFilter<"Permiso"> | string
    descripcion?: StringNullableFilter<"Permiso"> | string | null
    createdAt?: DateTimeFilter<"Permiso"> | Date | string
    updatedAt?: DateTimeFilter<"Permiso"> | Date | string
    rolesPermisos?: RolesPermisosListRelationFilter
  }

  export type PermisoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rolesPermisos?: RolesPermisosOrderByRelationAggregateInput
  }

  export type PermisoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: PermisoWhereInput | PermisoWhereInput[]
    OR?: PermisoWhereInput[]
    NOT?: PermisoWhereInput | PermisoWhereInput[]
    descripcion?: StringNullableFilter<"Permiso"> | string | null
    createdAt?: DateTimeFilter<"Permiso"> | Date | string
    updatedAt?: DateTimeFilter<"Permiso"> | Date | string
    rolesPermisos?: RolesPermisosListRelationFilter
  }, "id" | "nombre">

  export type PermisoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermisoCountOrderByAggregateInput
    _avg?: PermisoAvgOrderByAggregateInput
    _max?: PermisoMaxOrderByAggregateInput
    _min?: PermisoMinOrderByAggregateInput
    _sum?: PermisoSumOrderByAggregateInput
  }

  export type PermisoScalarWhereWithAggregatesInput = {
    AND?: PermisoScalarWhereWithAggregatesInput | PermisoScalarWhereWithAggregatesInput[]
    OR?: PermisoScalarWhereWithAggregatesInput[]
    NOT?: PermisoScalarWhereWithAggregatesInput | PermisoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permiso"> | number
    nombre?: StringWithAggregatesFilter<"Permiso"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Permiso"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permiso"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permiso"> | Date | string
  }

  export type RolesPermisosWhereInput = {
    AND?: RolesPermisosWhereInput | RolesPermisosWhereInput[]
    OR?: RolesPermisosWhereInput[]
    NOT?: RolesPermisosWhereInput | RolesPermisosWhereInput[]
    id?: IntFilter<"RolesPermisos"> | number
    rolId?: IntFilter<"RolesPermisos"> | number
    permisoId?: IntFilter<"RolesPermisos"> | number
    createdAt?: DateTimeFilter<"RolesPermisos"> | Date | string
    updatedAt?: DateTimeFilter<"RolesPermisos"> | Date | string
    permiso?: XOR<PermisoScalarRelationFilter, PermisoWhereInput>
    rol?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type RolesPermisosOrderByWithRelationInput = {
    id?: SortOrder
    rolId?: SortOrder
    permisoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permiso?: PermisoOrderByWithRelationInput
    rol?: RoleOrderByWithRelationInput
  }

  export type RolesPermisosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    rolId_permisoId?: RolesPermisosRolIdPermisoIdCompoundUniqueInput
    AND?: RolesPermisosWhereInput | RolesPermisosWhereInput[]
    OR?: RolesPermisosWhereInput[]
    NOT?: RolesPermisosWhereInput | RolesPermisosWhereInput[]
    rolId?: IntFilter<"RolesPermisos"> | number
    permisoId?: IntFilter<"RolesPermisos"> | number
    createdAt?: DateTimeFilter<"RolesPermisos"> | Date | string
    updatedAt?: DateTimeFilter<"RolesPermisos"> | Date | string
    permiso?: XOR<PermisoScalarRelationFilter, PermisoWhereInput>
    rol?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "id" | "rolId_permisoId">

  export type RolesPermisosOrderByWithAggregationInput = {
    id?: SortOrder
    rolId?: SortOrder
    permisoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RolesPermisosCountOrderByAggregateInput
    _avg?: RolesPermisosAvgOrderByAggregateInput
    _max?: RolesPermisosMaxOrderByAggregateInput
    _min?: RolesPermisosMinOrderByAggregateInput
    _sum?: RolesPermisosSumOrderByAggregateInput
  }

  export type RolesPermisosScalarWhereWithAggregatesInput = {
    AND?: RolesPermisosScalarWhereWithAggregatesInput | RolesPermisosScalarWhereWithAggregatesInput[]
    OR?: RolesPermisosScalarWhereWithAggregatesInput[]
    NOT?: RolesPermisosScalarWhereWithAggregatesInput | RolesPermisosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RolesPermisos"> | number
    rolId?: IntWithAggregatesFilter<"RolesPermisos"> | number
    permisoId?: IntWithAggregatesFilter<"RolesPermisos"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RolesPermisos"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RolesPermisos"> | Date | string
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: IntFilter<"Country"> | number
    name?: StringFilter<"Country"> | string
    codeIso?: StringFilter<"Country"> | string
    createdAt?: DateTimeFilter<"Country"> | Date | string
    updatedAt?: DateTimeFilter<"Country"> | Date | string
    subdivisions?: SubdivisionListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    codeIso?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subdivisions?: SubdivisionOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    codeIso?: string
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    createdAt?: DateTimeFilter<"Country"> | Date | string
    updatedAt?: DateTimeFilter<"Country"> | Date | string
    subdivisions?: SubdivisionListRelationFilter
  }, "id" | "name" | "codeIso">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    codeIso?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Country"> | number
    name?: StringWithAggregatesFilter<"Country"> | string
    codeIso?: StringWithAggregatesFilter<"Country"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Country"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Country"> | Date | string
  }

  export type SubdivisionWhereInput = {
    AND?: SubdivisionWhereInput | SubdivisionWhereInput[]
    OR?: SubdivisionWhereInput[]
    NOT?: SubdivisionWhereInput | SubdivisionWhereInput[]
    id?: IntFilter<"Subdivision"> | number
    countryId?: IntFilter<"Subdivision"> | number
    name?: StringFilter<"Subdivision"> | string
    createdAt?: DateTimeFilter<"Subdivision"> | Date | string
    updatedAt?: DateTimeFilter<"Subdivision"> | Date | string
    emprendimientos?: EmprendimientoListRelationFilter
    personas?: PersonaListRelationFilter
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
  }

  export type SubdivisionOrderByWithRelationInput = {
    id?: SortOrder
    countryId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emprendimientos?: EmprendimientoOrderByRelationAggregateInput
    personas?: PersonaOrderByRelationAggregateInput
    country?: CountryOrderByWithRelationInput
  }

  export type SubdivisionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    countryId_name?: SubdivisionCountryIdNameCompoundUniqueInput
    AND?: SubdivisionWhereInput | SubdivisionWhereInput[]
    OR?: SubdivisionWhereInput[]
    NOT?: SubdivisionWhereInput | SubdivisionWhereInput[]
    countryId?: IntFilter<"Subdivision"> | number
    name?: StringFilter<"Subdivision"> | string
    createdAt?: DateTimeFilter<"Subdivision"> | Date | string
    updatedAt?: DateTimeFilter<"Subdivision"> | Date | string
    emprendimientos?: EmprendimientoListRelationFilter
    personas?: PersonaListRelationFilter
    country?: XOR<CountryScalarRelationFilter, CountryWhereInput>
  }, "id" | "countryId_name">

  export type SubdivisionOrderByWithAggregationInput = {
    id?: SortOrder
    countryId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubdivisionCountOrderByAggregateInput
    _avg?: SubdivisionAvgOrderByAggregateInput
    _max?: SubdivisionMaxOrderByAggregateInput
    _min?: SubdivisionMinOrderByAggregateInput
    _sum?: SubdivisionSumOrderByAggregateInput
  }

  export type SubdivisionScalarWhereWithAggregatesInput = {
    AND?: SubdivisionScalarWhereWithAggregatesInput | SubdivisionScalarWhereWithAggregatesInput[]
    OR?: SubdivisionScalarWhereWithAggregatesInput[]
    NOT?: SubdivisionScalarWhereWithAggregatesInput | SubdivisionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subdivision"> | number
    countryId?: IntWithAggregatesFilter<"Subdivision"> | number
    name?: StringWithAggregatesFilter<"Subdivision"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subdivision"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subdivision"> | Date | string
  }

  export type PersonaWhereInput = {
    AND?: PersonaWhereInput | PersonaWhereInput[]
    OR?: PersonaWhereInput[]
    NOT?: PersonaWhereInput | PersonaWhereInput[]
    id?: IntFilter<"Persona"> | number
    nombre?: StringFilter<"Persona"> | string
    apellidos?: StringFilter<"Persona"> | string
    telefono?: StringNullableFilter<"Persona"> | string | null
    direccion?: StringNullableFilter<"Persona"> | string | null
    fotoPerfilUrl?: StringNullableFilter<"Persona"> | string | null
    fechaNacimiento?: DateTimeNullableFilter<"Persona"> | Date | string | null
    subdivisionId?: IntFilter<"Persona"> | number
    createdAt?: DateTimeFilter<"Persona"> | Date | string
    updatedAt?: DateTimeFilter<"Persona"> | Date | string
    subdivision?: XOR<SubdivisionScalarRelationFilter, SubdivisionWhereInput>
    usuario?: XOR<UsuarioNullableScalarRelationFilter, UsuarioWhereInput> | null
  }

  export type PersonaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    fotoPerfilUrl?: SortOrderInput | SortOrder
    fechaNacimiento?: SortOrderInput | SortOrder
    subdivisionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subdivision?: SubdivisionOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type PersonaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PersonaWhereInput | PersonaWhereInput[]
    OR?: PersonaWhereInput[]
    NOT?: PersonaWhereInput | PersonaWhereInput[]
    nombre?: StringFilter<"Persona"> | string
    apellidos?: StringFilter<"Persona"> | string
    telefono?: StringNullableFilter<"Persona"> | string | null
    direccion?: StringNullableFilter<"Persona"> | string | null
    fotoPerfilUrl?: StringNullableFilter<"Persona"> | string | null
    fechaNacimiento?: DateTimeNullableFilter<"Persona"> | Date | string | null
    subdivisionId?: IntFilter<"Persona"> | number
    createdAt?: DateTimeFilter<"Persona"> | Date | string
    updatedAt?: DateTimeFilter<"Persona"> | Date | string
    subdivision?: XOR<SubdivisionScalarRelationFilter, SubdivisionWhereInput>
    usuario?: XOR<UsuarioNullableScalarRelationFilter, UsuarioWhereInput> | null
  }, "id">

  export type PersonaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    fotoPerfilUrl?: SortOrderInput | SortOrder
    fechaNacimiento?: SortOrderInput | SortOrder
    subdivisionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PersonaCountOrderByAggregateInput
    _avg?: PersonaAvgOrderByAggregateInput
    _max?: PersonaMaxOrderByAggregateInput
    _min?: PersonaMinOrderByAggregateInput
    _sum?: PersonaSumOrderByAggregateInput
  }

  export type PersonaScalarWhereWithAggregatesInput = {
    AND?: PersonaScalarWhereWithAggregatesInput | PersonaScalarWhereWithAggregatesInput[]
    OR?: PersonaScalarWhereWithAggregatesInput[]
    NOT?: PersonaScalarWhereWithAggregatesInput | PersonaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Persona"> | number
    nombre?: StringWithAggregatesFilter<"Persona"> | string
    apellidos?: StringWithAggregatesFilter<"Persona"> | string
    telefono?: StringNullableWithAggregatesFilter<"Persona"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"Persona"> | string | null
    fotoPerfilUrl?: StringNullableWithAggregatesFilter<"Persona"> | string | null
    fechaNacimiento?: DateTimeNullableWithAggregatesFilter<"Persona"> | Date | string | null
    subdivisionId?: IntWithAggregatesFilter<"Persona"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Persona"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Persona"> | Date | string
  }

  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    personaId?: IntFilter<"Usuario"> | number
    email?: StringFilter<"Usuario"> | string
    passwordHash?: StringFilter<"Usuario"> | string
    recoveryToken?: StringNullableFilter<"Usuario"> | string | null
    recoveryTokenExpiresAt?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    emailVerificationToken?: StringNullableFilter<"Usuario"> | string | null
    emailVerified?: BoolFilter<"Usuario"> | boolean
    estaActivo?: BoolFilter<"Usuario"> | boolean
    ultimoAcceso?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    preferencias?: JsonFilter<"Usuario">
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    emprendimientos?: EmprendimientoListRelationFilter
    favoritos?: FavoritoListRelationFilter
    registroAccesos?: RegistroAccesoListRelationFilter
    resenas?: ResenaListRelationFilter
    tokensInvalidados?: TokenInvalidadoListRelationFilter
    persona?: XOR<PersonaScalarRelationFilter, PersonaWhereInput>
    usuariosRoles?: UsuariosRolesListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    personaId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    recoveryToken?: SortOrderInput | SortOrder
    recoveryTokenExpiresAt?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    estaActivo?: SortOrder
    ultimoAcceso?: SortOrderInput | SortOrder
    preferencias?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emprendimientos?: EmprendimientoOrderByRelationAggregateInput
    favoritos?: FavoritoOrderByRelationAggregateInput
    registroAccesos?: RegistroAccesoOrderByRelationAggregateInput
    resenas?: ResenaOrderByRelationAggregateInput
    tokensInvalidados?: TokenInvalidadoOrderByRelationAggregateInput
    persona?: PersonaOrderByWithRelationInput
    usuariosRoles?: UsuariosRolesOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    personaId?: number
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    passwordHash?: StringFilter<"Usuario"> | string
    recoveryToken?: StringNullableFilter<"Usuario"> | string | null
    recoveryTokenExpiresAt?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    emailVerificationToken?: StringNullableFilter<"Usuario"> | string | null
    emailVerified?: BoolFilter<"Usuario"> | boolean
    estaActivo?: BoolFilter<"Usuario"> | boolean
    ultimoAcceso?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    preferencias?: JsonFilter<"Usuario">
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    emprendimientos?: EmprendimientoListRelationFilter
    favoritos?: FavoritoListRelationFilter
    registroAccesos?: RegistroAccesoListRelationFilter
    resenas?: ResenaListRelationFilter
    tokensInvalidados?: TokenInvalidadoListRelationFilter
    persona?: XOR<PersonaScalarRelationFilter, PersonaWhereInput>
    usuariosRoles?: UsuariosRolesListRelationFilter
  }, "id" | "personaId" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    personaId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    recoveryToken?: SortOrderInput | SortOrder
    recoveryTokenExpiresAt?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    estaActivo?: SortOrder
    ultimoAcceso?: SortOrderInput | SortOrder
    preferencias?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    personaId?: IntWithAggregatesFilter<"Usuario"> | number
    email?: StringWithAggregatesFilter<"Usuario"> | string
    passwordHash?: StringWithAggregatesFilter<"Usuario"> | string
    recoveryToken?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    recoveryTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
    emailVerificationToken?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"Usuario"> | boolean
    estaActivo?: BoolWithAggregatesFilter<"Usuario"> | boolean
    ultimoAcceso?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
    preferencias?: JsonWithAggregatesFilter<"Usuario">
    createdAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type UsuariosRolesWhereInput = {
    AND?: UsuariosRolesWhereInput | UsuariosRolesWhereInput[]
    OR?: UsuariosRolesWhereInput[]
    NOT?: UsuariosRolesWhereInput | UsuariosRolesWhereInput[]
    id?: IntFilter<"UsuariosRoles"> | number
    rolId?: IntFilter<"UsuariosRoles"> | number
    usuarioId?: IntFilter<"UsuariosRoles"> | number
    createdAt?: DateTimeFilter<"UsuariosRoles"> | Date | string
    updatedAt?: DateTimeFilter<"UsuariosRoles"> | Date | string
    rol?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type UsuariosRolesOrderByWithRelationInput = {
    id?: SortOrder
    rolId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rol?: RoleOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type UsuariosRolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    usuarioId_rolId?: UsuariosRolesUsuarioIdRolIdCompoundUniqueInput
    AND?: UsuariosRolesWhereInput | UsuariosRolesWhereInput[]
    OR?: UsuariosRolesWhereInput[]
    NOT?: UsuariosRolesWhereInput | UsuariosRolesWhereInput[]
    rolId?: IntFilter<"UsuariosRoles"> | number
    usuarioId?: IntFilter<"UsuariosRoles"> | number
    createdAt?: DateTimeFilter<"UsuariosRoles"> | Date | string
    updatedAt?: DateTimeFilter<"UsuariosRoles"> | Date | string
    rol?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id" | "usuarioId_rolId">

  export type UsuariosRolesOrderByWithAggregationInput = {
    id?: SortOrder
    rolId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsuariosRolesCountOrderByAggregateInput
    _avg?: UsuariosRolesAvgOrderByAggregateInput
    _max?: UsuariosRolesMaxOrderByAggregateInput
    _min?: UsuariosRolesMinOrderByAggregateInput
    _sum?: UsuariosRolesSumOrderByAggregateInput
  }

  export type UsuariosRolesScalarWhereWithAggregatesInput = {
    AND?: UsuariosRolesScalarWhereWithAggregatesInput | UsuariosRolesScalarWhereWithAggregatesInput[]
    OR?: UsuariosRolesScalarWhereWithAggregatesInput[]
    NOT?: UsuariosRolesScalarWhereWithAggregatesInput | UsuariosRolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UsuariosRoles"> | number
    rolId?: IntWithAggregatesFilter<"UsuariosRoles"> | number
    usuarioId?: IntWithAggregatesFilter<"UsuariosRoles"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UsuariosRoles"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UsuariosRoles"> | Date | string
  }

  export type EmprendimientoWhereInput = {
    AND?: EmprendimientoWhereInput | EmprendimientoWhereInput[]
    OR?: EmprendimientoWhereInput[]
    NOT?: EmprendimientoWhereInput | EmprendimientoWhereInput[]
    id?: IntFilter<"Emprendimiento"> | number
    usuarioId?: IntFilter<"Emprendimiento"> | number
    nombre?: StringFilter<"Emprendimiento"> | string
    descripcion?: StringNullableFilter<"Emprendimiento"> | string | null
    tipo?: StringFilter<"Emprendimiento"> | string
    direccion?: StringNullableFilter<"Emprendimiento"> | string | null
    subdivisionId?: IntNullableFilter<"Emprendimiento"> | number | null
    coordenadas?: StringNullableFilter<"Emprendimiento"> | string | null
    contactoTelefono?: StringNullableFilter<"Emprendimiento"> | string | null
    contactoEmail?: StringNullableFilter<"Emprendimiento"> | string | null
    sitioWeb?: StringNullableFilter<"Emprendimiento"> | string | null
    redesSociales?: JsonNullableFilter<"Emprendimiento">
    estado?: StringFilter<"Emprendimiento"> | string
    fechaAprobacion?: DateTimeNullableFilter<"Emprendimiento"> | Date | string | null
    createdAt?: DateTimeFilter<"Emprendimiento"> | Date | string
    updatedAt?: DateTimeFilter<"Emprendimiento"> | Date | string
    subdivision?: XOR<SubdivisionNullableScalarRelationFilter, SubdivisionWhereInput> | null
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    favoritos?: FavoritoListRelationFilter
    paquetesTuristicos?: PaqueteTuristicoListRelationFilter
    servicios?: ServicioEmprendedorListRelationFilter
  }

  export type EmprendimientoOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    tipo?: SortOrder
    direccion?: SortOrderInput | SortOrder
    subdivisionId?: SortOrderInput | SortOrder
    coordenadas?: SortOrderInput | SortOrder
    contactoTelefono?: SortOrderInput | SortOrder
    contactoEmail?: SortOrderInput | SortOrder
    sitioWeb?: SortOrderInput | SortOrder
    redesSociales?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaAprobacion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subdivision?: SubdivisionOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
    favoritos?: FavoritoOrderByRelationAggregateInput
    paquetesTuristicos?: PaqueteTuristicoOrderByRelationAggregateInput
    servicios?: ServicioEmprendedorOrderByRelationAggregateInput
  }

  export type EmprendimientoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmprendimientoWhereInput | EmprendimientoWhereInput[]
    OR?: EmprendimientoWhereInput[]
    NOT?: EmprendimientoWhereInput | EmprendimientoWhereInput[]
    usuarioId?: IntFilter<"Emprendimiento"> | number
    nombre?: StringFilter<"Emprendimiento"> | string
    descripcion?: StringNullableFilter<"Emprendimiento"> | string | null
    tipo?: StringFilter<"Emprendimiento"> | string
    direccion?: StringNullableFilter<"Emprendimiento"> | string | null
    subdivisionId?: IntNullableFilter<"Emprendimiento"> | number | null
    coordenadas?: StringNullableFilter<"Emprendimiento"> | string | null
    contactoTelefono?: StringNullableFilter<"Emprendimiento"> | string | null
    contactoEmail?: StringNullableFilter<"Emprendimiento"> | string | null
    sitioWeb?: StringNullableFilter<"Emprendimiento"> | string | null
    redesSociales?: JsonNullableFilter<"Emprendimiento">
    estado?: StringFilter<"Emprendimiento"> | string
    fechaAprobacion?: DateTimeNullableFilter<"Emprendimiento"> | Date | string | null
    createdAt?: DateTimeFilter<"Emprendimiento"> | Date | string
    updatedAt?: DateTimeFilter<"Emprendimiento"> | Date | string
    subdivision?: XOR<SubdivisionNullableScalarRelationFilter, SubdivisionWhereInput> | null
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
    favoritos?: FavoritoListRelationFilter
    paquetesTuristicos?: PaqueteTuristicoListRelationFilter
    servicios?: ServicioEmprendedorListRelationFilter
  }, "id">

  export type EmprendimientoOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    tipo?: SortOrder
    direccion?: SortOrderInput | SortOrder
    subdivisionId?: SortOrderInput | SortOrder
    coordenadas?: SortOrderInput | SortOrder
    contactoTelefono?: SortOrderInput | SortOrder
    contactoEmail?: SortOrderInput | SortOrder
    sitioWeb?: SortOrderInput | SortOrder
    redesSociales?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaAprobacion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmprendimientoCountOrderByAggregateInput
    _avg?: EmprendimientoAvgOrderByAggregateInput
    _max?: EmprendimientoMaxOrderByAggregateInput
    _min?: EmprendimientoMinOrderByAggregateInput
    _sum?: EmprendimientoSumOrderByAggregateInput
  }

  export type EmprendimientoScalarWhereWithAggregatesInput = {
    AND?: EmprendimientoScalarWhereWithAggregatesInput | EmprendimientoScalarWhereWithAggregatesInput[]
    OR?: EmprendimientoScalarWhereWithAggregatesInput[]
    NOT?: EmprendimientoScalarWhereWithAggregatesInput | EmprendimientoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Emprendimiento"> | number
    usuarioId?: IntWithAggregatesFilter<"Emprendimiento"> | number
    nombre?: StringWithAggregatesFilter<"Emprendimiento"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Emprendimiento"> | string | null
    tipo?: StringWithAggregatesFilter<"Emprendimiento"> | string
    direccion?: StringNullableWithAggregatesFilter<"Emprendimiento"> | string | null
    subdivisionId?: IntNullableWithAggregatesFilter<"Emprendimiento"> | number | null
    coordenadas?: StringNullableWithAggregatesFilter<"Emprendimiento"> | string | null
    contactoTelefono?: StringNullableWithAggregatesFilter<"Emprendimiento"> | string | null
    contactoEmail?: StringNullableWithAggregatesFilter<"Emprendimiento"> | string | null
    sitioWeb?: StringNullableWithAggregatesFilter<"Emprendimiento"> | string | null
    redesSociales?: JsonNullableWithAggregatesFilter<"Emprendimiento">
    estado?: StringWithAggregatesFilter<"Emprendimiento"> | string
    fechaAprobacion?: DateTimeNullableWithAggregatesFilter<"Emprendimiento"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Emprendimiento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Emprendimiento"> | Date | string
  }

  export type RegistroAccesoWhereInput = {
    AND?: RegistroAccesoWhereInput | RegistroAccesoWhereInput[]
    OR?: RegistroAccesoWhereInput[]
    NOT?: RegistroAccesoWhereInput | RegistroAccesoWhereInput[]
    id?: IntFilter<"RegistroAcceso"> | number
    usuarioId?: IntFilter<"RegistroAcceso"> | number
    ipAddress?: StringFilter<"RegistroAcceso"> | string
    userAgent?: StringFilter<"RegistroAcceso"> | string
    tipoEvento?: StringFilter<"RegistroAcceso"> | string
    detalles?: JsonNullableFilter<"RegistroAcceso">
    createdAt?: DateTimeFilter<"RegistroAcceso"> | Date | string
    updatedAt?: DateTimeFilter<"RegistroAcceso"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type RegistroAccesoOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    tipoEvento?: SortOrder
    detalles?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type RegistroAccesoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegistroAccesoWhereInput | RegistroAccesoWhereInput[]
    OR?: RegistroAccesoWhereInput[]
    NOT?: RegistroAccesoWhereInput | RegistroAccesoWhereInput[]
    usuarioId?: IntFilter<"RegistroAcceso"> | number
    ipAddress?: StringFilter<"RegistroAcceso"> | string
    userAgent?: StringFilter<"RegistroAcceso"> | string
    tipoEvento?: StringFilter<"RegistroAcceso"> | string
    detalles?: JsonNullableFilter<"RegistroAcceso">
    createdAt?: DateTimeFilter<"RegistroAcceso"> | Date | string
    updatedAt?: DateTimeFilter<"RegistroAcceso"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type RegistroAccesoOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    tipoEvento?: SortOrder
    detalles?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RegistroAccesoCountOrderByAggregateInput
    _avg?: RegistroAccesoAvgOrderByAggregateInput
    _max?: RegistroAccesoMaxOrderByAggregateInput
    _min?: RegistroAccesoMinOrderByAggregateInput
    _sum?: RegistroAccesoSumOrderByAggregateInput
  }

  export type RegistroAccesoScalarWhereWithAggregatesInput = {
    AND?: RegistroAccesoScalarWhereWithAggregatesInput | RegistroAccesoScalarWhereWithAggregatesInput[]
    OR?: RegistroAccesoScalarWhereWithAggregatesInput[]
    NOT?: RegistroAccesoScalarWhereWithAggregatesInput | RegistroAccesoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RegistroAcceso"> | number
    usuarioId?: IntWithAggregatesFilter<"RegistroAcceso"> | number
    ipAddress?: StringWithAggregatesFilter<"RegistroAcceso"> | string
    userAgent?: StringWithAggregatesFilter<"RegistroAcceso"> | string
    tipoEvento?: StringWithAggregatesFilter<"RegistroAcceso"> | string
    detalles?: JsonNullableWithAggregatesFilter<"RegistroAcceso">
    createdAt?: DateTimeWithAggregatesFilter<"RegistroAcceso"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RegistroAcceso"> | Date | string
  }

  export type TokenInvalidadoWhereInput = {
    AND?: TokenInvalidadoWhereInput | TokenInvalidadoWhereInput[]
    OR?: TokenInvalidadoWhereInput[]
    NOT?: TokenInvalidadoWhereInput | TokenInvalidadoWhereInput[]
    id?: IntFilter<"TokenInvalidado"> | number
    tokenHash?: StringFilter<"TokenInvalidado"> | string
    usuarioId?: IntFilter<"TokenInvalidado"> | number
    invalidadoEn?: DateTimeFilter<"TokenInvalidado"> | Date | string
    expiraEn?: DateTimeFilter<"TokenInvalidado"> | Date | string
    metadata?: JsonFilter<"TokenInvalidado">
    createdAt?: DateTimeFilter<"TokenInvalidado"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type TokenInvalidadoOrderByWithRelationInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    usuarioId?: SortOrder
    invalidadoEn?: SortOrder
    expiraEn?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type TokenInvalidadoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tokenHash?: string
    AND?: TokenInvalidadoWhereInput | TokenInvalidadoWhereInput[]
    OR?: TokenInvalidadoWhereInput[]
    NOT?: TokenInvalidadoWhereInput | TokenInvalidadoWhereInput[]
    usuarioId?: IntFilter<"TokenInvalidado"> | number
    invalidadoEn?: DateTimeFilter<"TokenInvalidado"> | Date | string
    expiraEn?: DateTimeFilter<"TokenInvalidado"> | Date | string
    metadata?: JsonFilter<"TokenInvalidado">
    createdAt?: DateTimeFilter<"TokenInvalidado"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id" | "tokenHash">

  export type TokenInvalidadoOrderByWithAggregationInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    usuarioId?: SortOrder
    invalidadoEn?: SortOrder
    expiraEn?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: TokenInvalidadoCountOrderByAggregateInput
    _avg?: TokenInvalidadoAvgOrderByAggregateInput
    _max?: TokenInvalidadoMaxOrderByAggregateInput
    _min?: TokenInvalidadoMinOrderByAggregateInput
    _sum?: TokenInvalidadoSumOrderByAggregateInput
  }

  export type TokenInvalidadoScalarWhereWithAggregatesInput = {
    AND?: TokenInvalidadoScalarWhereWithAggregatesInput | TokenInvalidadoScalarWhereWithAggregatesInput[]
    OR?: TokenInvalidadoScalarWhereWithAggregatesInput[]
    NOT?: TokenInvalidadoScalarWhereWithAggregatesInput | TokenInvalidadoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TokenInvalidado"> | number
    tokenHash?: StringWithAggregatesFilter<"TokenInvalidado"> | string
    usuarioId?: IntWithAggregatesFilter<"TokenInvalidado"> | number
    invalidadoEn?: DateTimeWithAggregatesFilter<"TokenInvalidado"> | Date | string
    expiraEn?: DateTimeWithAggregatesFilter<"TokenInvalidado"> | Date | string
    metadata?: JsonWithAggregatesFilter<"TokenInvalidado">
    createdAt?: DateTimeWithAggregatesFilter<"TokenInvalidado"> | Date | string
  }

  export type TuristaWhereInput = {
    AND?: TuristaWhereInput | TuristaWhereInput[]
    OR?: TuristaWhereInput[]
    NOT?: TuristaWhereInput | TuristaWhereInput[]
    id?: IntFilter<"Turista"> | number
    nombre?: StringFilter<"Turista"> | string
    apellidos?: StringFilter<"Turista"> | string
    telefono?: StringFilter<"Turista"> | string
    direccion?: StringFilter<"Turista"> | string
    edad?: DecimalFilter<"Turista"> | Decimal | DecimalJsLike | number | string
    sexo?: StringFilter<"Turista"> | string
    pais?: StringFilter<"Turista"> | string
    peticionesEspeciales?: StringNullableFilter<"Turista"> | string | null
    email?: StringFilter<"Turista"> | string
    createdAt?: DateTimeFilter<"Turista"> | Date | string
    updatedAt?: DateTimeFilter<"Turista"> | Date | string
    reservas?: ReservaListRelationFilter
  }

  export type TuristaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    edad?: SortOrder
    sexo?: SortOrder
    pais?: SortOrder
    peticionesEspeciales?: SortOrderInput | SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reservas?: ReservaOrderByRelationAggregateInput
  }

  export type TuristaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: TuristaWhereInput | TuristaWhereInput[]
    OR?: TuristaWhereInput[]
    NOT?: TuristaWhereInput | TuristaWhereInput[]
    nombre?: StringFilter<"Turista"> | string
    apellidos?: StringFilter<"Turista"> | string
    telefono?: StringFilter<"Turista"> | string
    direccion?: StringFilter<"Turista"> | string
    edad?: DecimalFilter<"Turista"> | Decimal | DecimalJsLike | number | string
    sexo?: StringFilter<"Turista"> | string
    pais?: StringFilter<"Turista"> | string
    peticionesEspeciales?: StringNullableFilter<"Turista"> | string | null
    createdAt?: DateTimeFilter<"Turista"> | Date | string
    updatedAt?: DateTimeFilter<"Turista"> | Date | string
    reservas?: ReservaListRelationFilter
  }, "id" | "email">

  export type TuristaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    edad?: SortOrder
    sexo?: SortOrder
    pais?: SortOrder
    peticionesEspeciales?: SortOrderInput | SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TuristaCountOrderByAggregateInput
    _avg?: TuristaAvgOrderByAggregateInput
    _max?: TuristaMaxOrderByAggregateInput
    _min?: TuristaMinOrderByAggregateInput
    _sum?: TuristaSumOrderByAggregateInput
  }

  export type TuristaScalarWhereWithAggregatesInput = {
    AND?: TuristaScalarWhereWithAggregatesInput | TuristaScalarWhereWithAggregatesInput[]
    OR?: TuristaScalarWhereWithAggregatesInput[]
    NOT?: TuristaScalarWhereWithAggregatesInput | TuristaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Turista"> | number
    nombre?: StringWithAggregatesFilter<"Turista"> | string
    apellidos?: StringWithAggregatesFilter<"Turista"> | string
    telefono?: StringWithAggregatesFilter<"Turista"> | string
    direccion?: StringWithAggregatesFilter<"Turista"> | string
    edad?: DecimalWithAggregatesFilter<"Turista"> | Decimal | DecimalJsLike | number | string
    sexo?: StringWithAggregatesFilter<"Turista"> | string
    pais?: StringWithAggregatesFilter<"Turista"> | string
    peticionesEspeciales?: StringNullableWithAggregatesFilter<"Turista"> | string | null
    email?: StringWithAggregatesFilter<"Turista"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Turista"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Turista"> | Date | string
  }

  export type LugarTuristicoWhereInput = {
    AND?: LugarTuristicoWhereInput | LugarTuristicoWhereInput[]
    OR?: LugarTuristicoWhereInput[]
    NOT?: LugarTuristicoWhereInput | LugarTuristicoWhereInput[]
    id?: IntFilter<"LugarTuristico"> | number
    nombre?: StringFilter<"LugarTuristico"> | string
    descripcion?: StringFilter<"LugarTuristico"> | string
    direccion?: StringFilter<"LugarTuristico"> | string
    coordenadas?: StringFilter<"LugarTuristico"> | string
    horarioApertura?: DateTimeNullableFilter<"LugarTuristico"> | Date | string | null
    horarioCierre?: DateTimeNullableFilter<"LugarTuristico"> | Date | string | null
    costoEntrada?: DecimalNullableFilter<"LugarTuristico"> | Decimal | DecimalJsLike | number | string | null
    recomendaciones?: StringNullableFilter<"LugarTuristico"> | string | null
    restricciones?: StringNullableFilter<"LugarTuristico"> | string | null
    esDestacado?: BoolFilter<"LugarTuristico"> | boolean
    estado?: StringFilter<"LugarTuristico"> | string
    imagenUrl?: StringFilter<"LugarTuristico"> | string
    createdAt?: DateTimeFilter<"LugarTuristico"> | Date | string
    updatedAt?: DateTimeFilter<"LugarTuristico"> | Date | string
    itinerarioLugares?: ItinerarioLugarListRelationFilter
  }

  export type LugarTuristicoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    direccion?: SortOrder
    coordenadas?: SortOrder
    horarioApertura?: SortOrderInput | SortOrder
    horarioCierre?: SortOrderInput | SortOrder
    costoEntrada?: SortOrderInput | SortOrder
    recomendaciones?: SortOrderInput | SortOrder
    restricciones?: SortOrderInput | SortOrder
    esDestacado?: SortOrder
    estado?: SortOrder
    imagenUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    itinerarioLugares?: ItinerarioLugarOrderByRelationAggregateInput
  }

  export type LugarTuristicoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LugarTuristicoWhereInput | LugarTuristicoWhereInput[]
    OR?: LugarTuristicoWhereInput[]
    NOT?: LugarTuristicoWhereInput | LugarTuristicoWhereInput[]
    nombre?: StringFilter<"LugarTuristico"> | string
    descripcion?: StringFilter<"LugarTuristico"> | string
    direccion?: StringFilter<"LugarTuristico"> | string
    coordenadas?: StringFilter<"LugarTuristico"> | string
    horarioApertura?: DateTimeNullableFilter<"LugarTuristico"> | Date | string | null
    horarioCierre?: DateTimeNullableFilter<"LugarTuristico"> | Date | string | null
    costoEntrada?: DecimalNullableFilter<"LugarTuristico"> | Decimal | DecimalJsLike | number | string | null
    recomendaciones?: StringNullableFilter<"LugarTuristico"> | string | null
    restricciones?: StringNullableFilter<"LugarTuristico"> | string | null
    esDestacado?: BoolFilter<"LugarTuristico"> | boolean
    estado?: StringFilter<"LugarTuristico"> | string
    imagenUrl?: StringFilter<"LugarTuristico"> | string
    createdAt?: DateTimeFilter<"LugarTuristico"> | Date | string
    updatedAt?: DateTimeFilter<"LugarTuristico"> | Date | string
    itinerarioLugares?: ItinerarioLugarListRelationFilter
  }, "id">

  export type LugarTuristicoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    direccion?: SortOrder
    coordenadas?: SortOrder
    horarioApertura?: SortOrderInput | SortOrder
    horarioCierre?: SortOrderInput | SortOrder
    costoEntrada?: SortOrderInput | SortOrder
    recomendaciones?: SortOrderInput | SortOrder
    restricciones?: SortOrderInput | SortOrder
    esDestacado?: SortOrder
    estado?: SortOrder
    imagenUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LugarTuristicoCountOrderByAggregateInput
    _avg?: LugarTuristicoAvgOrderByAggregateInput
    _max?: LugarTuristicoMaxOrderByAggregateInput
    _min?: LugarTuristicoMinOrderByAggregateInput
    _sum?: LugarTuristicoSumOrderByAggregateInput
  }

  export type LugarTuristicoScalarWhereWithAggregatesInput = {
    AND?: LugarTuristicoScalarWhereWithAggregatesInput | LugarTuristicoScalarWhereWithAggregatesInput[]
    OR?: LugarTuristicoScalarWhereWithAggregatesInput[]
    NOT?: LugarTuristicoScalarWhereWithAggregatesInput | LugarTuristicoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LugarTuristico"> | number
    nombre?: StringWithAggregatesFilter<"LugarTuristico"> | string
    descripcion?: StringWithAggregatesFilter<"LugarTuristico"> | string
    direccion?: StringWithAggregatesFilter<"LugarTuristico"> | string
    coordenadas?: StringWithAggregatesFilter<"LugarTuristico"> | string
    horarioApertura?: DateTimeNullableWithAggregatesFilter<"LugarTuristico"> | Date | string | null
    horarioCierre?: DateTimeNullableWithAggregatesFilter<"LugarTuristico"> | Date | string | null
    costoEntrada?: DecimalNullableWithAggregatesFilter<"LugarTuristico"> | Decimal | DecimalJsLike | number | string | null
    recomendaciones?: StringNullableWithAggregatesFilter<"LugarTuristico"> | string | null
    restricciones?: StringNullableWithAggregatesFilter<"LugarTuristico"> | string | null
    esDestacado?: BoolWithAggregatesFilter<"LugarTuristico"> | boolean
    estado?: StringWithAggregatesFilter<"LugarTuristico"> | string
    imagenUrl?: StringWithAggregatesFilter<"LugarTuristico"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LugarTuristico"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LugarTuristico"> | Date | string
  }

  export type ServicioEmprendedorWhereInput = {
    AND?: ServicioEmprendedorWhereInput | ServicioEmprendedorWhereInput[]
    OR?: ServicioEmprendedorWhereInput[]
    NOT?: ServicioEmprendedorWhereInput | ServicioEmprendedorWhereInput[]
    id?: IntFilter<"ServicioEmprendedor"> | number
    servicioId?: IntFilter<"ServicioEmprendedor"> | number
    emprendimientoId?: IntFilter<"ServicioEmprendedor"> | number
    createdAt?: DateTimeFilter<"ServicioEmprendedor"> | Date | string
    updatedAt?: DateTimeFilter<"ServicioEmprendedor"> | Date | string
    emprendimiento?: XOR<EmprendimientoScalarRelationFilter, EmprendimientoWhereInput>
    servicio?: XOR<ServicioScalarRelationFilter, ServicioWhereInput>
  }

  export type ServicioEmprendedorOrderByWithRelationInput = {
    id?: SortOrder
    servicioId?: SortOrder
    emprendimientoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    emprendimiento?: EmprendimientoOrderByWithRelationInput
    servicio?: ServicioOrderByWithRelationInput
  }

  export type ServicioEmprendedorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServicioEmprendedorWhereInput | ServicioEmprendedorWhereInput[]
    OR?: ServicioEmprendedorWhereInput[]
    NOT?: ServicioEmprendedorWhereInput | ServicioEmprendedorWhereInput[]
    servicioId?: IntFilter<"ServicioEmprendedor"> | number
    emprendimientoId?: IntFilter<"ServicioEmprendedor"> | number
    createdAt?: DateTimeFilter<"ServicioEmprendedor"> | Date | string
    updatedAt?: DateTimeFilter<"ServicioEmprendedor"> | Date | string
    emprendimiento?: XOR<EmprendimientoScalarRelationFilter, EmprendimientoWhereInput>
    servicio?: XOR<ServicioScalarRelationFilter, ServicioWhereInput>
  }, "id">

  export type ServicioEmprendedorOrderByWithAggregationInput = {
    id?: SortOrder
    servicioId?: SortOrder
    emprendimientoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServicioEmprendedorCountOrderByAggregateInput
    _avg?: ServicioEmprendedorAvgOrderByAggregateInput
    _max?: ServicioEmprendedorMaxOrderByAggregateInput
    _min?: ServicioEmprendedorMinOrderByAggregateInput
    _sum?: ServicioEmprendedorSumOrderByAggregateInput
  }

  export type ServicioEmprendedorScalarWhereWithAggregatesInput = {
    AND?: ServicioEmprendedorScalarWhereWithAggregatesInput | ServicioEmprendedorScalarWhereWithAggregatesInput[]
    OR?: ServicioEmprendedorScalarWhereWithAggregatesInput[]
    NOT?: ServicioEmprendedorScalarWhereWithAggregatesInput | ServicioEmprendedorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServicioEmprendedor"> | number
    servicioId?: IntWithAggregatesFilter<"ServicioEmprendedor"> | number
    emprendimientoId?: IntWithAggregatesFilter<"ServicioEmprendedor"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ServicioEmprendedor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServicioEmprendedor"> | Date | string
  }

  export type ServicioWhereInput = {
    AND?: ServicioWhereInput | ServicioWhereInput[]
    OR?: ServicioWhereInput[]
    NOT?: ServicioWhereInput | ServicioWhereInput[]
    id?: IntFilter<"Servicio"> | number
    tipoServicioId?: IntFilter<"Servicio"> | number
    nombre?: StringFilter<"Servicio"> | string
    descripcion?: StringNullableFilter<"Servicio"> | string | null
    precioBase?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Servicio"> | string
    estado?: StringFilter<"Servicio"> | string
    imagenUrl?: StringFilter<"Servicio"> | string
    detallesServicio?: JsonFilter<"Servicio">
    createdAt?: DateTimeFilter<"Servicio"> | Date | string
    updatedAt?: DateTimeFilter<"Servicio"> | Date | string
    itinerariosReserva?: ItinerarioReservaListRelationFilter
    paquetesServicios?: PaqueteTuristicoServicioListRelationFilter
    tipoServicio?: XOR<TipoServicioScalarRelationFilter, TipoServicioWhereInput>
    disponibilidad?: ServicioDisponibilidadListRelationFilter
    serviciosEmprendedores?: ServicioEmprendedorListRelationFilter
  }

  export type ServicioOrderByWithRelationInput = {
    id?: SortOrder
    tipoServicioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    precioBase?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    imagenUrl?: SortOrder
    detallesServicio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    itinerariosReserva?: ItinerarioReservaOrderByRelationAggregateInput
    paquetesServicios?: PaqueteTuristicoServicioOrderByRelationAggregateInput
    tipoServicio?: TipoServicioOrderByWithRelationInput
    disponibilidad?: ServicioDisponibilidadOrderByRelationAggregateInput
    serviciosEmprendedores?: ServicioEmprendedorOrderByRelationAggregateInput
  }

  export type ServicioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServicioWhereInput | ServicioWhereInput[]
    OR?: ServicioWhereInput[]
    NOT?: ServicioWhereInput | ServicioWhereInput[]
    tipoServicioId?: IntFilter<"Servicio"> | number
    nombre?: StringFilter<"Servicio"> | string
    descripcion?: StringNullableFilter<"Servicio"> | string | null
    precioBase?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Servicio"> | string
    estado?: StringFilter<"Servicio"> | string
    imagenUrl?: StringFilter<"Servicio"> | string
    detallesServicio?: JsonFilter<"Servicio">
    createdAt?: DateTimeFilter<"Servicio"> | Date | string
    updatedAt?: DateTimeFilter<"Servicio"> | Date | string
    itinerariosReserva?: ItinerarioReservaListRelationFilter
    paquetesServicios?: PaqueteTuristicoServicioListRelationFilter
    tipoServicio?: XOR<TipoServicioScalarRelationFilter, TipoServicioWhereInput>
    disponibilidad?: ServicioDisponibilidadListRelationFilter
    serviciosEmprendedores?: ServicioEmprendedorListRelationFilter
  }, "id">

  export type ServicioOrderByWithAggregationInput = {
    id?: SortOrder
    tipoServicioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    precioBase?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    imagenUrl?: SortOrder
    detallesServicio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServicioCountOrderByAggregateInput
    _avg?: ServicioAvgOrderByAggregateInput
    _max?: ServicioMaxOrderByAggregateInput
    _min?: ServicioMinOrderByAggregateInput
    _sum?: ServicioSumOrderByAggregateInput
  }

  export type ServicioScalarWhereWithAggregatesInput = {
    AND?: ServicioScalarWhereWithAggregatesInput | ServicioScalarWhereWithAggregatesInput[]
    OR?: ServicioScalarWhereWithAggregatesInput[]
    NOT?: ServicioScalarWhereWithAggregatesInput | ServicioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Servicio"> | number
    tipoServicioId?: IntWithAggregatesFilter<"Servicio"> | number
    nombre?: StringWithAggregatesFilter<"Servicio"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Servicio"> | string | null
    precioBase?: DecimalWithAggregatesFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    moneda?: StringWithAggregatesFilter<"Servicio"> | string
    estado?: StringWithAggregatesFilter<"Servicio"> | string
    imagenUrl?: StringWithAggregatesFilter<"Servicio"> | string
    detallesServicio?: JsonWithAggregatesFilter<"Servicio">
    createdAt?: DateTimeWithAggregatesFilter<"Servicio"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Servicio"> | Date | string
  }

  export type PaqueteTuristicoServicioWhereInput = {
    AND?: PaqueteTuristicoServicioWhereInput | PaqueteTuristicoServicioWhereInput[]
    OR?: PaqueteTuristicoServicioWhereInput[]
    NOT?: PaqueteTuristicoServicioWhereInput | PaqueteTuristicoServicioWhereInput[]
    id?: IntFilter<"PaqueteTuristicoServicio"> | number
    servicioId?: IntFilter<"PaqueteTuristicoServicio"> | number
    paqueteTuristicoId?: IntFilter<"PaqueteTuristicoServicio"> | number
    createdAt?: DateTimeFilter<"PaqueteTuristicoServicio"> | Date | string
    updatedAt?: DateTimeFilter<"PaqueteTuristicoServicio"> | Date | string
    paqueteTuristico?: XOR<PaqueteTuristicoScalarRelationFilter, PaqueteTuristicoWhereInput>
    servicio?: XOR<ServicioScalarRelationFilter, ServicioWhereInput>
  }

  export type PaqueteTuristicoServicioOrderByWithRelationInput = {
    id?: SortOrder
    servicioId?: SortOrder
    paqueteTuristicoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paqueteTuristico?: PaqueteTuristicoOrderByWithRelationInput
    servicio?: ServicioOrderByWithRelationInput
  }

  export type PaqueteTuristicoServicioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaqueteTuristicoServicioWhereInput | PaqueteTuristicoServicioWhereInput[]
    OR?: PaqueteTuristicoServicioWhereInput[]
    NOT?: PaqueteTuristicoServicioWhereInput | PaqueteTuristicoServicioWhereInput[]
    servicioId?: IntFilter<"PaqueteTuristicoServicio"> | number
    paqueteTuristicoId?: IntFilter<"PaqueteTuristicoServicio"> | number
    createdAt?: DateTimeFilter<"PaqueteTuristicoServicio"> | Date | string
    updatedAt?: DateTimeFilter<"PaqueteTuristicoServicio"> | Date | string
    paqueteTuristico?: XOR<PaqueteTuristicoScalarRelationFilter, PaqueteTuristicoWhereInput>
    servicio?: XOR<ServicioScalarRelationFilter, ServicioWhereInput>
  }, "id">

  export type PaqueteTuristicoServicioOrderByWithAggregationInput = {
    id?: SortOrder
    servicioId?: SortOrder
    paqueteTuristicoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaqueteTuristicoServicioCountOrderByAggregateInput
    _avg?: PaqueteTuristicoServicioAvgOrderByAggregateInput
    _max?: PaqueteTuristicoServicioMaxOrderByAggregateInput
    _min?: PaqueteTuristicoServicioMinOrderByAggregateInput
    _sum?: PaqueteTuristicoServicioSumOrderByAggregateInput
  }

  export type PaqueteTuristicoServicioScalarWhereWithAggregatesInput = {
    AND?: PaqueteTuristicoServicioScalarWhereWithAggregatesInput | PaqueteTuristicoServicioScalarWhereWithAggregatesInput[]
    OR?: PaqueteTuristicoServicioScalarWhereWithAggregatesInput[]
    NOT?: PaqueteTuristicoServicioScalarWhereWithAggregatesInput | PaqueteTuristicoServicioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaqueteTuristicoServicio"> | number
    servicioId?: IntWithAggregatesFilter<"PaqueteTuristicoServicio"> | number
    paqueteTuristicoId?: IntWithAggregatesFilter<"PaqueteTuristicoServicio"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PaqueteTuristicoServicio"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaqueteTuristicoServicio"> | Date | string
  }

  export type PaqueteTuristicoWhereInput = {
    AND?: PaqueteTuristicoWhereInput | PaqueteTuristicoWhereInput[]
    OR?: PaqueteTuristicoWhereInput[]
    NOT?: PaqueteTuristicoWhereInput | PaqueteTuristicoWhereInput[]
    id?: IntFilter<"PaqueteTuristico"> | number
    emprendimientoId?: IntNullableFilter<"PaqueteTuristico"> | number | null
    nombre?: StringFilter<"PaqueteTuristico"> | string
    descripcion?: StringFilter<"PaqueteTuristico"> | string
    duracionDias?: IntFilter<"PaqueteTuristico"> | number
    duracionNoches?: IntNullableFilter<"PaqueteTuristico"> | number | null
    precioPorPersona?: DecimalFilter<"PaqueteTuristico"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"PaqueteTuristico"> | string
    capacidadMaxima?: IntNullableFilter<"PaqueteTuristico"> | number | null
    fechaInicio?: DateTimeNullableFilter<"PaqueteTuristico"> | Date | string | null
    fechaFin?: DateTimeNullableFilter<"PaqueteTuristico"> | Date | string | null
    lugaresVisitados?: JsonNullableFilter<"PaqueteTuristico">
    requisitos?: StringNullableFilter<"PaqueteTuristico"> | string | null
    incluye?: StringNullableFilter<"PaqueteTuristico"> | string | null
    noIncluye?: StringNullableFilter<"PaqueteTuristico"> | string | null
    estado?: StringFilter<"PaqueteTuristico"> | string
    esPersonalizable?: BoolFilter<"PaqueteTuristico"> | boolean
    createdAt?: DateTimeFilter<"PaqueteTuristico"> | Date | string
    updatedAt?: DateTimeFilter<"PaqueteTuristico"> | Date | string
    disponibilidad?: DisponibilidadPaqueteListRelationFilter
    emprendimiento?: XOR<EmprendimientoNullableScalarRelationFilter, EmprendimientoWhereInput> | null
    servicios?: PaqueteTuristicoServicioListRelationFilter
  }

  export type PaqueteTuristicoOrderByWithRelationInput = {
    id?: SortOrder
    emprendimientoId?: SortOrderInput | SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    duracionDias?: SortOrder
    duracionNoches?: SortOrderInput | SortOrder
    precioPorPersona?: SortOrder
    moneda?: SortOrder
    capacidadMaxima?: SortOrderInput | SortOrder
    fechaInicio?: SortOrderInput | SortOrder
    fechaFin?: SortOrderInput | SortOrder
    lugaresVisitados?: SortOrderInput | SortOrder
    requisitos?: SortOrderInput | SortOrder
    incluye?: SortOrderInput | SortOrder
    noIncluye?: SortOrderInput | SortOrder
    estado?: SortOrder
    esPersonalizable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    disponibilidad?: DisponibilidadPaqueteOrderByRelationAggregateInput
    emprendimiento?: EmprendimientoOrderByWithRelationInput
    servicios?: PaqueteTuristicoServicioOrderByRelationAggregateInput
  }

  export type PaqueteTuristicoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaqueteTuristicoWhereInput | PaqueteTuristicoWhereInput[]
    OR?: PaqueteTuristicoWhereInput[]
    NOT?: PaqueteTuristicoWhereInput | PaqueteTuristicoWhereInput[]
    emprendimientoId?: IntNullableFilter<"PaqueteTuristico"> | number | null
    nombre?: StringFilter<"PaqueteTuristico"> | string
    descripcion?: StringFilter<"PaqueteTuristico"> | string
    duracionDias?: IntFilter<"PaqueteTuristico"> | number
    duracionNoches?: IntNullableFilter<"PaqueteTuristico"> | number | null
    precioPorPersona?: DecimalFilter<"PaqueteTuristico"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"PaqueteTuristico"> | string
    capacidadMaxima?: IntNullableFilter<"PaqueteTuristico"> | number | null
    fechaInicio?: DateTimeNullableFilter<"PaqueteTuristico"> | Date | string | null
    fechaFin?: DateTimeNullableFilter<"PaqueteTuristico"> | Date | string | null
    lugaresVisitados?: JsonNullableFilter<"PaqueteTuristico">
    requisitos?: StringNullableFilter<"PaqueteTuristico"> | string | null
    incluye?: StringNullableFilter<"PaqueteTuristico"> | string | null
    noIncluye?: StringNullableFilter<"PaqueteTuristico"> | string | null
    estado?: StringFilter<"PaqueteTuristico"> | string
    esPersonalizable?: BoolFilter<"PaqueteTuristico"> | boolean
    createdAt?: DateTimeFilter<"PaqueteTuristico"> | Date | string
    updatedAt?: DateTimeFilter<"PaqueteTuristico"> | Date | string
    disponibilidad?: DisponibilidadPaqueteListRelationFilter
    emprendimiento?: XOR<EmprendimientoNullableScalarRelationFilter, EmprendimientoWhereInput> | null
    servicios?: PaqueteTuristicoServicioListRelationFilter
  }, "id">

  export type PaqueteTuristicoOrderByWithAggregationInput = {
    id?: SortOrder
    emprendimientoId?: SortOrderInput | SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    duracionDias?: SortOrder
    duracionNoches?: SortOrderInput | SortOrder
    precioPorPersona?: SortOrder
    moneda?: SortOrder
    capacidadMaxima?: SortOrderInput | SortOrder
    fechaInicio?: SortOrderInput | SortOrder
    fechaFin?: SortOrderInput | SortOrder
    lugaresVisitados?: SortOrderInput | SortOrder
    requisitos?: SortOrderInput | SortOrder
    incluye?: SortOrderInput | SortOrder
    noIncluye?: SortOrderInput | SortOrder
    estado?: SortOrder
    esPersonalizable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaqueteTuristicoCountOrderByAggregateInput
    _avg?: PaqueteTuristicoAvgOrderByAggregateInput
    _max?: PaqueteTuristicoMaxOrderByAggregateInput
    _min?: PaqueteTuristicoMinOrderByAggregateInput
    _sum?: PaqueteTuristicoSumOrderByAggregateInput
  }

  export type PaqueteTuristicoScalarWhereWithAggregatesInput = {
    AND?: PaqueteTuristicoScalarWhereWithAggregatesInput | PaqueteTuristicoScalarWhereWithAggregatesInput[]
    OR?: PaqueteTuristicoScalarWhereWithAggregatesInput[]
    NOT?: PaqueteTuristicoScalarWhereWithAggregatesInput | PaqueteTuristicoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaqueteTuristico"> | number
    emprendimientoId?: IntNullableWithAggregatesFilter<"PaqueteTuristico"> | number | null
    nombre?: StringWithAggregatesFilter<"PaqueteTuristico"> | string
    descripcion?: StringWithAggregatesFilter<"PaqueteTuristico"> | string
    duracionDias?: IntWithAggregatesFilter<"PaqueteTuristico"> | number
    duracionNoches?: IntNullableWithAggregatesFilter<"PaqueteTuristico"> | number | null
    precioPorPersona?: DecimalWithAggregatesFilter<"PaqueteTuristico"> | Decimal | DecimalJsLike | number | string
    moneda?: StringWithAggregatesFilter<"PaqueteTuristico"> | string
    capacidadMaxima?: IntNullableWithAggregatesFilter<"PaqueteTuristico"> | number | null
    fechaInicio?: DateTimeNullableWithAggregatesFilter<"PaqueteTuristico"> | Date | string | null
    fechaFin?: DateTimeNullableWithAggregatesFilter<"PaqueteTuristico"> | Date | string | null
    lugaresVisitados?: JsonNullableWithAggregatesFilter<"PaqueteTuristico">
    requisitos?: StringNullableWithAggregatesFilter<"PaqueteTuristico"> | string | null
    incluye?: StringNullableWithAggregatesFilter<"PaqueteTuristico"> | string | null
    noIncluye?: StringNullableWithAggregatesFilter<"PaqueteTuristico"> | string | null
    estado?: StringWithAggregatesFilter<"PaqueteTuristico"> | string
    esPersonalizable?: BoolWithAggregatesFilter<"PaqueteTuristico"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PaqueteTuristico"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaqueteTuristico"> | Date | string
  }

  export type DisponibilidadPaqueteWhereInput = {
    AND?: DisponibilidadPaqueteWhereInput | DisponibilidadPaqueteWhereInput[]
    OR?: DisponibilidadPaqueteWhereInput[]
    NOT?: DisponibilidadPaqueteWhereInput | DisponibilidadPaqueteWhereInput[]
    id?: IntFilter<"DisponibilidadPaquete"> | number
    paqueteId?: IntFilter<"DisponibilidadPaquete"> | number
    fechaInicio?: DateTimeFilter<"DisponibilidadPaquete"> | Date | string
    fechaFin?: DateTimeFilter<"DisponibilidadPaquete"> | Date | string
    cuposDisponibles?: IntFilter<"DisponibilidadPaquete"> | number
    precioEspecial?: DecimalNullableFilter<"DisponibilidadPaquete"> | Decimal | DecimalJsLike | number | string | null
    notas?: StringNullableFilter<"DisponibilidadPaquete"> | string | null
    createdAt?: DateTimeFilter<"DisponibilidadPaquete"> | Date | string
    updatedAt?: DateTimeFilter<"DisponibilidadPaquete"> | Date | string
    paquete?: XOR<PaqueteTuristicoScalarRelationFilter, PaqueteTuristicoWhereInput>
  }

  export type DisponibilidadPaqueteOrderByWithRelationInput = {
    id?: SortOrder
    paqueteId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrderInput | SortOrder
    notas?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paquete?: PaqueteTuristicoOrderByWithRelationInput
  }

  export type DisponibilidadPaqueteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    paqueteId_fechaInicio_fechaFin?: DisponibilidadPaquetePaqueteIdFechaInicioFechaFinCompoundUniqueInput
    AND?: DisponibilidadPaqueteWhereInput | DisponibilidadPaqueteWhereInput[]
    OR?: DisponibilidadPaqueteWhereInput[]
    NOT?: DisponibilidadPaqueteWhereInput | DisponibilidadPaqueteWhereInput[]
    paqueteId?: IntFilter<"DisponibilidadPaquete"> | number
    fechaInicio?: DateTimeFilter<"DisponibilidadPaquete"> | Date | string
    fechaFin?: DateTimeFilter<"DisponibilidadPaquete"> | Date | string
    cuposDisponibles?: IntFilter<"DisponibilidadPaquete"> | number
    precioEspecial?: DecimalNullableFilter<"DisponibilidadPaquete"> | Decimal | DecimalJsLike | number | string | null
    notas?: StringNullableFilter<"DisponibilidadPaquete"> | string | null
    createdAt?: DateTimeFilter<"DisponibilidadPaquete"> | Date | string
    updatedAt?: DateTimeFilter<"DisponibilidadPaquete"> | Date | string
    paquete?: XOR<PaqueteTuristicoScalarRelationFilter, PaqueteTuristicoWhereInput>
  }, "id" | "paqueteId_fechaInicio_fechaFin">

  export type DisponibilidadPaqueteOrderByWithAggregationInput = {
    id?: SortOrder
    paqueteId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrderInput | SortOrder
    notas?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DisponibilidadPaqueteCountOrderByAggregateInput
    _avg?: DisponibilidadPaqueteAvgOrderByAggregateInput
    _max?: DisponibilidadPaqueteMaxOrderByAggregateInput
    _min?: DisponibilidadPaqueteMinOrderByAggregateInput
    _sum?: DisponibilidadPaqueteSumOrderByAggregateInput
  }

  export type DisponibilidadPaqueteScalarWhereWithAggregatesInput = {
    AND?: DisponibilidadPaqueteScalarWhereWithAggregatesInput | DisponibilidadPaqueteScalarWhereWithAggregatesInput[]
    OR?: DisponibilidadPaqueteScalarWhereWithAggregatesInput[]
    NOT?: DisponibilidadPaqueteScalarWhereWithAggregatesInput | DisponibilidadPaqueteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DisponibilidadPaquete"> | number
    paqueteId?: IntWithAggregatesFilter<"DisponibilidadPaquete"> | number
    fechaInicio?: DateTimeWithAggregatesFilter<"DisponibilidadPaquete"> | Date | string
    fechaFin?: DateTimeWithAggregatesFilter<"DisponibilidadPaquete"> | Date | string
    cuposDisponibles?: IntWithAggregatesFilter<"DisponibilidadPaquete"> | number
    precioEspecial?: DecimalNullableWithAggregatesFilter<"DisponibilidadPaquete"> | Decimal | DecimalJsLike | number | string | null
    notas?: StringNullableWithAggregatesFilter<"DisponibilidadPaquete"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DisponibilidadPaquete"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DisponibilidadPaquete"> | Date | string
  }

  export type TipoServicioWhereInput = {
    AND?: TipoServicioWhereInput | TipoServicioWhereInput[]
    OR?: TipoServicioWhereInput[]
    NOT?: TipoServicioWhereInput | TipoServicioWhereInput[]
    id?: IntFilter<"TipoServicio"> | number
    nombre?: StringFilter<"TipoServicio"> | string
    descripcion?: StringNullableFilter<"TipoServicio"> | string | null
    imagenUrl?: StringFilter<"TipoServicio"> | string
    requiereCupo?: BoolFilter<"TipoServicio"> | boolean
    createdAt?: DateTimeFilter<"TipoServicio"> | Date | string
    servicios?: ServicioListRelationFilter
  }

  export type TipoServicioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    imagenUrl?: SortOrder
    requiereCupo?: SortOrder
    createdAt?: SortOrder
    servicios?: ServicioOrderByRelationAggregateInput
  }

  export type TipoServicioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TipoServicioWhereInput | TipoServicioWhereInput[]
    OR?: TipoServicioWhereInput[]
    NOT?: TipoServicioWhereInput | TipoServicioWhereInput[]
    nombre?: StringFilter<"TipoServicio"> | string
    descripcion?: StringNullableFilter<"TipoServicio"> | string | null
    imagenUrl?: StringFilter<"TipoServicio"> | string
    requiereCupo?: BoolFilter<"TipoServicio"> | boolean
    createdAt?: DateTimeFilter<"TipoServicio"> | Date | string
    servicios?: ServicioListRelationFilter
  }, "id">

  export type TipoServicioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    imagenUrl?: SortOrder
    requiereCupo?: SortOrder
    createdAt?: SortOrder
    _count?: TipoServicioCountOrderByAggregateInput
    _avg?: TipoServicioAvgOrderByAggregateInput
    _max?: TipoServicioMaxOrderByAggregateInput
    _min?: TipoServicioMinOrderByAggregateInput
    _sum?: TipoServicioSumOrderByAggregateInput
  }

  export type TipoServicioScalarWhereWithAggregatesInput = {
    AND?: TipoServicioScalarWhereWithAggregatesInput | TipoServicioScalarWhereWithAggregatesInput[]
    OR?: TipoServicioScalarWhereWithAggregatesInput[]
    NOT?: TipoServicioScalarWhereWithAggregatesInput | TipoServicioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoServicio"> | number
    nombre?: StringWithAggregatesFilter<"TipoServicio"> | string
    descripcion?: StringNullableWithAggregatesFilter<"TipoServicio"> | string | null
    imagenUrl?: StringWithAggregatesFilter<"TipoServicio"> | string
    requiereCupo?: BoolWithAggregatesFilter<"TipoServicio"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TipoServicio"> | Date | string
  }

  export type ServicioDisponibilidadWhereInput = {
    AND?: ServicioDisponibilidadWhereInput | ServicioDisponibilidadWhereInput[]
    OR?: ServicioDisponibilidadWhereInput[]
    NOT?: ServicioDisponibilidadWhereInput | ServicioDisponibilidadWhereInput[]
    id?: IntFilter<"ServicioDisponibilidad"> | number
    servicioId?: IntFilter<"ServicioDisponibilidad"> | number
    fecha?: DateTimeFilter<"ServicioDisponibilidad"> | Date | string
    cuposDisponibles?: IntFilter<"ServicioDisponibilidad"> | number
    precioEspecial?: DecimalNullableFilter<"ServicioDisponibilidad"> | Decimal | DecimalJsLike | number | string | null
    servicio?: XOR<ServicioScalarRelationFilter, ServicioWhereInput>
  }

  export type ServicioDisponibilidadOrderByWithRelationInput = {
    id?: SortOrder
    servicioId?: SortOrder
    fecha?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrderInput | SortOrder
    servicio?: ServicioOrderByWithRelationInput
  }

  export type ServicioDisponibilidadWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    servicioId_fecha?: ServicioDisponibilidadServicioIdFechaCompoundUniqueInput
    AND?: ServicioDisponibilidadWhereInput | ServicioDisponibilidadWhereInput[]
    OR?: ServicioDisponibilidadWhereInput[]
    NOT?: ServicioDisponibilidadWhereInput | ServicioDisponibilidadWhereInput[]
    servicioId?: IntFilter<"ServicioDisponibilidad"> | number
    fecha?: DateTimeFilter<"ServicioDisponibilidad"> | Date | string
    cuposDisponibles?: IntFilter<"ServicioDisponibilidad"> | number
    precioEspecial?: DecimalNullableFilter<"ServicioDisponibilidad"> | Decimal | DecimalJsLike | number | string | null
    servicio?: XOR<ServicioScalarRelationFilter, ServicioWhereInput>
  }, "id" | "servicioId_fecha">

  export type ServicioDisponibilidadOrderByWithAggregationInput = {
    id?: SortOrder
    servicioId?: SortOrder
    fecha?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrderInput | SortOrder
    _count?: ServicioDisponibilidadCountOrderByAggregateInput
    _avg?: ServicioDisponibilidadAvgOrderByAggregateInput
    _max?: ServicioDisponibilidadMaxOrderByAggregateInput
    _min?: ServicioDisponibilidadMinOrderByAggregateInput
    _sum?: ServicioDisponibilidadSumOrderByAggregateInput
  }

  export type ServicioDisponibilidadScalarWhereWithAggregatesInput = {
    AND?: ServicioDisponibilidadScalarWhereWithAggregatesInput | ServicioDisponibilidadScalarWhereWithAggregatesInput[]
    OR?: ServicioDisponibilidadScalarWhereWithAggregatesInput[]
    NOT?: ServicioDisponibilidadScalarWhereWithAggregatesInput | ServicioDisponibilidadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServicioDisponibilidad"> | number
    servicioId?: IntWithAggregatesFilter<"ServicioDisponibilidad"> | number
    fecha?: DateTimeWithAggregatesFilter<"ServicioDisponibilidad"> | Date | string
    cuposDisponibles?: IntWithAggregatesFilter<"ServicioDisponibilidad"> | number
    precioEspecial?: DecimalNullableWithAggregatesFilter<"ServicioDisponibilidad"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ResenaWhereInput = {
    AND?: ResenaWhereInput | ResenaWhereInput[]
    OR?: ResenaWhereInput[]
    NOT?: ResenaWhereInput | ResenaWhereInput[]
    id?: IntFilter<"Resena"> | number
    usuarioId?: IntFilter<"Resena"> | number
    tipoObjeto?: StringFilter<"Resena"> | string
    calificacion?: IntFilter<"Resena"> | number
    comentario?: StringNullableFilter<"Resena"> | string | null
    fechaExperiencia?: DateTimeNullableFilter<"Resena"> | Date | string | null
    respuestaOwner?: StringNullableFilter<"Resena"> | string | null
    fechaRespuesta?: DateTimeNullableFilter<"Resena"> | Date | string | null
    estado?: StringFilter<"Resena"> | string
    createdAt?: DateTimeFilter<"Resena"> | Date | string
    updatedAt?: DateTimeFilter<"Resena"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type ResenaOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipoObjeto?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrderInput | SortOrder
    fechaExperiencia?: SortOrderInput | SortOrder
    respuestaOwner?: SortOrderInput | SortOrder
    fechaRespuesta?: SortOrderInput | SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type ResenaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResenaWhereInput | ResenaWhereInput[]
    OR?: ResenaWhereInput[]
    NOT?: ResenaWhereInput | ResenaWhereInput[]
    usuarioId?: IntFilter<"Resena"> | number
    tipoObjeto?: StringFilter<"Resena"> | string
    calificacion?: IntFilter<"Resena"> | number
    comentario?: StringNullableFilter<"Resena"> | string | null
    fechaExperiencia?: DateTimeNullableFilter<"Resena"> | Date | string | null
    respuestaOwner?: StringNullableFilter<"Resena"> | string | null
    fechaRespuesta?: DateTimeNullableFilter<"Resena"> | Date | string | null
    estado?: StringFilter<"Resena"> | string
    createdAt?: DateTimeFilter<"Resena"> | Date | string
    updatedAt?: DateTimeFilter<"Resena"> | Date | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type ResenaOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipoObjeto?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrderInput | SortOrder
    fechaExperiencia?: SortOrderInput | SortOrder
    respuestaOwner?: SortOrderInput | SortOrder
    fechaRespuesta?: SortOrderInput | SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResenaCountOrderByAggregateInput
    _avg?: ResenaAvgOrderByAggregateInput
    _max?: ResenaMaxOrderByAggregateInput
    _min?: ResenaMinOrderByAggregateInput
    _sum?: ResenaSumOrderByAggregateInput
  }

  export type ResenaScalarWhereWithAggregatesInput = {
    AND?: ResenaScalarWhereWithAggregatesInput | ResenaScalarWhereWithAggregatesInput[]
    OR?: ResenaScalarWhereWithAggregatesInput[]
    NOT?: ResenaScalarWhereWithAggregatesInput | ResenaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Resena"> | number
    usuarioId?: IntWithAggregatesFilter<"Resena"> | number
    tipoObjeto?: StringWithAggregatesFilter<"Resena"> | string
    calificacion?: IntWithAggregatesFilter<"Resena"> | number
    comentario?: StringNullableWithAggregatesFilter<"Resena"> | string | null
    fechaExperiencia?: DateTimeNullableWithAggregatesFilter<"Resena"> | Date | string | null
    respuestaOwner?: StringNullableWithAggregatesFilter<"Resena"> | string | null
    fechaRespuesta?: DateTimeNullableWithAggregatesFilter<"Resena"> | Date | string | null
    estado?: StringWithAggregatesFilter<"Resena"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Resena"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Resena"> | Date | string
  }

  export type FavoritoWhereInput = {
    AND?: FavoritoWhereInput | FavoritoWhereInput[]
    OR?: FavoritoWhereInput[]
    NOT?: FavoritoWhereInput | FavoritoWhereInput[]
    id?: IntFilter<"Favorito"> | number
    estado?: StringFilter<"Favorito"> | string
    usuarioId?: IntFilter<"Favorito"> | number
    emprendimientoId?: IntFilter<"Favorito"> | number
    createdAt?: DateTimeFilter<"Favorito"> | Date | string
    emprendimiento?: XOR<EmprendimientoScalarRelationFilter, EmprendimientoWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type FavoritoOrderByWithRelationInput = {
    id?: SortOrder
    estado?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
    createdAt?: SortOrder
    emprendimiento?: EmprendimientoOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type FavoritoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    emprendimientoId_usuarioId?: FavoritoEmprendimientoIdUsuarioIdCompoundUniqueInput
    AND?: FavoritoWhereInput | FavoritoWhereInput[]
    OR?: FavoritoWhereInput[]
    NOT?: FavoritoWhereInput | FavoritoWhereInput[]
    estado?: StringFilter<"Favorito"> | string
    usuarioId?: IntFilter<"Favorito"> | number
    emprendimientoId?: IntFilter<"Favorito"> | number
    createdAt?: DateTimeFilter<"Favorito"> | Date | string
    emprendimiento?: XOR<EmprendimientoScalarRelationFilter, EmprendimientoWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id" | "emprendimientoId_usuarioId">

  export type FavoritoOrderByWithAggregationInput = {
    id?: SortOrder
    estado?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
    createdAt?: SortOrder
    _count?: FavoritoCountOrderByAggregateInput
    _avg?: FavoritoAvgOrderByAggregateInput
    _max?: FavoritoMaxOrderByAggregateInput
    _min?: FavoritoMinOrderByAggregateInput
    _sum?: FavoritoSumOrderByAggregateInput
  }

  export type FavoritoScalarWhereWithAggregatesInput = {
    AND?: FavoritoScalarWhereWithAggregatesInput | FavoritoScalarWhereWithAggregatesInput[]
    OR?: FavoritoScalarWhereWithAggregatesInput[]
    NOT?: FavoritoScalarWhereWithAggregatesInput | FavoritoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Favorito"> | number
    estado?: StringWithAggregatesFilter<"Favorito"> | string
    usuarioId?: IntWithAggregatesFilter<"Favorito"> | number
    emprendimientoId?: IntWithAggregatesFilter<"Favorito"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Favorito"> | Date | string
  }

  export type ReservaWhereInput = {
    AND?: ReservaWhereInput | ReservaWhereInput[]
    OR?: ReservaWhereInput[]
    NOT?: ReservaWhereInput | ReservaWhereInput[]
    id?: IntFilter<"Reserva"> | number
    codigoReserva?: StringFilter<"Reserva"> | string
    turistaId?: IntFilter<"Reserva"> | number
    tipoReserva?: StringFilter<"Reserva"> | string
    fechaReserva?: DateTimeFilter<"Reserva"> | Date | string
    fechaInicio?: DateTimeFilter<"Reserva"> | Date | string
    hora?: StringNullableFilter<"Reserva"> | string | null
    fechaFin?: DateTimeNullableFilter<"Reserva"> | Date | string | null
    cantidadPersonas?: IntFilter<"Reserva"> | number
    precioTotal?: DecimalFilter<"Reserva"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Reserva"> | string
    estado?: StringFilter<"Reserva"> | string
    metodoPago?: StringNullableFilter<"Reserva"> | string | null
    datosPago?: JsonNullableFilter<"Reserva">
    notas?: StringNullableFilter<"Reserva"> | string | null
    motivoCancelacion?: StringNullableFilter<"Reserva"> | string | null
    fechaCancelacion?: DateTimeNullableFilter<"Reserva"> | Date | string | null
    createdAt?: DateTimeFilter<"Reserva"> | Date | string
    updatedAt?: DateTimeFilter<"Reserva"> | Date | string
    itinerarios?: ItinerarioReservaListRelationFilter
    pagos?: PagoListRelationFilter
    turista?: XOR<TuristaScalarRelationFilter, TuristaWhereInput>
  }

  export type ReservaOrderByWithRelationInput = {
    id?: SortOrder
    codigoReserva?: SortOrder
    turistaId?: SortOrder
    tipoReserva?: SortOrder
    fechaReserva?: SortOrder
    fechaInicio?: SortOrder
    hora?: SortOrderInput | SortOrder
    fechaFin?: SortOrderInput | SortOrder
    cantidadPersonas?: SortOrder
    precioTotal?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    metodoPago?: SortOrderInput | SortOrder
    datosPago?: SortOrderInput | SortOrder
    notas?: SortOrderInput | SortOrder
    motivoCancelacion?: SortOrderInput | SortOrder
    fechaCancelacion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    itinerarios?: ItinerarioReservaOrderByRelationAggregateInput
    pagos?: PagoOrderByRelationAggregateInput
    turista?: TuristaOrderByWithRelationInput
  }

  export type ReservaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigoReserva?: string
    AND?: ReservaWhereInput | ReservaWhereInput[]
    OR?: ReservaWhereInput[]
    NOT?: ReservaWhereInput | ReservaWhereInput[]
    turistaId?: IntFilter<"Reserva"> | number
    tipoReserva?: StringFilter<"Reserva"> | string
    fechaReserva?: DateTimeFilter<"Reserva"> | Date | string
    fechaInicio?: DateTimeFilter<"Reserva"> | Date | string
    hora?: StringNullableFilter<"Reserva"> | string | null
    fechaFin?: DateTimeNullableFilter<"Reserva"> | Date | string | null
    cantidadPersonas?: IntFilter<"Reserva"> | number
    precioTotal?: DecimalFilter<"Reserva"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Reserva"> | string
    estado?: StringFilter<"Reserva"> | string
    metodoPago?: StringNullableFilter<"Reserva"> | string | null
    datosPago?: JsonNullableFilter<"Reserva">
    notas?: StringNullableFilter<"Reserva"> | string | null
    motivoCancelacion?: StringNullableFilter<"Reserva"> | string | null
    fechaCancelacion?: DateTimeNullableFilter<"Reserva"> | Date | string | null
    createdAt?: DateTimeFilter<"Reserva"> | Date | string
    updatedAt?: DateTimeFilter<"Reserva"> | Date | string
    itinerarios?: ItinerarioReservaListRelationFilter
    pagos?: PagoListRelationFilter
    turista?: XOR<TuristaScalarRelationFilter, TuristaWhereInput>
  }, "id" | "codigoReserva">

  export type ReservaOrderByWithAggregationInput = {
    id?: SortOrder
    codigoReserva?: SortOrder
    turistaId?: SortOrder
    tipoReserva?: SortOrder
    fechaReserva?: SortOrder
    fechaInicio?: SortOrder
    hora?: SortOrderInput | SortOrder
    fechaFin?: SortOrderInput | SortOrder
    cantidadPersonas?: SortOrder
    precioTotal?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    metodoPago?: SortOrderInput | SortOrder
    datosPago?: SortOrderInput | SortOrder
    notas?: SortOrderInput | SortOrder
    motivoCancelacion?: SortOrderInput | SortOrder
    fechaCancelacion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReservaCountOrderByAggregateInput
    _avg?: ReservaAvgOrderByAggregateInput
    _max?: ReservaMaxOrderByAggregateInput
    _min?: ReservaMinOrderByAggregateInput
    _sum?: ReservaSumOrderByAggregateInput
  }

  export type ReservaScalarWhereWithAggregatesInput = {
    AND?: ReservaScalarWhereWithAggregatesInput | ReservaScalarWhereWithAggregatesInput[]
    OR?: ReservaScalarWhereWithAggregatesInput[]
    NOT?: ReservaScalarWhereWithAggregatesInput | ReservaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reserva"> | number
    codigoReserva?: StringWithAggregatesFilter<"Reserva"> | string
    turistaId?: IntWithAggregatesFilter<"Reserva"> | number
    tipoReserva?: StringWithAggregatesFilter<"Reserva"> | string
    fechaReserva?: DateTimeWithAggregatesFilter<"Reserva"> | Date | string
    fechaInicio?: DateTimeWithAggregatesFilter<"Reserva"> | Date | string
    hora?: StringNullableWithAggregatesFilter<"Reserva"> | string | null
    fechaFin?: DateTimeNullableWithAggregatesFilter<"Reserva"> | Date | string | null
    cantidadPersonas?: IntWithAggregatesFilter<"Reserva"> | number
    precioTotal?: DecimalWithAggregatesFilter<"Reserva"> | Decimal | DecimalJsLike | number | string
    moneda?: StringWithAggregatesFilter<"Reserva"> | string
    estado?: StringWithAggregatesFilter<"Reserva"> | string
    metodoPago?: StringNullableWithAggregatesFilter<"Reserva"> | string | null
    datosPago?: JsonNullableWithAggregatesFilter<"Reserva">
    notas?: StringNullableWithAggregatesFilter<"Reserva"> | string | null
    motivoCancelacion?: StringNullableWithAggregatesFilter<"Reserva"> | string | null
    fechaCancelacion?: DateTimeNullableWithAggregatesFilter<"Reserva"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Reserva"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reserva"> | Date | string
  }

  export type ItinerarioReservaWhereInput = {
    AND?: ItinerarioReservaWhereInput | ItinerarioReservaWhereInput[]
    OR?: ItinerarioReservaWhereInput[]
    NOT?: ItinerarioReservaWhereInput | ItinerarioReservaWhereInput[]
    id?: IntFilter<"ItinerarioReserva"> | number
    fecha?: DateTimeFilter<"ItinerarioReserva"> | Date | string
    hora?: DateTimeNullableFilter<"ItinerarioReserva"> | Date | string | null
    tipoEvento?: StringFilter<"ItinerarioReserva"> | string
    descripcion?: StringFilter<"ItinerarioReserva"> | string
    notas?: StringNullableFilter<"ItinerarioReserva"> | string | null
    duracion?: IntNullableFilter<"ItinerarioReserva"> | number | null
    reservaId?: IntFilter<"ItinerarioReserva"> | number
    servicioId?: IntNullableFilter<"ItinerarioReserva"> | number | null
    createdAt?: DateTimeFilter<"ItinerarioReserva"> | Date | string
    updatedAt?: DateTimeFilter<"ItinerarioReserva"> | Date | string
    itinerarioLugares?: ItinerarioLugarListRelationFilter
    reserva?: XOR<ReservaScalarRelationFilter, ReservaWhereInput>
    servicio?: XOR<ServicioNullableScalarRelationFilter, ServicioWhereInput> | null
  }

  export type ItinerarioReservaOrderByWithRelationInput = {
    id?: SortOrder
    fecha?: SortOrder
    hora?: SortOrderInput | SortOrder
    tipoEvento?: SortOrder
    descripcion?: SortOrder
    notas?: SortOrderInput | SortOrder
    duracion?: SortOrderInput | SortOrder
    reservaId?: SortOrder
    servicioId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    itinerarioLugares?: ItinerarioLugarOrderByRelationAggregateInput
    reserva?: ReservaOrderByWithRelationInput
    servicio?: ServicioOrderByWithRelationInput
  }

  export type ItinerarioReservaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItinerarioReservaWhereInput | ItinerarioReservaWhereInput[]
    OR?: ItinerarioReservaWhereInput[]
    NOT?: ItinerarioReservaWhereInput | ItinerarioReservaWhereInput[]
    fecha?: DateTimeFilter<"ItinerarioReserva"> | Date | string
    hora?: DateTimeNullableFilter<"ItinerarioReserva"> | Date | string | null
    tipoEvento?: StringFilter<"ItinerarioReserva"> | string
    descripcion?: StringFilter<"ItinerarioReserva"> | string
    notas?: StringNullableFilter<"ItinerarioReserva"> | string | null
    duracion?: IntNullableFilter<"ItinerarioReserva"> | number | null
    reservaId?: IntFilter<"ItinerarioReserva"> | number
    servicioId?: IntNullableFilter<"ItinerarioReserva"> | number | null
    createdAt?: DateTimeFilter<"ItinerarioReserva"> | Date | string
    updatedAt?: DateTimeFilter<"ItinerarioReserva"> | Date | string
    itinerarioLugares?: ItinerarioLugarListRelationFilter
    reserva?: XOR<ReservaScalarRelationFilter, ReservaWhereInput>
    servicio?: XOR<ServicioNullableScalarRelationFilter, ServicioWhereInput> | null
  }, "id">

  export type ItinerarioReservaOrderByWithAggregationInput = {
    id?: SortOrder
    fecha?: SortOrder
    hora?: SortOrderInput | SortOrder
    tipoEvento?: SortOrder
    descripcion?: SortOrder
    notas?: SortOrderInput | SortOrder
    duracion?: SortOrderInput | SortOrder
    reservaId?: SortOrder
    servicioId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItinerarioReservaCountOrderByAggregateInput
    _avg?: ItinerarioReservaAvgOrderByAggregateInput
    _max?: ItinerarioReservaMaxOrderByAggregateInput
    _min?: ItinerarioReservaMinOrderByAggregateInput
    _sum?: ItinerarioReservaSumOrderByAggregateInput
  }

  export type ItinerarioReservaScalarWhereWithAggregatesInput = {
    AND?: ItinerarioReservaScalarWhereWithAggregatesInput | ItinerarioReservaScalarWhereWithAggregatesInput[]
    OR?: ItinerarioReservaScalarWhereWithAggregatesInput[]
    NOT?: ItinerarioReservaScalarWhereWithAggregatesInput | ItinerarioReservaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItinerarioReserva"> | number
    fecha?: DateTimeWithAggregatesFilter<"ItinerarioReserva"> | Date | string
    hora?: DateTimeNullableWithAggregatesFilter<"ItinerarioReserva"> | Date | string | null
    tipoEvento?: StringWithAggregatesFilter<"ItinerarioReserva"> | string
    descripcion?: StringWithAggregatesFilter<"ItinerarioReserva"> | string
    notas?: StringNullableWithAggregatesFilter<"ItinerarioReserva"> | string | null
    duracion?: IntNullableWithAggregatesFilter<"ItinerarioReserva"> | number | null
    reservaId?: IntWithAggregatesFilter<"ItinerarioReserva"> | number
    servicioId?: IntNullableWithAggregatesFilter<"ItinerarioReserva"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ItinerarioReserva"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItinerarioReserva"> | Date | string
  }

  export type ItinerarioLugarWhereInput = {
    AND?: ItinerarioLugarWhereInput | ItinerarioLugarWhereInput[]
    OR?: ItinerarioLugarWhereInput[]
    NOT?: ItinerarioLugarWhereInput | ItinerarioLugarWhereInput[]
    id?: IntFilter<"ItinerarioLugar"> | number
    itinerarioReservaId?: IntFilter<"ItinerarioLugar"> | number
    lugarTuristicoId?: IntFilter<"ItinerarioLugar"> | number
    createdAt?: DateTimeFilter<"ItinerarioLugar"> | Date | string
    updatedAt?: DateTimeFilter<"ItinerarioLugar"> | Date | string
    itinerarioReserva?: XOR<ItinerarioReservaScalarRelationFilter, ItinerarioReservaWhereInput>
    lugarTuristico?: XOR<LugarTuristicoScalarRelationFilter, LugarTuristicoWhereInput>
  }

  export type ItinerarioLugarOrderByWithRelationInput = {
    id?: SortOrder
    itinerarioReservaId?: SortOrder
    lugarTuristicoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    itinerarioReserva?: ItinerarioReservaOrderByWithRelationInput
    lugarTuristico?: LugarTuristicoOrderByWithRelationInput
  }

  export type ItinerarioLugarWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItinerarioLugarWhereInput | ItinerarioLugarWhereInput[]
    OR?: ItinerarioLugarWhereInput[]
    NOT?: ItinerarioLugarWhereInput | ItinerarioLugarWhereInput[]
    itinerarioReservaId?: IntFilter<"ItinerarioLugar"> | number
    lugarTuristicoId?: IntFilter<"ItinerarioLugar"> | number
    createdAt?: DateTimeFilter<"ItinerarioLugar"> | Date | string
    updatedAt?: DateTimeFilter<"ItinerarioLugar"> | Date | string
    itinerarioReserva?: XOR<ItinerarioReservaScalarRelationFilter, ItinerarioReservaWhereInput>
    lugarTuristico?: XOR<LugarTuristicoScalarRelationFilter, LugarTuristicoWhereInput>
  }, "id">

  export type ItinerarioLugarOrderByWithAggregationInput = {
    id?: SortOrder
    itinerarioReservaId?: SortOrder
    lugarTuristicoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItinerarioLugarCountOrderByAggregateInput
    _avg?: ItinerarioLugarAvgOrderByAggregateInput
    _max?: ItinerarioLugarMaxOrderByAggregateInput
    _min?: ItinerarioLugarMinOrderByAggregateInput
    _sum?: ItinerarioLugarSumOrderByAggregateInput
  }

  export type ItinerarioLugarScalarWhereWithAggregatesInput = {
    AND?: ItinerarioLugarScalarWhereWithAggregatesInput | ItinerarioLugarScalarWhereWithAggregatesInput[]
    OR?: ItinerarioLugarScalarWhereWithAggregatesInput[]
    NOT?: ItinerarioLugarScalarWhereWithAggregatesInput | ItinerarioLugarScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ItinerarioLugar"> | number
    itinerarioReservaId?: IntWithAggregatesFilter<"ItinerarioLugar"> | number
    lugarTuristicoId?: IntWithAggregatesFilter<"ItinerarioLugar"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ItinerarioLugar"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ItinerarioLugar"> | Date | string
  }

  export type PagoWhereInput = {
    AND?: PagoWhereInput | PagoWhereInput[]
    OR?: PagoWhereInput[]
    NOT?: PagoWhereInput | PagoWhereInput[]
    id?: IntFilter<"Pago"> | number
    reservaId?: IntFilter<"Pago"> | number
    codigoTransaccion?: StringNullableFilter<"Pago"> | string | null
    montoTotal?: DecimalFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Pago"> | string
    estado?: StringFilter<"Pago"> | string
    fechaPago?: DateTimeNullableFilter<"Pago"> | Date | string | null
    datosMetodoPago?: JsonNullableFilter<"Pago">
    metadata?: JsonFilter<"Pago">
    createdAt?: DateTimeFilter<"Pago"> | Date | string
    updatedAt?: DateTimeFilter<"Pago"> | Date | string
    comprobante?: XOR<ComprobanteNullableScalarRelationFilter, ComprobanteWhereInput> | null
    reserva?: XOR<ReservaScalarRelationFilter, ReservaWhereInput>
    detalles?: PagoDetalleListRelationFilter
  }

  export type PagoOrderByWithRelationInput = {
    id?: SortOrder
    reservaId?: SortOrder
    codigoTransaccion?: SortOrderInput | SortOrder
    montoTotal?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    fechaPago?: SortOrderInput | SortOrder
    datosMetodoPago?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comprobante?: ComprobanteOrderByWithRelationInput
    reserva?: ReservaOrderByWithRelationInput
    detalles?: PagoDetalleOrderByRelationAggregateInput
  }

  export type PagoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    codigoTransaccion?: string
    AND?: PagoWhereInput | PagoWhereInput[]
    OR?: PagoWhereInput[]
    NOT?: PagoWhereInput | PagoWhereInput[]
    reservaId?: IntFilter<"Pago"> | number
    montoTotal?: DecimalFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Pago"> | string
    estado?: StringFilter<"Pago"> | string
    fechaPago?: DateTimeNullableFilter<"Pago"> | Date | string | null
    datosMetodoPago?: JsonNullableFilter<"Pago">
    metadata?: JsonFilter<"Pago">
    createdAt?: DateTimeFilter<"Pago"> | Date | string
    updatedAt?: DateTimeFilter<"Pago"> | Date | string
    comprobante?: XOR<ComprobanteNullableScalarRelationFilter, ComprobanteWhereInput> | null
    reserva?: XOR<ReservaScalarRelationFilter, ReservaWhereInput>
    detalles?: PagoDetalleListRelationFilter
  }, "id" | "codigoTransaccion">

  export type PagoOrderByWithAggregationInput = {
    id?: SortOrder
    reservaId?: SortOrder
    codigoTransaccion?: SortOrderInput | SortOrder
    montoTotal?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    fechaPago?: SortOrderInput | SortOrder
    datosMetodoPago?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PagoCountOrderByAggregateInput
    _avg?: PagoAvgOrderByAggregateInput
    _max?: PagoMaxOrderByAggregateInput
    _min?: PagoMinOrderByAggregateInput
    _sum?: PagoSumOrderByAggregateInput
  }

  export type PagoScalarWhereWithAggregatesInput = {
    AND?: PagoScalarWhereWithAggregatesInput | PagoScalarWhereWithAggregatesInput[]
    OR?: PagoScalarWhereWithAggregatesInput[]
    NOT?: PagoScalarWhereWithAggregatesInput | PagoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pago"> | number
    reservaId?: IntWithAggregatesFilter<"Pago"> | number
    codigoTransaccion?: StringNullableWithAggregatesFilter<"Pago"> | string | null
    montoTotal?: DecimalWithAggregatesFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    moneda?: StringWithAggregatesFilter<"Pago"> | string
    estado?: StringWithAggregatesFilter<"Pago"> | string
    fechaPago?: DateTimeNullableWithAggregatesFilter<"Pago"> | Date | string | null
    datosMetodoPago?: JsonNullableWithAggregatesFilter<"Pago">
    metadata?: JsonWithAggregatesFilter<"Pago">
    createdAt?: DateTimeWithAggregatesFilter<"Pago"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pago"> | Date | string
  }

  export type PagoDetalleWhereInput = {
    AND?: PagoDetalleWhereInput | PagoDetalleWhereInput[]
    OR?: PagoDetalleWhereInput[]
    NOT?: PagoDetalleWhereInput | PagoDetalleWhereInput[]
    id?: IntFilter<"PagoDetalle"> | number
    pagoId?: IntFilter<"PagoDetalle"> | number
    tipoPagoId?: IntFilter<"PagoDetalle"> | number
    concepto?: StringFilter<"PagoDetalle"> | string
    monto?: DecimalFilter<"PagoDetalle"> | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalFilter<"PagoDetalle"> | Decimal | DecimalJsLike | number | string
    cantidad?: IntFilter<"PagoDetalle"> | number
    descripcion?: StringNullableFilter<"PagoDetalle"> | string | null
    createdAt?: DateTimeFilter<"PagoDetalle"> | Date | string
    updatedAt?: DateTimeFilter<"PagoDetalle"> | Date | string
    pago?: XOR<PagoScalarRelationFilter, PagoWhereInput>
    tipoPago?: XOR<TipoPagoScalarRelationFilter, TipoPagoWhereInput>
  }

  export type PagoDetalleOrderByWithRelationInput = {
    id?: SortOrder
    pagoId?: SortOrder
    tipoPagoId?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    porcentajeImpuesto?: SortOrder
    cantidad?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pago?: PagoOrderByWithRelationInput
    tipoPago?: TipoPagoOrderByWithRelationInput
  }

  export type PagoDetalleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PagoDetalleWhereInput | PagoDetalleWhereInput[]
    OR?: PagoDetalleWhereInput[]
    NOT?: PagoDetalleWhereInput | PagoDetalleWhereInput[]
    pagoId?: IntFilter<"PagoDetalle"> | number
    tipoPagoId?: IntFilter<"PagoDetalle"> | number
    concepto?: StringFilter<"PagoDetalle"> | string
    monto?: DecimalFilter<"PagoDetalle"> | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalFilter<"PagoDetalle"> | Decimal | DecimalJsLike | number | string
    cantidad?: IntFilter<"PagoDetalle"> | number
    descripcion?: StringNullableFilter<"PagoDetalle"> | string | null
    createdAt?: DateTimeFilter<"PagoDetalle"> | Date | string
    updatedAt?: DateTimeFilter<"PagoDetalle"> | Date | string
    pago?: XOR<PagoScalarRelationFilter, PagoWhereInput>
    tipoPago?: XOR<TipoPagoScalarRelationFilter, TipoPagoWhereInput>
  }, "id">

  export type PagoDetalleOrderByWithAggregationInput = {
    id?: SortOrder
    pagoId?: SortOrder
    tipoPagoId?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    porcentajeImpuesto?: SortOrder
    cantidad?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PagoDetalleCountOrderByAggregateInput
    _avg?: PagoDetalleAvgOrderByAggregateInput
    _max?: PagoDetalleMaxOrderByAggregateInput
    _min?: PagoDetalleMinOrderByAggregateInput
    _sum?: PagoDetalleSumOrderByAggregateInput
  }

  export type PagoDetalleScalarWhereWithAggregatesInput = {
    AND?: PagoDetalleScalarWhereWithAggregatesInput | PagoDetalleScalarWhereWithAggregatesInput[]
    OR?: PagoDetalleScalarWhereWithAggregatesInput[]
    NOT?: PagoDetalleScalarWhereWithAggregatesInput | PagoDetalleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PagoDetalle"> | number
    pagoId?: IntWithAggregatesFilter<"PagoDetalle"> | number
    tipoPagoId?: IntWithAggregatesFilter<"PagoDetalle"> | number
    concepto?: StringWithAggregatesFilter<"PagoDetalle"> | string
    monto?: DecimalWithAggregatesFilter<"PagoDetalle"> | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalWithAggregatesFilter<"PagoDetalle"> | Decimal | DecimalJsLike | number | string
    cantidad?: IntWithAggregatesFilter<"PagoDetalle"> | number
    descripcion?: StringNullableWithAggregatesFilter<"PagoDetalle"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PagoDetalle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PagoDetalle"> | Date | string
  }

  export type TipoPagoWhereInput = {
    AND?: TipoPagoWhereInput | TipoPagoWhereInput[]
    OR?: TipoPagoWhereInput[]
    NOT?: TipoPagoWhereInput | TipoPagoWhereInput[]
    id?: IntFilter<"TipoPago"> | number
    nombre?: StringFilter<"TipoPago"> | string
    descripcion?: StringNullableFilter<"TipoPago"> | string | null
    requiereVerificacion?: BoolFilter<"TipoPago"> | boolean
    comisionPorcentaje?: DecimalFilter<"TipoPago"> | Decimal | DecimalJsLike | number | string
    activo?: BoolFilter<"TipoPago"> | boolean
    createdAt?: DateTimeFilter<"TipoPago"> | Date | string
    updatedAt?: DateTimeFilter<"TipoPago"> | Date | string
    pagoDetalles?: PagoDetalleListRelationFilter
  }

  export type TipoPagoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    requiereVerificacion?: SortOrder
    comisionPorcentaje?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pagoDetalles?: PagoDetalleOrderByRelationAggregateInput
  }

  export type TipoPagoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: TipoPagoWhereInput | TipoPagoWhereInput[]
    OR?: TipoPagoWhereInput[]
    NOT?: TipoPagoWhereInput | TipoPagoWhereInput[]
    descripcion?: StringNullableFilter<"TipoPago"> | string | null
    requiereVerificacion?: BoolFilter<"TipoPago"> | boolean
    comisionPorcentaje?: DecimalFilter<"TipoPago"> | Decimal | DecimalJsLike | number | string
    activo?: BoolFilter<"TipoPago"> | boolean
    createdAt?: DateTimeFilter<"TipoPago"> | Date | string
    updatedAt?: DateTimeFilter<"TipoPago"> | Date | string
    pagoDetalles?: PagoDetalleListRelationFilter
  }, "id" | "nombre">

  export type TipoPagoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    requiereVerificacion?: SortOrder
    comisionPorcentaje?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TipoPagoCountOrderByAggregateInput
    _avg?: TipoPagoAvgOrderByAggregateInput
    _max?: TipoPagoMaxOrderByAggregateInput
    _min?: TipoPagoMinOrderByAggregateInput
    _sum?: TipoPagoSumOrderByAggregateInput
  }

  export type TipoPagoScalarWhereWithAggregatesInput = {
    AND?: TipoPagoScalarWhereWithAggregatesInput | TipoPagoScalarWhereWithAggregatesInput[]
    OR?: TipoPagoScalarWhereWithAggregatesInput[]
    NOT?: TipoPagoScalarWhereWithAggregatesInput | TipoPagoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoPago"> | number
    nombre?: StringWithAggregatesFilter<"TipoPago"> | string
    descripcion?: StringNullableWithAggregatesFilter<"TipoPago"> | string | null
    requiereVerificacion?: BoolWithAggregatesFilter<"TipoPago"> | boolean
    comisionPorcentaje?: DecimalWithAggregatesFilter<"TipoPago"> | Decimal | DecimalJsLike | number | string
    activo?: BoolWithAggregatesFilter<"TipoPago"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TipoPago"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TipoPago"> | Date | string
  }

  export type ComprobanteWhereInput = {
    AND?: ComprobanteWhereInput | ComprobanteWhereInput[]
    OR?: ComprobanteWhereInput[]
    NOT?: ComprobanteWhereInput | ComprobanteWhereInput[]
    id?: IntFilter<"Comprobante"> | number
    pagoId?: IntFilter<"Comprobante"> | number
    tipoComprobante?: StringFilter<"Comprobante"> | string
    serie?: StringFilter<"Comprobante"> | string
    numero?: IntFilter<"Comprobante"> | number
    fechaEmision?: DateTimeFilter<"Comprobante"> | Date | string
    rucCliente?: StringNullableFilter<"Comprobante"> | string | null
    razonSocial?: StringNullableFilter<"Comprobante"> | string | null
    direccionCliente?: StringNullableFilter<"Comprobante"> | string | null
    subtotal?: DecimalFilter<"Comprobante"> | Decimal | DecimalJsLike | number | string
    igv?: DecimalFilter<"Comprobante"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Comprobante"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Comprobante"> | string
    estado?: StringFilter<"Comprobante"> | string
    codigoSunat?: StringNullableFilter<"Comprobante"> | string | null
    codigoHash?: StringNullableFilter<"Comprobante"> | string | null
    xmlUrl?: StringNullableFilter<"Comprobante"> | string | null
    pdfUrl?: StringNullableFilter<"Comprobante"> | string | null
    createdAt?: DateTimeFilter<"Comprobante"> | Date | string
    updatedAt?: DateTimeFilter<"Comprobante"> | Date | string
    pago?: XOR<PagoScalarRelationFilter, PagoWhereInput>
  }

  export type ComprobanteOrderByWithRelationInput = {
    id?: SortOrder
    pagoId?: SortOrder
    tipoComprobante?: SortOrder
    serie?: SortOrder
    numero?: SortOrder
    fechaEmision?: SortOrder
    rucCliente?: SortOrderInput | SortOrder
    razonSocial?: SortOrderInput | SortOrder
    direccionCliente?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    codigoSunat?: SortOrderInput | SortOrder
    codigoHash?: SortOrderInput | SortOrder
    xmlUrl?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pago?: PagoOrderByWithRelationInput
  }

  export type ComprobanteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pagoId?: number
    serie_numero?: ComprobanteSerieNumeroCompoundUniqueInput
    AND?: ComprobanteWhereInput | ComprobanteWhereInput[]
    OR?: ComprobanteWhereInput[]
    NOT?: ComprobanteWhereInput | ComprobanteWhereInput[]
    tipoComprobante?: StringFilter<"Comprobante"> | string
    serie?: StringFilter<"Comprobante"> | string
    numero?: IntFilter<"Comprobante"> | number
    fechaEmision?: DateTimeFilter<"Comprobante"> | Date | string
    rucCliente?: StringNullableFilter<"Comprobante"> | string | null
    razonSocial?: StringNullableFilter<"Comprobante"> | string | null
    direccionCliente?: StringNullableFilter<"Comprobante"> | string | null
    subtotal?: DecimalFilter<"Comprobante"> | Decimal | DecimalJsLike | number | string
    igv?: DecimalFilter<"Comprobante"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Comprobante"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Comprobante"> | string
    estado?: StringFilter<"Comprobante"> | string
    codigoSunat?: StringNullableFilter<"Comprobante"> | string | null
    codigoHash?: StringNullableFilter<"Comprobante"> | string | null
    xmlUrl?: StringNullableFilter<"Comprobante"> | string | null
    pdfUrl?: StringNullableFilter<"Comprobante"> | string | null
    createdAt?: DateTimeFilter<"Comprobante"> | Date | string
    updatedAt?: DateTimeFilter<"Comprobante"> | Date | string
    pago?: XOR<PagoScalarRelationFilter, PagoWhereInput>
  }, "id" | "pagoId" | "serie_numero">

  export type ComprobanteOrderByWithAggregationInput = {
    id?: SortOrder
    pagoId?: SortOrder
    tipoComprobante?: SortOrder
    serie?: SortOrder
    numero?: SortOrder
    fechaEmision?: SortOrder
    rucCliente?: SortOrderInput | SortOrder
    razonSocial?: SortOrderInput | SortOrder
    direccionCliente?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    codigoSunat?: SortOrderInput | SortOrder
    codigoHash?: SortOrderInput | SortOrder
    xmlUrl?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComprobanteCountOrderByAggregateInput
    _avg?: ComprobanteAvgOrderByAggregateInput
    _max?: ComprobanteMaxOrderByAggregateInput
    _min?: ComprobanteMinOrderByAggregateInput
    _sum?: ComprobanteSumOrderByAggregateInput
  }

  export type ComprobanteScalarWhereWithAggregatesInput = {
    AND?: ComprobanteScalarWhereWithAggregatesInput | ComprobanteScalarWhereWithAggregatesInput[]
    OR?: ComprobanteScalarWhereWithAggregatesInput[]
    NOT?: ComprobanteScalarWhereWithAggregatesInput | ComprobanteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comprobante"> | number
    pagoId?: IntWithAggregatesFilter<"Comprobante"> | number
    tipoComprobante?: StringWithAggregatesFilter<"Comprobante"> | string
    serie?: StringWithAggregatesFilter<"Comprobante"> | string
    numero?: IntWithAggregatesFilter<"Comprobante"> | number
    fechaEmision?: DateTimeWithAggregatesFilter<"Comprobante"> | Date | string
    rucCliente?: StringNullableWithAggregatesFilter<"Comprobante"> | string | null
    razonSocial?: StringNullableWithAggregatesFilter<"Comprobante"> | string | null
    direccionCliente?: StringNullableWithAggregatesFilter<"Comprobante"> | string | null
    subtotal?: DecimalWithAggregatesFilter<"Comprobante"> | Decimal | DecimalJsLike | number | string
    igv?: DecimalWithAggregatesFilter<"Comprobante"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Comprobante"> | Decimal | DecimalJsLike | number | string
    moneda?: StringWithAggregatesFilter<"Comprobante"> | string
    estado?: StringWithAggregatesFilter<"Comprobante"> | string
    codigoSunat?: StringNullableWithAggregatesFilter<"Comprobante"> | string | null
    codigoHash?: StringNullableWithAggregatesFilter<"Comprobante"> | string | null
    xmlUrl?: StringNullableWithAggregatesFilter<"Comprobante"> | string | null
    pdfUrl?: StringNullableWithAggregatesFilter<"Comprobante"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Comprobante"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comprobante"> | Date | string
  }

  export type RoleCreateInput = {
    nombre: string
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolesPermisos?: RolesPermisosCreateNestedManyWithoutRolInput
    usuariosRoles?: UsuariosRolesCreateNestedManyWithoutRolInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolesPermisos?: RolesPermisosUncheckedCreateNestedManyWithoutRolInput
    usuariosRoles?: UsuariosRolesUncheckedCreateNestedManyWithoutRolInput
  }

  export type RoleUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolesPermisos?: RolesPermisosUpdateManyWithoutRolNestedInput
    usuariosRoles?: UsuariosRolesUpdateManyWithoutRolNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolesPermisos?: RolesPermisosUncheckedUpdateManyWithoutRolNestedInput
    usuariosRoles?: UsuariosRolesUncheckedUpdateManyWithoutRolNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermisoCreateInput = {
    nombre: string
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolesPermisos?: RolesPermisosCreateNestedManyWithoutPermisoInput
  }

  export type PermisoUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolesPermisos?: RolesPermisosUncheckedCreateNestedManyWithoutPermisoInput
  }

  export type PermisoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolesPermisos?: RolesPermisosUpdateManyWithoutPermisoNestedInput
  }

  export type PermisoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolesPermisos?: RolesPermisosUncheckedUpdateManyWithoutPermisoNestedInput
  }

  export type PermisoCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermisoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermisoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolesPermisosCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    permiso: PermisoCreateNestedOneWithoutRolesPermisosInput
    rol: RoleCreateNestedOneWithoutRolesPermisosInput
  }

  export type RolesPermisosUncheckedCreateInput = {
    id?: number
    rolId: number
    permisoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolesPermisosUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permiso?: PermisoUpdateOneRequiredWithoutRolesPermisosNestedInput
    rol?: RoleUpdateOneRequiredWithoutRolesPermisosNestedInput
  }

  export type RolesPermisosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolId?: IntFieldUpdateOperationsInput | number
    permisoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolesPermisosCreateManyInput = {
    id?: number
    rolId: number
    permisoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolesPermisosUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolesPermisosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolId?: IntFieldUpdateOperationsInput | number
    permisoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryCreateInput = {
    name: string
    codeIso: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subdivisions?: SubdivisionCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: number
    name: string
    codeIso: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subdivisions?: SubdivisionUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    codeIso?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subdivisions?: SubdivisionUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    codeIso?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subdivisions?: SubdivisionUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: number
    name: string
    codeIso: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    codeIso?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    codeIso?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdivisionCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoCreateNestedManyWithoutSubdivisionInput
    personas?: PersonaCreateNestedManyWithoutSubdivisionInput
    country: CountryCreateNestedOneWithoutSubdivisionsInput
  }

  export type SubdivisionUncheckedCreateInput = {
    id?: number
    countryId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutSubdivisionInput
    personas?: PersonaUncheckedCreateNestedManyWithoutSubdivisionInput
  }

  export type SubdivisionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUpdateManyWithoutSubdivisionNestedInput
    personas?: PersonaUpdateManyWithoutSubdivisionNestedInput
    country?: CountryUpdateOneRequiredWithoutSubdivisionsNestedInput
  }

  export type SubdivisionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutSubdivisionNestedInput
    personas?: PersonaUncheckedUpdateManyWithoutSubdivisionNestedInput
  }

  export type SubdivisionCreateManyInput = {
    id?: number
    countryId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubdivisionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdivisionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonaCreateInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    direccion?: string | null
    fotoPerfilUrl?: string | null
    fechaNacimiento?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subdivision: SubdivisionCreateNestedOneWithoutPersonasInput
    usuario?: UsuarioCreateNestedOneWithoutPersonaInput
  }

  export type PersonaUncheckedCreateInput = {
    id?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    direccion?: string | null
    fotoPerfilUrl?: string | null
    fechaNacimiento?: Date | string | null
    subdivisionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario?: UsuarioUncheckedCreateNestedOneWithoutPersonaInput
  }

  export type PersonaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fotoPerfilUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subdivision?: SubdivisionUpdateOneRequiredWithoutPersonasNestedInput
    usuario?: UsuarioUpdateOneWithoutPersonaNestedInput
  }

  export type PersonaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fotoPerfilUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subdivisionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUncheckedUpdateOneWithoutPersonaNestedInput
  }

  export type PersonaCreateManyInput = {
    id?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    direccion?: string | null
    fotoPerfilUrl?: string | null
    fechaNacimiento?: Date | string | null
    subdivisionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fotoPerfilUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fotoPerfilUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subdivisionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioCreateInput = {
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoCreateNestedManyWithoutUsuarioInput
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoCreateNestedManyWithoutUsuarioInput
    persona: PersonaCreateNestedOneWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    personaId: number
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoUncheckedCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoUncheckedCreateNestedManyWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUpdateManyWithoutUsuarioNestedInput
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUpdateManyWithoutUsuarioNestedInput
    persona?: PersonaUpdateOneRequiredWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    personaId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUncheckedUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUncheckedUpdateManyWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    personaId: number
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    personaId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuariosRolesCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    rol: RoleCreateNestedOneWithoutUsuariosRolesInput
    usuario: UsuarioCreateNestedOneWithoutUsuariosRolesInput
  }

  export type UsuariosRolesUncheckedCreateInput = {
    id?: number
    rolId: number
    usuarioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuariosRolesUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: RoleUpdateOneRequiredWithoutUsuariosRolesNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutUsuariosRolesNestedInput
  }

  export type UsuariosRolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuariosRolesCreateManyInput = {
    id?: number
    rolId: number
    usuarioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuariosRolesUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuariosRolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprendimientoCreateInput = {
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subdivision?: SubdivisionCreateNestedOneWithoutEmprendimientosInput
    usuario: UsuarioCreateNestedOneWithoutEmprendimientosInput
    favoritos?: FavoritoCreateNestedManyWithoutEmprendimientoInput
    paquetesTuristicos?: PaqueteTuristicoCreateNestedManyWithoutEmprendimientoInput
    servicios?: ServicioEmprendedorCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateInput = {
    id?: number
    usuarioId: number
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    subdivisionId?: number | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutEmprendimientoInput
    paquetesTuristicos?: PaqueteTuristicoUncheckedCreateNestedManyWithoutEmprendimientoInput
    servicios?: ServicioEmprendedorUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subdivision?: SubdivisionUpdateOneWithoutEmprendimientosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput
    favoritos?: FavoritoUpdateManyWithoutEmprendimientoNestedInput
    paquetesTuristicos?: PaqueteTuristicoUpdateManyWithoutEmprendimientoNestedInput
    servicios?: ServicioEmprendedorUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    subdivisionId?: NullableIntFieldUpdateOperationsInput | number | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favoritos?: FavoritoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    paquetesTuristicos?: PaqueteTuristicoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    servicios?: ServicioEmprendedorUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoCreateManyInput = {
    id?: number
    usuarioId: number
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    subdivisionId?: number | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmprendimientoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprendimientoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    subdivisionId?: NullableIntFieldUpdateOperationsInput | number | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegistroAccesoCreateInput = {
    ipAddress: string
    userAgent: string
    tipoEvento: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutRegistroAccesosInput
  }

  export type RegistroAccesoUncheckedCreateInput = {
    id?: number
    usuarioId: number
    ipAddress: string
    userAgent: string
    tipoEvento: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegistroAccesoUpdateInput = {
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    tipoEvento?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutRegistroAccesosNestedInput
  }

  export type RegistroAccesoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    tipoEvento?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegistroAccesoCreateManyInput = {
    id?: number
    usuarioId: number
    ipAddress: string
    userAgent: string
    tipoEvento: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegistroAccesoUpdateManyMutationInput = {
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    tipoEvento?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegistroAccesoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    tipoEvento?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenInvalidadoCreateInput = {
    tokenHash: string
    invalidadoEn: Date | string
    expiraEn: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutTokensInvalidadosInput
  }

  export type TokenInvalidadoUncheckedCreateInput = {
    id?: number
    tokenHash: string
    usuarioId: number
    invalidadoEn: Date | string
    expiraEn: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TokenInvalidadoUpdateInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    invalidadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutTokensInvalidadosNestedInput
  }

  export type TokenInvalidadoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    invalidadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenInvalidadoCreateManyInput = {
    id?: number
    tokenHash: string
    usuarioId: number
    invalidadoEn: Date | string
    expiraEn: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TokenInvalidadoUpdateManyMutationInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    invalidadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenInvalidadoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    invalidadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TuristaCreateInput = {
    nombre: string
    apellidos: string
    telefono: string
    direccion: string
    edad: Decimal | DecimalJsLike | number | string
    sexo: string
    pais: string
    peticionesEspeciales?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reservas?: ReservaCreateNestedManyWithoutTuristaInput
  }

  export type TuristaUncheckedCreateInput = {
    id?: number
    nombre: string
    apellidos: string
    telefono: string
    direccion: string
    edad: Decimal | DecimalJsLike | number | string
    sexo: string
    pais: string
    peticionesEspeciales?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reservas?: ReservaUncheckedCreateNestedManyWithoutTuristaInput
  }

  export type TuristaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    edad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sexo?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    peticionesEspeciales?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUpdateManyWithoutTuristaNestedInput
  }

  export type TuristaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    edad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sexo?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    peticionesEspeciales?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUncheckedUpdateManyWithoutTuristaNestedInput
  }

  export type TuristaCreateManyInput = {
    id?: number
    nombre: string
    apellidos: string
    telefono: string
    direccion: string
    edad: Decimal | DecimalJsLike | number | string
    sexo: string
    pais: string
    peticionesEspeciales?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TuristaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    edad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sexo?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    peticionesEspeciales?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TuristaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    edad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sexo?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    peticionesEspeciales?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LugarTuristicoCreateInput = {
    nombre: string
    descripcion: string
    direccion: string
    coordenadas: string
    horarioApertura?: Date | string | null
    horarioCierre?: Date | string | null
    costoEntrada?: Decimal | DecimalJsLike | number | string | null
    recomendaciones?: string | null
    restricciones?: string | null
    esDestacado?: boolean
    estado?: string
    imagenUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarioLugares?: ItinerarioLugarCreateNestedManyWithoutLugarTuristicoInput
  }

  export type LugarTuristicoUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion: string
    direccion: string
    coordenadas: string
    horarioApertura?: Date | string | null
    horarioCierre?: Date | string | null
    costoEntrada?: Decimal | DecimalJsLike | number | string | null
    recomendaciones?: string | null
    restricciones?: string | null
    esDestacado?: boolean
    estado?: string
    imagenUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarioLugares?: ItinerarioLugarUncheckedCreateNestedManyWithoutLugarTuristicoInput
  }

  export type LugarTuristicoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    coordenadas?: StringFieldUpdateOperationsInput | string
    horarioApertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioCierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costoEntrada?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recomendaciones?: NullableStringFieldUpdateOperationsInput | string | null
    restricciones?: NullableStringFieldUpdateOperationsInput | string | null
    esDestacado?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarioLugares?: ItinerarioLugarUpdateManyWithoutLugarTuristicoNestedInput
  }

  export type LugarTuristicoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    coordenadas?: StringFieldUpdateOperationsInput | string
    horarioApertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioCierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costoEntrada?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recomendaciones?: NullableStringFieldUpdateOperationsInput | string | null
    restricciones?: NullableStringFieldUpdateOperationsInput | string | null
    esDestacado?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarioLugares?: ItinerarioLugarUncheckedUpdateManyWithoutLugarTuristicoNestedInput
  }

  export type LugarTuristicoCreateManyInput = {
    id?: number
    nombre: string
    descripcion: string
    direccion: string
    coordenadas: string
    horarioApertura?: Date | string | null
    horarioCierre?: Date | string | null
    costoEntrada?: Decimal | DecimalJsLike | number | string | null
    recomendaciones?: string | null
    restricciones?: string | null
    esDestacado?: boolean
    estado?: string
    imagenUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LugarTuristicoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    coordenadas?: StringFieldUpdateOperationsInput | string
    horarioApertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioCierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costoEntrada?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recomendaciones?: NullableStringFieldUpdateOperationsInput | string | null
    restricciones?: NullableStringFieldUpdateOperationsInput | string | null
    esDestacado?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LugarTuristicoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    coordenadas?: StringFieldUpdateOperationsInput | string
    horarioApertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioCierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costoEntrada?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recomendaciones?: NullableStringFieldUpdateOperationsInput | string | null
    restricciones?: NullableStringFieldUpdateOperationsInput | string | null
    esDestacado?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicioEmprendedorCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimiento: EmprendimientoCreateNestedOneWithoutServiciosInput
    servicio: ServicioCreateNestedOneWithoutServiciosEmprendedoresInput
  }

  export type ServicioEmprendedorUncheckedCreateInput = {
    id?: number
    servicioId: number
    emprendimientoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicioEmprendedorUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimiento?: EmprendimientoUpdateOneRequiredWithoutServiciosNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutServiciosEmprendedoresNestedInput
  }

  export type ServicioEmprendedorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicioEmprendedorCreateManyInput = {
    id?: number
    servicioId: number
    emprendimientoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicioEmprendedorUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicioEmprendedorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicioCreateInput = {
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerariosReserva?: ItinerarioReservaCreateNestedManyWithoutServicioInput
    paquetesServicios?: PaqueteTuristicoServicioCreateNestedManyWithoutServicioInput
    tipoServicio: TipoServicioCreateNestedOneWithoutServiciosInput
    disponibilidad?: ServicioDisponibilidadCreateNestedManyWithoutServicioInput
    serviciosEmprendedores?: ServicioEmprendedorCreateNestedManyWithoutServicioInput
  }

  export type ServicioUncheckedCreateInput = {
    id?: number
    tipoServicioId: number
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerariosReserva?: ItinerarioReservaUncheckedCreateNestedManyWithoutServicioInput
    paquetesServicios?: PaqueteTuristicoServicioUncheckedCreateNestedManyWithoutServicioInput
    disponibilidad?: ServicioDisponibilidadUncheckedCreateNestedManyWithoutServicioInput
    serviciosEmprendedores?: ServicioEmprendedorUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerariosReserva?: ItinerarioReservaUpdateManyWithoutServicioNestedInput
    paquetesServicios?: PaqueteTuristicoServicioUpdateManyWithoutServicioNestedInput
    tipoServicio?: TipoServicioUpdateOneRequiredWithoutServiciosNestedInput
    disponibilidad?: ServicioDisponibilidadUpdateManyWithoutServicioNestedInput
    serviciosEmprendedores?: ServicioEmprendedorUpdateManyWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoServicioId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerariosReserva?: ItinerarioReservaUncheckedUpdateManyWithoutServicioNestedInput
    paquetesServicios?: PaqueteTuristicoServicioUncheckedUpdateManyWithoutServicioNestedInput
    disponibilidad?: ServicioDisponibilidadUncheckedUpdateManyWithoutServicioNestedInput
    serviciosEmprendedores?: ServicioEmprendedorUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type ServicioCreateManyInput = {
    id?: number
    tipoServicioId: number
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoServicioId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTuristicoServicioCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    paqueteTuristico: PaqueteTuristicoCreateNestedOneWithoutServiciosInput
    servicio: ServicioCreateNestedOneWithoutPaquetesServiciosInput
  }

  export type PaqueteTuristicoServicioUncheckedCreateInput = {
    id?: number
    servicioId: number
    paqueteTuristicoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaqueteTuristicoServicioUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paqueteTuristico?: PaqueteTuristicoUpdateOneRequiredWithoutServiciosNestedInput
    servicio?: ServicioUpdateOneRequiredWithoutPaquetesServiciosNestedInput
  }

  export type PaqueteTuristicoServicioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
    paqueteTuristicoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTuristicoServicioCreateManyInput = {
    id?: number
    servicioId: number
    paqueteTuristicoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaqueteTuristicoServicioUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTuristicoServicioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
    paqueteTuristicoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTuristicoCreateInput = {
    nombre: string
    descripcion: string
    duracionDias: number
    duracionNoches?: number | null
    precioPorPersona: Decimal | DecimalJsLike | number | string
    moneda?: string
    capacidadMaxima?: number | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: string | null
    incluye?: string | null
    noIncluye?: string | null
    estado?: string
    esPersonalizable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    disponibilidad?: DisponibilidadPaqueteCreateNestedManyWithoutPaqueteInput
    emprendimiento?: EmprendimientoCreateNestedOneWithoutPaquetesTuristicosInput
    servicios?: PaqueteTuristicoServicioCreateNestedManyWithoutPaqueteTuristicoInput
  }

  export type PaqueteTuristicoUncheckedCreateInput = {
    id?: number
    emprendimientoId?: number | null
    nombre: string
    descripcion: string
    duracionDias: number
    duracionNoches?: number | null
    precioPorPersona: Decimal | DecimalJsLike | number | string
    moneda?: string
    capacidadMaxima?: number | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: string | null
    incluye?: string | null
    noIncluye?: string | null
    estado?: string
    esPersonalizable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    disponibilidad?: DisponibilidadPaqueteUncheckedCreateNestedManyWithoutPaqueteInput
    servicios?: PaqueteTuristicoServicioUncheckedCreateNestedManyWithoutPaqueteTuristicoInput
  }

  export type PaqueteTuristicoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracionDias?: IntFieldUpdateOperationsInput | number
    duracionNoches?: NullableIntFieldUpdateOperationsInput | number | null
    precioPorPersona?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    capacidadMaxima?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null
    incluye?: NullableStringFieldUpdateOperationsInput | string | null
    noIncluye?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    esPersonalizable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disponibilidad?: DisponibilidadPaqueteUpdateManyWithoutPaqueteNestedInput
    emprendimiento?: EmprendimientoUpdateOneWithoutPaquetesTuristicosNestedInput
    servicios?: PaqueteTuristicoServicioUpdateManyWithoutPaqueteTuristicoNestedInput
  }

  export type PaqueteTuristicoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracionDias?: IntFieldUpdateOperationsInput | number
    duracionNoches?: NullableIntFieldUpdateOperationsInput | number | null
    precioPorPersona?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    capacidadMaxima?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null
    incluye?: NullableStringFieldUpdateOperationsInput | string | null
    noIncluye?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    esPersonalizable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disponibilidad?: DisponibilidadPaqueteUncheckedUpdateManyWithoutPaqueteNestedInput
    servicios?: PaqueteTuristicoServicioUncheckedUpdateManyWithoutPaqueteTuristicoNestedInput
  }

  export type PaqueteTuristicoCreateManyInput = {
    id?: number
    emprendimientoId?: number | null
    nombre: string
    descripcion: string
    duracionDias: number
    duracionNoches?: number | null
    precioPorPersona: Decimal | DecimalJsLike | number | string
    moneda?: string
    capacidadMaxima?: number | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: string | null
    incluye?: string | null
    noIncluye?: string | null
    estado?: string
    esPersonalizable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaqueteTuristicoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracionDias?: IntFieldUpdateOperationsInput | number
    duracionNoches?: NullableIntFieldUpdateOperationsInput | number | null
    precioPorPersona?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    capacidadMaxima?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null
    incluye?: NullableStringFieldUpdateOperationsInput | string | null
    noIncluye?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    esPersonalizable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTuristicoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracionDias?: IntFieldUpdateOperationsInput | number
    duracionNoches?: NullableIntFieldUpdateOperationsInput | number | null
    precioPorPersona?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    capacidadMaxima?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null
    incluye?: NullableStringFieldUpdateOperationsInput | string | null
    noIncluye?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    esPersonalizable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibilidadPaqueteCreateInput = {
    fechaInicio: Date | string
    fechaFin: Date | string
    cuposDisponibles: number
    precioEspecial?: Decimal | DecimalJsLike | number | string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paquete: PaqueteTuristicoCreateNestedOneWithoutDisponibilidadInput
  }

  export type DisponibilidadPaqueteUncheckedCreateInput = {
    id?: number
    paqueteId: number
    fechaInicio: Date | string
    fechaFin: Date | string
    cuposDisponibles: number
    precioEspecial?: Decimal | DecimalJsLike | number | string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisponibilidadPaqueteUpdateInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paquete?: PaqueteTuristicoUpdateOneRequiredWithoutDisponibilidadNestedInput
  }

  export type DisponibilidadPaqueteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    paqueteId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibilidadPaqueteCreateManyInput = {
    id?: number
    paqueteId: number
    fechaInicio: Date | string
    fechaFin: Date | string
    cuposDisponibles: number
    precioEspecial?: Decimal | DecimalJsLike | number | string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisponibilidadPaqueteUpdateManyMutationInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibilidadPaqueteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    paqueteId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoServicioCreateInput = {
    nombre: string
    descripcion?: string | null
    imagenUrl: string
    requiereCupo?: boolean
    createdAt?: Date | string
    servicios?: ServicioCreateNestedManyWithoutTipoServicioInput
  }

  export type TipoServicioUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    imagenUrl: string
    requiereCupo?: boolean
    createdAt?: Date | string
    servicios?: ServicioUncheckedCreateNestedManyWithoutTipoServicioInput
  }

  export type TipoServicioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    imagenUrl?: StringFieldUpdateOperationsInput | string
    requiereCupo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicios?: ServicioUpdateManyWithoutTipoServicioNestedInput
  }

  export type TipoServicioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    imagenUrl?: StringFieldUpdateOperationsInput | string
    requiereCupo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicios?: ServicioUncheckedUpdateManyWithoutTipoServicioNestedInput
  }

  export type TipoServicioCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    imagenUrl: string
    requiereCupo?: boolean
    createdAt?: Date | string
  }

  export type TipoServicioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    imagenUrl?: StringFieldUpdateOperationsInput | string
    requiereCupo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoServicioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    imagenUrl?: StringFieldUpdateOperationsInput | string
    requiereCupo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicioDisponibilidadCreateInput = {
    fecha: Date | string
    cuposDisponibles: number
    precioEspecial?: Decimal | DecimalJsLike | number | string | null
    servicio: ServicioCreateNestedOneWithoutDisponibilidadInput
  }

  export type ServicioDisponibilidadUncheckedCreateInput = {
    id?: number
    servicioId: number
    fecha: Date | string
    cuposDisponibles: number
    precioEspecial?: Decimal | DecimalJsLike | number | string | null
  }

  export type ServicioDisponibilidadUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    servicio?: ServicioUpdateOneRequiredWithoutDisponibilidadNestedInput
  }

  export type ServicioDisponibilidadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ServicioDisponibilidadCreateManyInput = {
    id?: number
    servicioId: number
    fecha: Date | string
    cuposDisponibles: number
    precioEspecial?: Decimal | DecimalJsLike | number | string | null
  }

  export type ServicioDisponibilidadUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ServicioDisponibilidadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ResenaCreateInput = {
    tipoObjeto: string
    calificacion: number
    comentario?: string | null
    fechaExperiencia?: Date | string | null
    respuestaOwner?: string | null
    fechaRespuesta?: Date | string | null
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutResenasInput
  }

  export type ResenaUncheckedCreateInput = {
    id?: number
    usuarioId: number
    tipoObjeto: string
    calificacion: number
    comentario?: string | null
    fechaExperiencia?: Date | string | null
    respuestaOwner?: string | null
    fechaRespuesta?: Date | string | null
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResenaUpdateInput = {
    tipoObjeto?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fechaExperiencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respuestaOwner?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutResenasNestedInput
  }

  export type ResenaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    tipoObjeto?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fechaExperiencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respuestaOwner?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResenaCreateManyInput = {
    id?: number
    usuarioId: number
    tipoObjeto: string
    calificacion: number
    comentario?: string | null
    fechaExperiencia?: Date | string | null
    respuestaOwner?: string | null
    fechaRespuesta?: Date | string | null
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResenaUpdateManyMutationInput = {
    tipoObjeto?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fechaExperiencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respuestaOwner?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResenaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    tipoObjeto?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fechaExperiencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respuestaOwner?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoCreateInput = {
    estado?: string
    createdAt?: Date | string
    emprendimiento: EmprendimientoCreateNestedOneWithoutFavoritosInput
    usuario: UsuarioCreateNestedOneWithoutFavoritosInput
  }

  export type FavoritoUncheckedCreateInput = {
    id?: number
    estado?: string
    usuarioId: number
    emprendimientoId: number
    createdAt?: Date | string
  }

  export type FavoritoUpdateInput = {
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimiento?: EmprendimientoUpdateOneRequiredWithoutFavoritosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutFavoritosNestedInput
  }

  export type FavoritoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoCreateManyInput = {
    id?: number
    estado?: string
    usuarioId: number
    emprendimientoId: number
    createdAt?: Date | string
  }

  export type FavoritoUpdateManyMutationInput = {
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservaCreateInput = {
    codigoReserva: string
    tipoReserva: string
    fechaReserva?: Date | string
    fechaInicio: Date | string
    hora?: string | null
    fechaFin?: Date | string | null
    cantidadPersonas?: number
    precioTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    metodoPago?: string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: string | null
    motivoCancelacion?: string | null
    fechaCancelacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarios?: ItinerarioReservaCreateNestedManyWithoutReservaInput
    pagos?: PagoCreateNestedManyWithoutReservaInput
    turista: TuristaCreateNestedOneWithoutReservasInput
  }

  export type ReservaUncheckedCreateInput = {
    id?: number
    codigoReserva: string
    turistaId: number
    tipoReserva: string
    fechaReserva?: Date | string
    fechaInicio: Date | string
    hora?: string | null
    fechaFin?: Date | string | null
    cantidadPersonas?: number
    precioTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    metodoPago?: string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: string | null
    motivoCancelacion?: string | null
    fechaCancelacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarios?: ItinerarioReservaUncheckedCreateNestedManyWithoutReservaInput
    pagos?: PagoUncheckedCreateNestedManyWithoutReservaInput
  }

  export type ReservaUpdateInput = {
    codigoReserva?: StringFieldUpdateOperationsInput | string
    tipoReserva?: StringFieldUpdateOperationsInput | string
    fechaReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableStringFieldUpdateOperationsInput | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidadPersonas?: IntFieldUpdateOperationsInput | number
    precioTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    motivoCancelacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCancelacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarios?: ItinerarioReservaUpdateManyWithoutReservaNestedInput
    pagos?: PagoUpdateManyWithoutReservaNestedInput
    turista?: TuristaUpdateOneRequiredWithoutReservasNestedInput
  }

  export type ReservaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoReserva?: StringFieldUpdateOperationsInput | string
    turistaId?: IntFieldUpdateOperationsInput | number
    tipoReserva?: StringFieldUpdateOperationsInput | string
    fechaReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableStringFieldUpdateOperationsInput | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidadPersonas?: IntFieldUpdateOperationsInput | number
    precioTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    motivoCancelacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCancelacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarios?: ItinerarioReservaUncheckedUpdateManyWithoutReservaNestedInput
    pagos?: PagoUncheckedUpdateManyWithoutReservaNestedInput
  }

  export type ReservaCreateManyInput = {
    id?: number
    codigoReserva: string
    turistaId: number
    tipoReserva: string
    fechaReserva?: Date | string
    fechaInicio: Date | string
    hora?: string | null
    fechaFin?: Date | string | null
    cantidadPersonas?: number
    precioTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    metodoPago?: string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: string | null
    motivoCancelacion?: string | null
    fechaCancelacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservaUpdateManyMutationInput = {
    codigoReserva?: StringFieldUpdateOperationsInput | string
    tipoReserva?: StringFieldUpdateOperationsInput | string
    fechaReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableStringFieldUpdateOperationsInput | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidadPersonas?: IntFieldUpdateOperationsInput | number
    precioTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    motivoCancelacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCancelacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoReserva?: StringFieldUpdateOperationsInput | string
    turistaId?: IntFieldUpdateOperationsInput | number
    tipoReserva?: StringFieldUpdateOperationsInput | string
    fechaReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableStringFieldUpdateOperationsInput | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidadPersonas?: IntFieldUpdateOperationsInput | number
    precioTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    motivoCancelacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCancelacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItinerarioReservaCreateInput = {
    fecha: Date | string
    hora?: Date | string | null
    tipoEvento: string
    descripcion: string
    notas?: string | null
    duracion?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarioLugares?: ItinerarioLugarCreateNestedManyWithoutItinerarioReservaInput
    reserva: ReservaCreateNestedOneWithoutItinerariosInput
    servicio?: ServicioCreateNestedOneWithoutItinerariosReservaInput
  }

  export type ItinerarioReservaUncheckedCreateInput = {
    id?: number
    fecha: Date | string
    hora?: Date | string | null
    tipoEvento: string
    descripcion: string
    notas?: string | null
    duracion?: number | null
    reservaId: number
    servicioId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarioLugares?: ItinerarioLugarUncheckedCreateNestedManyWithoutItinerarioReservaInput
  }

  export type ItinerarioReservaUpdateInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarioLugares?: ItinerarioLugarUpdateManyWithoutItinerarioReservaNestedInput
    reserva?: ReservaUpdateOneRequiredWithoutItinerariosNestedInput
    servicio?: ServicioUpdateOneWithoutItinerariosReservaNestedInput
  }

  export type ItinerarioReservaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    reservaId?: IntFieldUpdateOperationsInput | number
    servicioId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarioLugares?: ItinerarioLugarUncheckedUpdateManyWithoutItinerarioReservaNestedInput
  }

  export type ItinerarioReservaCreateManyInput = {
    id?: number
    fecha: Date | string
    hora?: Date | string | null
    tipoEvento: string
    descripcion: string
    notas?: string | null
    duracion?: number | null
    reservaId: number
    servicioId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItinerarioReservaUpdateManyMutationInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItinerarioReservaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    reservaId?: IntFieldUpdateOperationsInput | number
    servicioId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItinerarioLugarCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarioReserva: ItinerarioReservaCreateNestedOneWithoutItinerarioLugaresInput
    lugarTuristico: LugarTuristicoCreateNestedOneWithoutItinerarioLugaresInput
  }

  export type ItinerarioLugarUncheckedCreateInput = {
    id?: number
    itinerarioReservaId: number
    lugarTuristicoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItinerarioLugarUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarioReserva?: ItinerarioReservaUpdateOneRequiredWithoutItinerarioLugaresNestedInput
    lugarTuristico?: LugarTuristicoUpdateOneRequiredWithoutItinerarioLugaresNestedInput
  }

  export type ItinerarioLugarUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    itinerarioReservaId?: IntFieldUpdateOperationsInput | number
    lugarTuristicoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItinerarioLugarCreateManyInput = {
    id?: number
    itinerarioReservaId: number
    lugarTuristicoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItinerarioLugarUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItinerarioLugarUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    itinerarioReservaId?: IntFieldUpdateOperationsInput | number
    lugarTuristicoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoCreateInput = {
    codigoTransaccion?: string | null
    montoTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    fechaPago?: Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comprobante?: ComprobanteCreateNestedOneWithoutPagoInput
    reserva: ReservaCreateNestedOneWithoutPagosInput
    detalles?: PagoDetalleCreateNestedManyWithoutPagoInput
  }

  export type PagoUncheckedCreateInput = {
    id?: number
    reservaId: number
    codigoTransaccion?: string | null
    montoTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    fechaPago?: Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comprobante?: ComprobanteUncheckedCreateNestedOneWithoutPagoInput
    detalles?: PagoDetalleUncheckedCreateNestedManyWithoutPagoInput
  }

  export type PagoUpdateInput = {
    codigoTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    montoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comprobante?: ComprobanteUpdateOneWithoutPagoNestedInput
    reserva?: ReservaUpdateOneRequiredWithoutPagosNestedInput
    detalles?: PagoDetalleUpdateManyWithoutPagoNestedInput
  }

  export type PagoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservaId?: IntFieldUpdateOperationsInput | number
    codigoTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    montoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comprobante?: ComprobanteUncheckedUpdateOneWithoutPagoNestedInput
    detalles?: PagoDetalleUncheckedUpdateManyWithoutPagoNestedInput
  }

  export type PagoCreateManyInput = {
    id?: number
    reservaId: number
    codigoTransaccion?: string | null
    montoTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    fechaPago?: Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoUpdateManyMutationInput = {
    codigoTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    montoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservaId?: IntFieldUpdateOperationsInput | number
    codigoTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    montoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDetalleCreateInput = {
    concepto: string
    monto: Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: Decimal | DecimalJsLike | number | string
    cantidad?: number
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pago: PagoCreateNestedOneWithoutDetallesInput
    tipoPago: TipoPagoCreateNestedOneWithoutPagoDetallesInput
  }

  export type PagoDetalleUncheckedCreateInput = {
    id?: number
    pagoId: number
    tipoPagoId: number
    concepto: string
    monto: Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: Decimal | DecimalJsLike | number | string
    cantidad?: number
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoDetalleUpdateInput = {
    concepto?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pago?: PagoUpdateOneRequiredWithoutDetallesNestedInput
    tipoPago?: TipoPagoUpdateOneRequiredWithoutPagoDetallesNestedInput
  }

  export type PagoDetalleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pagoId?: IntFieldUpdateOperationsInput | number
    tipoPagoId?: IntFieldUpdateOperationsInput | number
    concepto?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDetalleCreateManyInput = {
    id?: number
    pagoId: number
    tipoPagoId: number
    concepto: string
    monto: Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: Decimal | DecimalJsLike | number | string
    cantidad?: number
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoDetalleUpdateManyMutationInput = {
    concepto?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDetalleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pagoId?: IntFieldUpdateOperationsInput | number
    tipoPagoId?: IntFieldUpdateOperationsInput | number
    concepto?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoPagoCreateInput = {
    nombre: string
    descripcion?: string | null
    requiereVerificacion?: boolean
    comisionPorcentaje?: Decimal | DecimalJsLike | number | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pagoDetalles?: PagoDetalleCreateNestedManyWithoutTipoPagoInput
  }

  export type TipoPagoUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    requiereVerificacion?: boolean
    comisionPorcentaje?: Decimal | DecimalJsLike | number | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    pagoDetalles?: PagoDetalleUncheckedCreateNestedManyWithoutTipoPagoInput
  }

  export type TipoPagoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    requiereVerificacion?: BoolFieldUpdateOperationsInput | boolean
    comisionPorcentaje?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagoDetalles?: PagoDetalleUpdateManyWithoutTipoPagoNestedInput
  }

  export type TipoPagoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    requiereVerificacion?: BoolFieldUpdateOperationsInput | boolean
    comisionPorcentaje?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagoDetalles?: PagoDetalleUncheckedUpdateManyWithoutTipoPagoNestedInput
  }

  export type TipoPagoCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    requiereVerificacion?: boolean
    comisionPorcentaje?: Decimal | DecimalJsLike | number | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TipoPagoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    requiereVerificacion?: BoolFieldUpdateOperationsInput | boolean
    comisionPorcentaje?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoPagoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    requiereVerificacion?: BoolFieldUpdateOperationsInput | boolean
    comisionPorcentaje?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComprobanteCreateInput = {
    tipoComprobante: string
    serie: string
    numero: number
    fechaEmision?: Date | string
    rucCliente?: string | null
    razonSocial?: string | null
    direccionCliente?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    igv?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    codigoSunat?: string | null
    codigoHash?: string | null
    xmlUrl?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pago: PagoCreateNestedOneWithoutComprobanteInput
  }

  export type ComprobanteUncheckedCreateInput = {
    id?: number
    pagoId: number
    tipoComprobante: string
    serie: string
    numero: number
    fechaEmision?: Date | string
    rucCliente?: string | null
    razonSocial?: string | null
    direccionCliente?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    igv?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    codigoSunat?: string | null
    codigoHash?: string | null
    xmlUrl?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComprobanteUpdateInput = {
    tipoComprobante?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    rucCliente?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    direccionCliente?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    codigoSunat?: NullableStringFieldUpdateOperationsInput | string | null
    codigoHash?: NullableStringFieldUpdateOperationsInput | string | null
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pago?: PagoUpdateOneRequiredWithoutComprobanteNestedInput
  }

  export type ComprobanteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pagoId?: IntFieldUpdateOperationsInput | number
    tipoComprobante?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    rucCliente?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    direccionCliente?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    codigoSunat?: NullableStringFieldUpdateOperationsInput | string | null
    codigoHash?: NullableStringFieldUpdateOperationsInput | string | null
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComprobanteCreateManyInput = {
    id?: number
    pagoId: number
    tipoComprobante: string
    serie: string
    numero: number
    fechaEmision?: Date | string
    rucCliente?: string | null
    razonSocial?: string | null
    direccionCliente?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    igv?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    codigoSunat?: string | null
    codigoHash?: string | null
    xmlUrl?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComprobanteUpdateManyMutationInput = {
    tipoComprobante?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    rucCliente?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    direccionCliente?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    codigoSunat?: NullableStringFieldUpdateOperationsInput | string | null
    codigoHash?: NullableStringFieldUpdateOperationsInput | string | null
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComprobanteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pagoId?: IntFieldUpdateOperationsInput | number
    tipoComprobante?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    rucCliente?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    direccionCliente?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    codigoSunat?: NullableStringFieldUpdateOperationsInput | string | null
    codigoHash?: NullableStringFieldUpdateOperationsInput | string | null
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RolesPermisosListRelationFilter = {
    every?: RolesPermisosWhereInput
    some?: RolesPermisosWhereInput
    none?: RolesPermisosWhereInput
  }

  export type UsuariosRolesListRelationFilter = {
    every?: UsuariosRolesWhereInput
    some?: UsuariosRolesWhereInput
    none?: UsuariosRolesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RolesPermisosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuariosRolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PermisoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermisoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermisoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermisoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermisoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermisoScalarRelationFilter = {
    is?: PermisoWhereInput
    isNot?: PermisoWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type RolesPermisosRolIdPermisoIdCompoundUniqueInput = {
    rolId: number
    permisoId: number
  }

  export type RolesPermisosCountOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    permisoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolesPermisosAvgOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    permisoId?: SortOrder
  }

  export type RolesPermisosMaxOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    permisoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolesPermisosMinOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    permisoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolesPermisosSumOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    permisoId?: SortOrder
  }

  export type SubdivisionListRelationFilter = {
    every?: SubdivisionWhereInput
    some?: SubdivisionWhereInput
    none?: SubdivisionWhereInput
  }

  export type SubdivisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    codeIso?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    codeIso?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    codeIso?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmprendimientoListRelationFilter = {
    every?: EmprendimientoWhereInput
    some?: EmprendimientoWhereInput
    none?: EmprendimientoWhereInput
  }

  export type PersonaListRelationFilter = {
    every?: PersonaWhereInput
    some?: PersonaWhereInput
    none?: PersonaWhereInput
  }

  export type CountryScalarRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type EmprendimientoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubdivisionCountryIdNameCompoundUniqueInput = {
    countryId: number
    name: string
  }

  export type SubdivisionCountOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubdivisionAvgOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type SubdivisionMaxOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubdivisionMinOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubdivisionSumOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SubdivisionScalarRelationFilter = {
    is?: SubdivisionWhereInput
    isNot?: SubdivisionWhereInput
  }

  export type UsuarioNullableScalarRelationFilter = {
    is?: UsuarioWhereInput | null
    isNot?: UsuarioWhereInput | null
  }

  export type PersonaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fotoPerfilUrl?: SortOrder
    fechaNacimiento?: SortOrder
    subdivisionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonaAvgOrderByAggregateInput = {
    id?: SortOrder
    subdivisionId?: SortOrder
  }

  export type PersonaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fotoPerfilUrl?: SortOrder
    fechaNacimiento?: SortOrder
    subdivisionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fotoPerfilUrl?: SortOrder
    fechaNacimiento?: SortOrder
    subdivisionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonaSumOrderByAggregateInput = {
    id?: SortOrder
    subdivisionId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FavoritoListRelationFilter = {
    every?: FavoritoWhereInput
    some?: FavoritoWhereInput
    none?: FavoritoWhereInput
  }

  export type RegistroAccesoListRelationFilter = {
    every?: RegistroAccesoWhereInput
    some?: RegistroAccesoWhereInput
    none?: RegistroAccesoWhereInput
  }

  export type ResenaListRelationFilter = {
    every?: ResenaWhereInput
    some?: ResenaWhereInput
    none?: ResenaWhereInput
  }

  export type TokenInvalidadoListRelationFilter = {
    every?: TokenInvalidadoWhereInput
    some?: TokenInvalidadoWhereInput
    none?: TokenInvalidadoWhereInput
  }

  export type PersonaScalarRelationFilter = {
    is?: PersonaWhereInput
    isNot?: PersonaWhereInput
  }

  export type FavoritoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegistroAccesoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResenaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenInvalidadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    personaId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    recoveryToken?: SortOrder
    recoveryTokenExpiresAt?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerified?: SortOrder
    estaActivo?: SortOrder
    ultimoAcceso?: SortOrder
    preferencias?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    personaId?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    personaId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    recoveryToken?: SortOrder
    recoveryTokenExpiresAt?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerified?: SortOrder
    estaActivo?: SortOrder
    ultimoAcceso?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    personaId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    recoveryToken?: SortOrder
    recoveryTokenExpiresAt?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerified?: SortOrder
    estaActivo?: SortOrder
    ultimoAcceso?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
    personaId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type UsuarioScalarRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type UsuariosRolesUsuarioIdRolIdCompoundUniqueInput = {
    usuarioId: number
    rolId: number
  }

  export type UsuariosRolesCountOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuariosRolesAvgOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    usuarioId?: SortOrder
  }

  export type UsuariosRolesMaxOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuariosRolesMinOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    usuarioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuariosRolesSumOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    usuarioId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SubdivisionNullableScalarRelationFilter = {
    is?: SubdivisionWhereInput | null
    isNot?: SubdivisionWhereInput | null
  }

  export type PaqueteTuristicoListRelationFilter = {
    every?: PaqueteTuristicoWhereInput
    some?: PaqueteTuristicoWhereInput
    none?: PaqueteTuristicoWhereInput
  }

  export type ServicioEmprendedorListRelationFilter = {
    every?: ServicioEmprendedorWhereInput
    some?: ServicioEmprendedorWhereInput
    none?: ServicioEmprendedorWhereInput
  }

  export type PaqueteTuristicoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicioEmprendedorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmprendimientoCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    direccion?: SortOrder
    subdivisionId?: SortOrder
    coordenadas?: SortOrder
    contactoTelefono?: SortOrder
    contactoEmail?: SortOrder
    sitioWeb?: SortOrder
    redesSociales?: SortOrder
    estado?: SortOrder
    fechaAprobacion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmprendimientoAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    subdivisionId?: SortOrder
  }

  export type EmprendimientoMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    direccion?: SortOrder
    subdivisionId?: SortOrder
    coordenadas?: SortOrder
    contactoTelefono?: SortOrder
    contactoEmail?: SortOrder
    sitioWeb?: SortOrder
    estado?: SortOrder
    fechaAprobacion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmprendimientoMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    tipo?: SortOrder
    direccion?: SortOrder
    subdivisionId?: SortOrder
    coordenadas?: SortOrder
    contactoTelefono?: SortOrder
    contactoEmail?: SortOrder
    sitioWeb?: SortOrder
    estado?: SortOrder
    fechaAprobacion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmprendimientoSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    subdivisionId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type RegistroAccesoCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    tipoEvento?: SortOrder
    detalles?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegistroAccesoAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type RegistroAccesoMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    tipoEvento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegistroAccesoMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    tipoEvento?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RegistroAccesoSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type TokenInvalidadoCountOrderByAggregateInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    usuarioId?: SortOrder
    invalidadoEn?: SortOrder
    expiraEn?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenInvalidadoAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type TokenInvalidadoMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    usuarioId?: SortOrder
    invalidadoEn?: SortOrder
    expiraEn?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenInvalidadoMinOrderByAggregateInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    usuarioId?: SortOrder
    invalidadoEn?: SortOrder
    expiraEn?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenInvalidadoSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ReservaListRelationFilter = {
    every?: ReservaWhereInput
    some?: ReservaWhereInput
    none?: ReservaWhereInput
  }

  export type ReservaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TuristaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    edad?: SortOrder
    sexo?: SortOrder
    pais?: SortOrder
    peticionesEspeciales?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TuristaAvgOrderByAggregateInput = {
    id?: SortOrder
    edad?: SortOrder
  }

  export type TuristaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    edad?: SortOrder
    sexo?: SortOrder
    pais?: SortOrder
    peticionesEspeciales?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TuristaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    edad?: SortOrder
    sexo?: SortOrder
    pais?: SortOrder
    peticionesEspeciales?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TuristaSumOrderByAggregateInput = {
    id?: SortOrder
    edad?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ItinerarioLugarListRelationFilter = {
    every?: ItinerarioLugarWhereInput
    some?: ItinerarioLugarWhereInput
    none?: ItinerarioLugarWhereInput
  }

  export type ItinerarioLugarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LugarTuristicoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    direccion?: SortOrder
    coordenadas?: SortOrder
    horarioApertura?: SortOrder
    horarioCierre?: SortOrder
    costoEntrada?: SortOrder
    recomendaciones?: SortOrder
    restricciones?: SortOrder
    esDestacado?: SortOrder
    estado?: SortOrder
    imagenUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LugarTuristicoAvgOrderByAggregateInput = {
    id?: SortOrder
    costoEntrada?: SortOrder
  }

  export type LugarTuristicoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    direccion?: SortOrder
    coordenadas?: SortOrder
    horarioApertura?: SortOrder
    horarioCierre?: SortOrder
    costoEntrada?: SortOrder
    recomendaciones?: SortOrder
    restricciones?: SortOrder
    esDestacado?: SortOrder
    estado?: SortOrder
    imagenUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LugarTuristicoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    direccion?: SortOrder
    coordenadas?: SortOrder
    horarioApertura?: SortOrder
    horarioCierre?: SortOrder
    costoEntrada?: SortOrder
    recomendaciones?: SortOrder
    restricciones?: SortOrder
    esDestacado?: SortOrder
    estado?: SortOrder
    imagenUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LugarTuristicoSumOrderByAggregateInput = {
    id?: SortOrder
    costoEntrada?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EmprendimientoScalarRelationFilter = {
    is?: EmprendimientoWhereInput
    isNot?: EmprendimientoWhereInput
  }

  export type ServicioScalarRelationFilter = {
    is?: ServicioWhereInput
    isNot?: ServicioWhereInput
  }

  export type ServicioEmprendedorCountOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    emprendimientoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicioEmprendedorAvgOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type ServicioEmprendedorMaxOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    emprendimientoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicioEmprendedorMinOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    emprendimientoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicioEmprendedorSumOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type ItinerarioReservaListRelationFilter = {
    every?: ItinerarioReservaWhereInput
    some?: ItinerarioReservaWhereInput
    none?: ItinerarioReservaWhereInput
  }

  export type PaqueteTuristicoServicioListRelationFilter = {
    every?: PaqueteTuristicoServicioWhereInput
    some?: PaqueteTuristicoServicioWhereInput
    none?: PaqueteTuristicoServicioWhereInput
  }

  export type TipoServicioScalarRelationFilter = {
    is?: TipoServicioWhereInput
    isNot?: TipoServicioWhereInput
  }

  export type ServicioDisponibilidadListRelationFilter = {
    every?: ServicioDisponibilidadWhereInput
    some?: ServicioDisponibilidadWhereInput
    none?: ServicioDisponibilidadWhereInput
  }

  export type ItinerarioReservaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaqueteTuristicoServicioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicioDisponibilidadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicioCountOrderByAggregateInput = {
    id?: SortOrder
    tipoServicioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precioBase?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    imagenUrl?: SortOrder
    detallesServicio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicioAvgOrderByAggregateInput = {
    id?: SortOrder
    tipoServicioId?: SortOrder
    precioBase?: SortOrder
  }

  export type ServicioMaxOrderByAggregateInput = {
    id?: SortOrder
    tipoServicioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precioBase?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    imagenUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicioMinOrderByAggregateInput = {
    id?: SortOrder
    tipoServicioId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precioBase?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    imagenUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicioSumOrderByAggregateInput = {
    id?: SortOrder
    tipoServicioId?: SortOrder
    precioBase?: SortOrder
  }

  export type PaqueteTuristicoScalarRelationFilter = {
    is?: PaqueteTuristicoWhereInput
    isNot?: PaqueteTuristicoWhereInput
  }

  export type PaqueteTuristicoServicioCountOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    paqueteTuristicoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaqueteTuristicoServicioAvgOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    paqueteTuristicoId?: SortOrder
  }

  export type PaqueteTuristicoServicioMaxOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    paqueteTuristicoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaqueteTuristicoServicioMinOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    paqueteTuristicoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaqueteTuristicoServicioSumOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    paqueteTuristicoId?: SortOrder
  }

  export type DisponibilidadPaqueteListRelationFilter = {
    every?: DisponibilidadPaqueteWhereInput
    some?: DisponibilidadPaqueteWhereInput
    none?: DisponibilidadPaqueteWhereInput
  }

  export type EmprendimientoNullableScalarRelationFilter = {
    is?: EmprendimientoWhereInput | null
    isNot?: EmprendimientoWhereInput | null
  }

  export type DisponibilidadPaqueteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaqueteTuristicoCountOrderByAggregateInput = {
    id?: SortOrder
    emprendimientoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    duracionDias?: SortOrder
    duracionNoches?: SortOrder
    precioPorPersona?: SortOrder
    moneda?: SortOrder
    capacidadMaxima?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    lugaresVisitados?: SortOrder
    requisitos?: SortOrder
    incluye?: SortOrder
    noIncluye?: SortOrder
    estado?: SortOrder
    esPersonalizable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaqueteTuristicoAvgOrderByAggregateInput = {
    id?: SortOrder
    emprendimientoId?: SortOrder
    duracionDias?: SortOrder
    duracionNoches?: SortOrder
    precioPorPersona?: SortOrder
    capacidadMaxima?: SortOrder
  }

  export type PaqueteTuristicoMaxOrderByAggregateInput = {
    id?: SortOrder
    emprendimientoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    duracionDias?: SortOrder
    duracionNoches?: SortOrder
    precioPorPersona?: SortOrder
    moneda?: SortOrder
    capacidadMaxima?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    requisitos?: SortOrder
    incluye?: SortOrder
    noIncluye?: SortOrder
    estado?: SortOrder
    esPersonalizable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaqueteTuristicoMinOrderByAggregateInput = {
    id?: SortOrder
    emprendimientoId?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    duracionDias?: SortOrder
    duracionNoches?: SortOrder
    precioPorPersona?: SortOrder
    moneda?: SortOrder
    capacidadMaxima?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    requisitos?: SortOrder
    incluye?: SortOrder
    noIncluye?: SortOrder
    estado?: SortOrder
    esPersonalizable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaqueteTuristicoSumOrderByAggregateInput = {
    id?: SortOrder
    emprendimientoId?: SortOrder
    duracionDias?: SortOrder
    duracionNoches?: SortOrder
    precioPorPersona?: SortOrder
    capacidadMaxima?: SortOrder
  }

  export type DisponibilidadPaquetePaqueteIdFechaInicioFechaFinCompoundUniqueInput = {
    paqueteId: number
    fechaInicio: Date | string
    fechaFin: Date | string
  }

  export type DisponibilidadPaqueteCountOrderByAggregateInput = {
    id?: SortOrder
    paqueteId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrder
    notas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisponibilidadPaqueteAvgOrderByAggregateInput = {
    id?: SortOrder
    paqueteId?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrder
  }

  export type DisponibilidadPaqueteMaxOrderByAggregateInput = {
    id?: SortOrder
    paqueteId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrder
    notas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisponibilidadPaqueteMinOrderByAggregateInput = {
    id?: SortOrder
    paqueteId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrder
    notas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisponibilidadPaqueteSumOrderByAggregateInput = {
    id?: SortOrder
    paqueteId?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrder
  }

  export type ServicioListRelationFilter = {
    every?: ServicioWhereInput
    some?: ServicioWhereInput
    none?: ServicioWhereInput
  }

  export type ServicioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TipoServicioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    imagenUrl?: SortOrder
    requiereCupo?: SortOrder
    createdAt?: SortOrder
  }

  export type TipoServicioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoServicioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    imagenUrl?: SortOrder
    requiereCupo?: SortOrder
    createdAt?: SortOrder
  }

  export type TipoServicioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    imagenUrl?: SortOrder
    requiereCupo?: SortOrder
    createdAt?: SortOrder
  }

  export type TipoServicioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServicioDisponibilidadServicioIdFechaCompoundUniqueInput = {
    servicioId: number
    fecha: Date | string
  }

  export type ServicioDisponibilidadCountOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    fecha?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrder
  }

  export type ServicioDisponibilidadAvgOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrder
  }

  export type ServicioDisponibilidadMaxOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    fecha?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrder
  }

  export type ServicioDisponibilidadMinOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    fecha?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrder
  }

  export type ServicioDisponibilidadSumOrderByAggregateInput = {
    id?: SortOrder
    servicioId?: SortOrder
    cuposDisponibles?: SortOrder
    precioEspecial?: SortOrder
  }

  export type ResenaCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipoObjeto?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    fechaExperiencia?: SortOrder
    respuestaOwner?: SortOrder
    fechaRespuesta?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResenaAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    calificacion?: SortOrder
  }

  export type ResenaMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipoObjeto?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    fechaExperiencia?: SortOrder
    respuestaOwner?: SortOrder
    fechaRespuesta?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResenaMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tipoObjeto?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    fechaExperiencia?: SortOrder
    respuestaOwner?: SortOrder
    fechaRespuesta?: SortOrder
    estado?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResenaSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    calificacion?: SortOrder
  }

  export type FavoritoEmprendimientoIdUsuarioIdCompoundUniqueInput = {
    emprendimientoId: number
    usuarioId: number
  }

  export type FavoritoCountOrderByAggregateInput = {
    id?: SortOrder
    estado?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoritoAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type FavoritoMaxOrderByAggregateInput = {
    id?: SortOrder
    estado?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoritoMinOrderByAggregateInput = {
    id?: SortOrder
    estado?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoritoSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type PagoListRelationFilter = {
    every?: PagoWhereInput
    some?: PagoWhereInput
    none?: PagoWhereInput
  }

  export type TuristaScalarRelationFilter = {
    is?: TuristaWhereInput
    isNot?: TuristaWhereInput
  }

  export type PagoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservaCountOrderByAggregateInput = {
    id?: SortOrder
    codigoReserva?: SortOrder
    turistaId?: SortOrder
    tipoReserva?: SortOrder
    fechaReserva?: SortOrder
    fechaInicio?: SortOrder
    hora?: SortOrder
    fechaFin?: SortOrder
    cantidadPersonas?: SortOrder
    precioTotal?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    metodoPago?: SortOrder
    datosPago?: SortOrder
    notas?: SortOrder
    motivoCancelacion?: SortOrder
    fechaCancelacion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservaAvgOrderByAggregateInput = {
    id?: SortOrder
    turistaId?: SortOrder
    cantidadPersonas?: SortOrder
    precioTotal?: SortOrder
  }

  export type ReservaMaxOrderByAggregateInput = {
    id?: SortOrder
    codigoReserva?: SortOrder
    turistaId?: SortOrder
    tipoReserva?: SortOrder
    fechaReserva?: SortOrder
    fechaInicio?: SortOrder
    hora?: SortOrder
    fechaFin?: SortOrder
    cantidadPersonas?: SortOrder
    precioTotal?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    metodoPago?: SortOrder
    notas?: SortOrder
    motivoCancelacion?: SortOrder
    fechaCancelacion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservaMinOrderByAggregateInput = {
    id?: SortOrder
    codigoReserva?: SortOrder
    turistaId?: SortOrder
    tipoReserva?: SortOrder
    fechaReserva?: SortOrder
    fechaInicio?: SortOrder
    hora?: SortOrder
    fechaFin?: SortOrder
    cantidadPersonas?: SortOrder
    precioTotal?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    metodoPago?: SortOrder
    notas?: SortOrder
    motivoCancelacion?: SortOrder
    fechaCancelacion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservaSumOrderByAggregateInput = {
    id?: SortOrder
    turistaId?: SortOrder
    cantidadPersonas?: SortOrder
    precioTotal?: SortOrder
  }

  export type ReservaScalarRelationFilter = {
    is?: ReservaWhereInput
    isNot?: ReservaWhereInput
  }

  export type ServicioNullableScalarRelationFilter = {
    is?: ServicioWhereInput | null
    isNot?: ServicioWhereInput | null
  }

  export type ItinerarioReservaCountOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    tipoEvento?: SortOrder
    descripcion?: SortOrder
    notas?: SortOrder
    duracion?: SortOrder
    reservaId?: SortOrder
    servicioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItinerarioReservaAvgOrderByAggregateInput = {
    id?: SortOrder
    duracion?: SortOrder
    reservaId?: SortOrder
    servicioId?: SortOrder
  }

  export type ItinerarioReservaMaxOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    tipoEvento?: SortOrder
    descripcion?: SortOrder
    notas?: SortOrder
    duracion?: SortOrder
    reservaId?: SortOrder
    servicioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItinerarioReservaMinOrderByAggregateInput = {
    id?: SortOrder
    fecha?: SortOrder
    hora?: SortOrder
    tipoEvento?: SortOrder
    descripcion?: SortOrder
    notas?: SortOrder
    duracion?: SortOrder
    reservaId?: SortOrder
    servicioId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItinerarioReservaSumOrderByAggregateInput = {
    id?: SortOrder
    duracion?: SortOrder
    reservaId?: SortOrder
    servicioId?: SortOrder
  }

  export type ItinerarioReservaScalarRelationFilter = {
    is?: ItinerarioReservaWhereInput
    isNot?: ItinerarioReservaWhereInput
  }

  export type LugarTuristicoScalarRelationFilter = {
    is?: LugarTuristicoWhereInput
    isNot?: LugarTuristicoWhereInput
  }

  export type ItinerarioLugarCountOrderByAggregateInput = {
    id?: SortOrder
    itinerarioReservaId?: SortOrder
    lugarTuristicoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItinerarioLugarAvgOrderByAggregateInput = {
    id?: SortOrder
    itinerarioReservaId?: SortOrder
    lugarTuristicoId?: SortOrder
  }

  export type ItinerarioLugarMaxOrderByAggregateInput = {
    id?: SortOrder
    itinerarioReservaId?: SortOrder
    lugarTuristicoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItinerarioLugarMinOrderByAggregateInput = {
    id?: SortOrder
    itinerarioReservaId?: SortOrder
    lugarTuristicoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItinerarioLugarSumOrderByAggregateInput = {
    id?: SortOrder
    itinerarioReservaId?: SortOrder
    lugarTuristicoId?: SortOrder
  }

  export type ComprobanteNullableScalarRelationFilter = {
    is?: ComprobanteWhereInput | null
    isNot?: ComprobanteWhereInput | null
  }

  export type PagoDetalleListRelationFilter = {
    every?: PagoDetalleWhereInput
    some?: PagoDetalleWhereInput
    none?: PagoDetalleWhereInput
  }

  export type PagoDetalleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PagoCountOrderByAggregateInput = {
    id?: SortOrder
    reservaId?: SortOrder
    codigoTransaccion?: SortOrder
    montoTotal?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    fechaPago?: SortOrder
    datosMetodoPago?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagoAvgOrderByAggregateInput = {
    id?: SortOrder
    reservaId?: SortOrder
    montoTotal?: SortOrder
  }

  export type PagoMaxOrderByAggregateInput = {
    id?: SortOrder
    reservaId?: SortOrder
    codigoTransaccion?: SortOrder
    montoTotal?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    fechaPago?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagoMinOrderByAggregateInput = {
    id?: SortOrder
    reservaId?: SortOrder
    codigoTransaccion?: SortOrder
    montoTotal?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    fechaPago?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagoSumOrderByAggregateInput = {
    id?: SortOrder
    reservaId?: SortOrder
    montoTotal?: SortOrder
  }

  export type PagoScalarRelationFilter = {
    is?: PagoWhereInput
    isNot?: PagoWhereInput
  }

  export type TipoPagoScalarRelationFilter = {
    is?: TipoPagoWhereInput
    isNot?: TipoPagoWhereInput
  }

  export type PagoDetalleCountOrderByAggregateInput = {
    id?: SortOrder
    pagoId?: SortOrder
    tipoPagoId?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    porcentajeImpuesto?: SortOrder
    cantidad?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagoDetalleAvgOrderByAggregateInput = {
    id?: SortOrder
    pagoId?: SortOrder
    tipoPagoId?: SortOrder
    monto?: SortOrder
    porcentajeImpuesto?: SortOrder
    cantidad?: SortOrder
  }

  export type PagoDetalleMaxOrderByAggregateInput = {
    id?: SortOrder
    pagoId?: SortOrder
    tipoPagoId?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    porcentajeImpuesto?: SortOrder
    cantidad?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagoDetalleMinOrderByAggregateInput = {
    id?: SortOrder
    pagoId?: SortOrder
    tipoPagoId?: SortOrder
    concepto?: SortOrder
    monto?: SortOrder
    porcentajeImpuesto?: SortOrder
    cantidad?: SortOrder
    descripcion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PagoDetalleSumOrderByAggregateInput = {
    id?: SortOrder
    pagoId?: SortOrder
    tipoPagoId?: SortOrder
    monto?: SortOrder
    porcentajeImpuesto?: SortOrder
    cantidad?: SortOrder
  }

  export type TipoPagoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    requiereVerificacion?: SortOrder
    comisionPorcentaje?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TipoPagoAvgOrderByAggregateInput = {
    id?: SortOrder
    comisionPorcentaje?: SortOrder
  }

  export type TipoPagoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    requiereVerificacion?: SortOrder
    comisionPorcentaje?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TipoPagoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    requiereVerificacion?: SortOrder
    comisionPorcentaje?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TipoPagoSumOrderByAggregateInput = {
    id?: SortOrder
    comisionPorcentaje?: SortOrder
  }

  export type ComprobanteSerieNumeroCompoundUniqueInput = {
    serie: string
    numero: number
  }

  export type ComprobanteCountOrderByAggregateInput = {
    id?: SortOrder
    pagoId?: SortOrder
    tipoComprobante?: SortOrder
    serie?: SortOrder
    numero?: SortOrder
    fechaEmision?: SortOrder
    rucCliente?: SortOrder
    razonSocial?: SortOrder
    direccionCliente?: SortOrder
    subtotal?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    codigoSunat?: SortOrder
    codigoHash?: SortOrder
    xmlUrl?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComprobanteAvgOrderByAggregateInput = {
    id?: SortOrder
    pagoId?: SortOrder
    numero?: SortOrder
    subtotal?: SortOrder
    igv?: SortOrder
    total?: SortOrder
  }

  export type ComprobanteMaxOrderByAggregateInput = {
    id?: SortOrder
    pagoId?: SortOrder
    tipoComprobante?: SortOrder
    serie?: SortOrder
    numero?: SortOrder
    fechaEmision?: SortOrder
    rucCliente?: SortOrder
    razonSocial?: SortOrder
    direccionCliente?: SortOrder
    subtotal?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    codigoSunat?: SortOrder
    codigoHash?: SortOrder
    xmlUrl?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComprobanteMinOrderByAggregateInput = {
    id?: SortOrder
    pagoId?: SortOrder
    tipoComprobante?: SortOrder
    serie?: SortOrder
    numero?: SortOrder
    fechaEmision?: SortOrder
    rucCliente?: SortOrder
    razonSocial?: SortOrder
    direccionCliente?: SortOrder
    subtotal?: SortOrder
    igv?: SortOrder
    total?: SortOrder
    moneda?: SortOrder
    estado?: SortOrder
    codigoSunat?: SortOrder
    codigoHash?: SortOrder
    xmlUrl?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComprobanteSumOrderByAggregateInput = {
    id?: SortOrder
    pagoId?: SortOrder
    numero?: SortOrder
    subtotal?: SortOrder
    igv?: SortOrder
    total?: SortOrder
  }

  export type RolesPermisosCreateNestedManyWithoutRolInput = {
    create?: XOR<RolesPermisosCreateWithoutRolInput, RolesPermisosUncheckedCreateWithoutRolInput> | RolesPermisosCreateWithoutRolInput[] | RolesPermisosUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolesPermisosCreateOrConnectWithoutRolInput | RolesPermisosCreateOrConnectWithoutRolInput[]
    createMany?: RolesPermisosCreateManyRolInputEnvelope
    connect?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
  }

  export type UsuariosRolesCreateNestedManyWithoutRolInput = {
    create?: XOR<UsuariosRolesCreateWithoutRolInput, UsuariosRolesUncheckedCreateWithoutRolInput> | UsuariosRolesCreateWithoutRolInput[] | UsuariosRolesUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuariosRolesCreateOrConnectWithoutRolInput | UsuariosRolesCreateOrConnectWithoutRolInput[]
    createMany?: UsuariosRolesCreateManyRolInputEnvelope
    connect?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
  }

  export type RolesPermisosUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<RolesPermisosCreateWithoutRolInput, RolesPermisosUncheckedCreateWithoutRolInput> | RolesPermisosCreateWithoutRolInput[] | RolesPermisosUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolesPermisosCreateOrConnectWithoutRolInput | RolesPermisosCreateOrConnectWithoutRolInput[]
    createMany?: RolesPermisosCreateManyRolInputEnvelope
    connect?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
  }

  export type UsuariosRolesUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<UsuariosRolesCreateWithoutRolInput, UsuariosRolesUncheckedCreateWithoutRolInput> | UsuariosRolesCreateWithoutRolInput[] | UsuariosRolesUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuariosRolesCreateOrConnectWithoutRolInput | UsuariosRolesCreateOrConnectWithoutRolInput[]
    createMany?: UsuariosRolesCreateManyRolInputEnvelope
    connect?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RolesPermisosUpdateManyWithoutRolNestedInput = {
    create?: XOR<RolesPermisosCreateWithoutRolInput, RolesPermisosUncheckedCreateWithoutRolInput> | RolesPermisosCreateWithoutRolInput[] | RolesPermisosUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolesPermisosCreateOrConnectWithoutRolInput | RolesPermisosCreateOrConnectWithoutRolInput[]
    upsert?: RolesPermisosUpsertWithWhereUniqueWithoutRolInput | RolesPermisosUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: RolesPermisosCreateManyRolInputEnvelope
    set?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    disconnect?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    delete?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    connect?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    update?: RolesPermisosUpdateWithWhereUniqueWithoutRolInput | RolesPermisosUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: RolesPermisosUpdateManyWithWhereWithoutRolInput | RolesPermisosUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: RolesPermisosScalarWhereInput | RolesPermisosScalarWhereInput[]
  }

  export type UsuariosRolesUpdateManyWithoutRolNestedInput = {
    create?: XOR<UsuariosRolesCreateWithoutRolInput, UsuariosRolesUncheckedCreateWithoutRolInput> | UsuariosRolesCreateWithoutRolInput[] | UsuariosRolesUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuariosRolesCreateOrConnectWithoutRolInput | UsuariosRolesCreateOrConnectWithoutRolInput[]
    upsert?: UsuariosRolesUpsertWithWhereUniqueWithoutRolInput | UsuariosRolesUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: UsuariosRolesCreateManyRolInputEnvelope
    set?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    disconnect?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    delete?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    connect?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    update?: UsuariosRolesUpdateWithWhereUniqueWithoutRolInput | UsuariosRolesUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: UsuariosRolesUpdateManyWithWhereWithoutRolInput | UsuariosRolesUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: UsuariosRolesScalarWhereInput | UsuariosRolesScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RolesPermisosUncheckedUpdateManyWithoutRolNestedInput = {
    create?: XOR<RolesPermisosCreateWithoutRolInput, RolesPermisosUncheckedCreateWithoutRolInput> | RolesPermisosCreateWithoutRolInput[] | RolesPermisosUncheckedCreateWithoutRolInput[]
    connectOrCreate?: RolesPermisosCreateOrConnectWithoutRolInput | RolesPermisosCreateOrConnectWithoutRolInput[]
    upsert?: RolesPermisosUpsertWithWhereUniqueWithoutRolInput | RolesPermisosUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: RolesPermisosCreateManyRolInputEnvelope
    set?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    disconnect?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    delete?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    connect?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    update?: RolesPermisosUpdateWithWhereUniqueWithoutRolInput | RolesPermisosUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: RolesPermisosUpdateManyWithWhereWithoutRolInput | RolesPermisosUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: RolesPermisosScalarWhereInput | RolesPermisosScalarWhereInput[]
  }

  export type UsuariosRolesUncheckedUpdateManyWithoutRolNestedInput = {
    create?: XOR<UsuariosRolesCreateWithoutRolInput, UsuariosRolesUncheckedCreateWithoutRolInput> | UsuariosRolesCreateWithoutRolInput[] | UsuariosRolesUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuariosRolesCreateOrConnectWithoutRolInput | UsuariosRolesCreateOrConnectWithoutRolInput[]
    upsert?: UsuariosRolesUpsertWithWhereUniqueWithoutRolInput | UsuariosRolesUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: UsuariosRolesCreateManyRolInputEnvelope
    set?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    disconnect?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    delete?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    connect?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    update?: UsuariosRolesUpdateWithWhereUniqueWithoutRolInput | UsuariosRolesUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: UsuariosRolesUpdateManyWithWhereWithoutRolInput | UsuariosRolesUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: UsuariosRolesScalarWhereInput | UsuariosRolesScalarWhereInput[]
  }

  export type RolesPermisosCreateNestedManyWithoutPermisoInput = {
    create?: XOR<RolesPermisosCreateWithoutPermisoInput, RolesPermisosUncheckedCreateWithoutPermisoInput> | RolesPermisosCreateWithoutPermisoInput[] | RolesPermisosUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: RolesPermisosCreateOrConnectWithoutPermisoInput | RolesPermisosCreateOrConnectWithoutPermisoInput[]
    createMany?: RolesPermisosCreateManyPermisoInputEnvelope
    connect?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
  }

  export type RolesPermisosUncheckedCreateNestedManyWithoutPermisoInput = {
    create?: XOR<RolesPermisosCreateWithoutPermisoInput, RolesPermisosUncheckedCreateWithoutPermisoInput> | RolesPermisosCreateWithoutPermisoInput[] | RolesPermisosUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: RolesPermisosCreateOrConnectWithoutPermisoInput | RolesPermisosCreateOrConnectWithoutPermisoInput[]
    createMany?: RolesPermisosCreateManyPermisoInputEnvelope
    connect?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
  }

  export type RolesPermisosUpdateManyWithoutPermisoNestedInput = {
    create?: XOR<RolesPermisosCreateWithoutPermisoInput, RolesPermisosUncheckedCreateWithoutPermisoInput> | RolesPermisosCreateWithoutPermisoInput[] | RolesPermisosUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: RolesPermisosCreateOrConnectWithoutPermisoInput | RolesPermisosCreateOrConnectWithoutPermisoInput[]
    upsert?: RolesPermisosUpsertWithWhereUniqueWithoutPermisoInput | RolesPermisosUpsertWithWhereUniqueWithoutPermisoInput[]
    createMany?: RolesPermisosCreateManyPermisoInputEnvelope
    set?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    disconnect?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    delete?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    connect?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    update?: RolesPermisosUpdateWithWhereUniqueWithoutPermisoInput | RolesPermisosUpdateWithWhereUniqueWithoutPermisoInput[]
    updateMany?: RolesPermisosUpdateManyWithWhereWithoutPermisoInput | RolesPermisosUpdateManyWithWhereWithoutPermisoInput[]
    deleteMany?: RolesPermisosScalarWhereInput | RolesPermisosScalarWhereInput[]
  }

  export type RolesPermisosUncheckedUpdateManyWithoutPermisoNestedInput = {
    create?: XOR<RolesPermisosCreateWithoutPermisoInput, RolesPermisosUncheckedCreateWithoutPermisoInput> | RolesPermisosCreateWithoutPermisoInput[] | RolesPermisosUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: RolesPermisosCreateOrConnectWithoutPermisoInput | RolesPermisosCreateOrConnectWithoutPermisoInput[]
    upsert?: RolesPermisosUpsertWithWhereUniqueWithoutPermisoInput | RolesPermisosUpsertWithWhereUniqueWithoutPermisoInput[]
    createMany?: RolesPermisosCreateManyPermisoInputEnvelope
    set?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    disconnect?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    delete?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    connect?: RolesPermisosWhereUniqueInput | RolesPermisosWhereUniqueInput[]
    update?: RolesPermisosUpdateWithWhereUniqueWithoutPermisoInput | RolesPermisosUpdateWithWhereUniqueWithoutPermisoInput[]
    updateMany?: RolesPermisosUpdateManyWithWhereWithoutPermisoInput | RolesPermisosUpdateManyWithWhereWithoutPermisoInput[]
    deleteMany?: RolesPermisosScalarWhereInput | RolesPermisosScalarWhereInput[]
  }

  export type PermisoCreateNestedOneWithoutRolesPermisosInput = {
    create?: XOR<PermisoCreateWithoutRolesPermisosInput, PermisoUncheckedCreateWithoutRolesPermisosInput>
    connectOrCreate?: PermisoCreateOrConnectWithoutRolesPermisosInput
    connect?: PermisoWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutRolesPermisosInput = {
    create?: XOR<RoleCreateWithoutRolesPermisosInput, RoleUncheckedCreateWithoutRolesPermisosInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolesPermisosInput
    connect?: RoleWhereUniqueInput
  }

  export type PermisoUpdateOneRequiredWithoutRolesPermisosNestedInput = {
    create?: XOR<PermisoCreateWithoutRolesPermisosInput, PermisoUncheckedCreateWithoutRolesPermisosInput>
    connectOrCreate?: PermisoCreateOrConnectWithoutRolesPermisosInput
    upsert?: PermisoUpsertWithoutRolesPermisosInput
    connect?: PermisoWhereUniqueInput
    update?: XOR<XOR<PermisoUpdateToOneWithWhereWithoutRolesPermisosInput, PermisoUpdateWithoutRolesPermisosInput>, PermisoUncheckedUpdateWithoutRolesPermisosInput>
  }

  export type RoleUpdateOneRequiredWithoutRolesPermisosNestedInput = {
    create?: XOR<RoleCreateWithoutRolesPermisosInput, RoleUncheckedCreateWithoutRolesPermisosInput>
    connectOrCreate?: RoleCreateOrConnectWithoutRolesPermisosInput
    upsert?: RoleUpsertWithoutRolesPermisosInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutRolesPermisosInput, RoleUpdateWithoutRolesPermisosInput>, RoleUncheckedUpdateWithoutRolesPermisosInput>
  }

  export type SubdivisionCreateNestedManyWithoutCountryInput = {
    create?: XOR<SubdivisionCreateWithoutCountryInput, SubdivisionUncheckedCreateWithoutCountryInput> | SubdivisionCreateWithoutCountryInput[] | SubdivisionUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: SubdivisionCreateOrConnectWithoutCountryInput | SubdivisionCreateOrConnectWithoutCountryInput[]
    createMany?: SubdivisionCreateManyCountryInputEnvelope
    connect?: SubdivisionWhereUniqueInput | SubdivisionWhereUniqueInput[]
  }

  export type SubdivisionUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<SubdivisionCreateWithoutCountryInput, SubdivisionUncheckedCreateWithoutCountryInput> | SubdivisionCreateWithoutCountryInput[] | SubdivisionUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: SubdivisionCreateOrConnectWithoutCountryInput | SubdivisionCreateOrConnectWithoutCountryInput[]
    createMany?: SubdivisionCreateManyCountryInputEnvelope
    connect?: SubdivisionWhereUniqueInput | SubdivisionWhereUniqueInput[]
  }

  export type SubdivisionUpdateManyWithoutCountryNestedInput = {
    create?: XOR<SubdivisionCreateWithoutCountryInput, SubdivisionUncheckedCreateWithoutCountryInput> | SubdivisionCreateWithoutCountryInput[] | SubdivisionUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: SubdivisionCreateOrConnectWithoutCountryInput | SubdivisionCreateOrConnectWithoutCountryInput[]
    upsert?: SubdivisionUpsertWithWhereUniqueWithoutCountryInput | SubdivisionUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: SubdivisionCreateManyCountryInputEnvelope
    set?: SubdivisionWhereUniqueInput | SubdivisionWhereUniqueInput[]
    disconnect?: SubdivisionWhereUniqueInput | SubdivisionWhereUniqueInput[]
    delete?: SubdivisionWhereUniqueInput | SubdivisionWhereUniqueInput[]
    connect?: SubdivisionWhereUniqueInput | SubdivisionWhereUniqueInput[]
    update?: SubdivisionUpdateWithWhereUniqueWithoutCountryInput | SubdivisionUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: SubdivisionUpdateManyWithWhereWithoutCountryInput | SubdivisionUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: SubdivisionScalarWhereInput | SubdivisionScalarWhereInput[]
  }

  export type SubdivisionUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<SubdivisionCreateWithoutCountryInput, SubdivisionUncheckedCreateWithoutCountryInput> | SubdivisionCreateWithoutCountryInput[] | SubdivisionUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: SubdivisionCreateOrConnectWithoutCountryInput | SubdivisionCreateOrConnectWithoutCountryInput[]
    upsert?: SubdivisionUpsertWithWhereUniqueWithoutCountryInput | SubdivisionUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: SubdivisionCreateManyCountryInputEnvelope
    set?: SubdivisionWhereUniqueInput | SubdivisionWhereUniqueInput[]
    disconnect?: SubdivisionWhereUniqueInput | SubdivisionWhereUniqueInput[]
    delete?: SubdivisionWhereUniqueInput | SubdivisionWhereUniqueInput[]
    connect?: SubdivisionWhereUniqueInput | SubdivisionWhereUniqueInput[]
    update?: SubdivisionUpdateWithWhereUniqueWithoutCountryInput | SubdivisionUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: SubdivisionUpdateManyWithWhereWithoutCountryInput | SubdivisionUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: SubdivisionScalarWhereInput | SubdivisionScalarWhereInput[]
  }

  export type EmprendimientoCreateNestedManyWithoutSubdivisionInput = {
    create?: XOR<EmprendimientoCreateWithoutSubdivisionInput, EmprendimientoUncheckedCreateWithoutSubdivisionInput> | EmprendimientoCreateWithoutSubdivisionInput[] | EmprendimientoUncheckedCreateWithoutSubdivisionInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutSubdivisionInput | EmprendimientoCreateOrConnectWithoutSubdivisionInput[]
    createMany?: EmprendimientoCreateManySubdivisionInputEnvelope
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
  }

  export type PersonaCreateNestedManyWithoutSubdivisionInput = {
    create?: XOR<PersonaCreateWithoutSubdivisionInput, PersonaUncheckedCreateWithoutSubdivisionInput> | PersonaCreateWithoutSubdivisionInput[] | PersonaUncheckedCreateWithoutSubdivisionInput[]
    connectOrCreate?: PersonaCreateOrConnectWithoutSubdivisionInput | PersonaCreateOrConnectWithoutSubdivisionInput[]
    createMany?: PersonaCreateManySubdivisionInputEnvelope
    connect?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
  }

  export type CountryCreateNestedOneWithoutSubdivisionsInput = {
    create?: XOR<CountryCreateWithoutSubdivisionsInput, CountryUncheckedCreateWithoutSubdivisionsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutSubdivisionsInput
    connect?: CountryWhereUniqueInput
  }

  export type EmprendimientoUncheckedCreateNestedManyWithoutSubdivisionInput = {
    create?: XOR<EmprendimientoCreateWithoutSubdivisionInput, EmprendimientoUncheckedCreateWithoutSubdivisionInput> | EmprendimientoCreateWithoutSubdivisionInput[] | EmprendimientoUncheckedCreateWithoutSubdivisionInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutSubdivisionInput | EmprendimientoCreateOrConnectWithoutSubdivisionInput[]
    createMany?: EmprendimientoCreateManySubdivisionInputEnvelope
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
  }

  export type PersonaUncheckedCreateNestedManyWithoutSubdivisionInput = {
    create?: XOR<PersonaCreateWithoutSubdivisionInput, PersonaUncheckedCreateWithoutSubdivisionInput> | PersonaCreateWithoutSubdivisionInput[] | PersonaUncheckedCreateWithoutSubdivisionInput[]
    connectOrCreate?: PersonaCreateOrConnectWithoutSubdivisionInput | PersonaCreateOrConnectWithoutSubdivisionInput[]
    createMany?: PersonaCreateManySubdivisionInputEnvelope
    connect?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
  }

  export type EmprendimientoUpdateManyWithoutSubdivisionNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutSubdivisionInput, EmprendimientoUncheckedCreateWithoutSubdivisionInput> | EmprendimientoCreateWithoutSubdivisionInput[] | EmprendimientoUncheckedCreateWithoutSubdivisionInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutSubdivisionInput | EmprendimientoCreateOrConnectWithoutSubdivisionInput[]
    upsert?: EmprendimientoUpsertWithWhereUniqueWithoutSubdivisionInput | EmprendimientoUpsertWithWhereUniqueWithoutSubdivisionInput[]
    createMany?: EmprendimientoCreateManySubdivisionInputEnvelope
    set?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    disconnect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    delete?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    update?: EmprendimientoUpdateWithWhereUniqueWithoutSubdivisionInput | EmprendimientoUpdateWithWhereUniqueWithoutSubdivisionInput[]
    updateMany?: EmprendimientoUpdateManyWithWhereWithoutSubdivisionInput | EmprendimientoUpdateManyWithWhereWithoutSubdivisionInput[]
    deleteMany?: EmprendimientoScalarWhereInput | EmprendimientoScalarWhereInput[]
  }

  export type PersonaUpdateManyWithoutSubdivisionNestedInput = {
    create?: XOR<PersonaCreateWithoutSubdivisionInput, PersonaUncheckedCreateWithoutSubdivisionInput> | PersonaCreateWithoutSubdivisionInput[] | PersonaUncheckedCreateWithoutSubdivisionInput[]
    connectOrCreate?: PersonaCreateOrConnectWithoutSubdivisionInput | PersonaCreateOrConnectWithoutSubdivisionInput[]
    upsert?: PersonaUpsertWithWhereUniqueWithoutSubdivisionInput | PersonaUpsertWithWhereUniqueWithoutSubdivisionInput[]
    createMany?: PersonaCreateManySubdivisionInputEnvelope
    set?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    disconnect?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    delete?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    connect?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    update?: PersonaUpdateWithWhereUniqueWithoutSubdivisionInput | PersonaUpdateWithWhereUniqueWithoutSubdivisionInput[]
    updateMany?: PersonaUpdateManyWithWhereWithoutSubdivisionInput | PersonaUpdateManyWithWhereWithoutSubdivisionInput[]
    deleteMany?: PersonaScalarWhereInput | PersonaScalarWhereInput[]
  }

  export type CountryUpdateOneRequiredWithoutSubdivisionsNestedInput = {
    create?: XOR<CountryCreateWithoutSubdivisionsInput, CountryUncheckedCreateWithoutSubdivisionsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutSubdivisionsInput
    upsert?: CountryUpsertWithoutSubdivisionsInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutSubdivisionsInput, CountryUpdateWithoutSubdivisionsInput>, CountryUncheckedUpdateWithoutSubdivisionsInput>
  }

  export type EmprendimientoUncheckedUpdateManyWithoutSubdivisionNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutSubdivisionInput, EmprendimientoUncheckedCreateWithoutSubdivisionInput> | EmprendimientoCreateWithoutSubdivisionInput[] | EmprendimientoUncheckedCreateWithoutSubdivisionInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutSubdivisionInput | EmprendimientoCreateOrConnectWithoutSubdivisionInput[]
    upsert?: EmprendimientoUpsertWithWhereUniqueWithoutSubdivisionInput | EmprendimientoUpsertWithWhereUniqueWithoutSubdivisionInput[]
    createMany?: EmprendimientoCreateManySubdivisionInputEnvelope
    set?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    disconnect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    delete?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    update?: EmprendimientoUpdateWithWhereUniqueWithoutSubdivisionInput | EmprendimientoUpdateWithWhereUniqueWithoutSubdivisionInput[]
    updateMany?: EmprendimientoUpdateManyWithWhereWithoutSubdivisionInput | EmprendimientoUpdateManyWithWhereWithoutSubdivisionInput[]
    deleteMany?: EmprendimientoScalarWhereInput | EmprendimientoScalarWhereInput[]
  }

  export type PersonaUncheckedUpdateManyWithoutSubdivisionNestedInput = {
    create?: XOR<PersonaCreateWithoutSubdivisionInput, PersonaUncheckedCreateWithoutSubdivisionInput> | PersonaCreateWithoutSubdivisionInput[] | PersonaUncheckedCreateWithoutSubdivisionInput[]
    connectOrCreate?: PersonaCreateOrConnectWithoutSubdivisionInput | PersonaCreateOrConnectWithoutSubdivisionInput[]
    upsert?: PersonaUpsertWithWhereUniqueWithoutSubdivisionInput | PersonaUpsertWithWhereUniqueWithoutSubdivisionInput[]
    createMany?: PersonaCreateManySubdivisionInputEnvelope
    set?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    disconnect?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    delete?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    connect?: PersonaWhereUniqueInput | PersonaWhereUniqueInput[]
    update?: PersonaUpdateWithWhereUniqueWithoutSubdivisionInput | PersonaUpdateWithWhereUniqueWithoutSubdivisionInput[]
    updateMany?: PersonaUpdateManyWithWhereWithoutSubdivisionInput | PersonaUpdateManyWithWhereWithoutSubdivisionInput[]
    deleteMany?: PersonaScalarWhereInput | PersonaScalarWhereInput[]
  }

  export type SubdivisionCreateNestedOneWithoutPersonasInput = {
    create?: XOR<SubdivisionCreateWithoutPersonasInput, SubdivisionUncheckedCreateWithoutPersonasInput>
    connectOrCreate?: SubdivisionCreateOrConnectWithoutPersonasInput
    connect?: SubdivisionWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutPersonaInput = {
    create?: XOR<UsuarioCreateWithoutPersonaInput, UsuarioUncheckedCreateWithoutPersonaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPersonaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUncheckedCreateNestedOneWithoutPersonaInput = {
    create?: XOR<UsuarioCreateWithoutPersonaInput, UsuarioUncheckedCreateWithoutPersonaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPersonaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type SubdivisionUpdateOneRequiredWithoutPersonasNestedInput = {
    create?: XOR<SubdivisionCreateWithoutPersonasInput, SubdivisionUncheckedCreateWithoutPersonasInput>
    connectOrCreate?: SubdivisionCreateOrConnectWithoutPersonasInput
    upsert?: SubdivisionUpsertWithoutPersonasInput
    connect?: SubdivisionWhereUniqueInput
    update?: XOR<XOR<SubdivisionUpdateToOneWithWhereWithoutPersonasInput, SubdivisionUpdateWithoutPersonasInput>, SubdivisionUncheckedUpdateWithoutPersonasInput>
  }

  export type UsuarioUpdateOneWithoutPersonaNestedInput = {
    create?: XOR<UsuarioCreateWithoutPersonaInput, UsuarioUncheckedCreateWithoutPersonaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPersonaInput
    upsert?: UsuarioUpsertWithoutPersonaInput
    disconnect?: UsuarioWhereInput | boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPersonaInput, UsuarioUpdateWithoutPersonaInput>, UsuarioUncheckedUpdateWithoutPersonaInput>
  }

  export type UsuarioUncheckedUpdateOneWithoutPersonaNestedInput = {
    create?: XOR<UsuarioCreateWithoutPersonaInput, UsuarioUncheckedCreateWithoutPersonaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPersonaInput
    upsert?: UsuarioUpsertWithoutPersonaInput
    disconnect?: UsuarioWhereInput | boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPersonaInput, UsuarioUpdateWithoutPersonaInput>, UsuarioUncheckedUpdateWithoutPersonaInput>
  }

  export type EmprendimientoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EmprendimientoCreateWithoutUsuarioInput, EmprendimientoUncheckedCreateWithoutUsuarioInput> | EmprendimientoCreateWithoutUsuarioInput[] | EmprendimientoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutUsuarioInput | EmprendimientoCreateOrConnectWithoutUsuarioInput[]
    createMany?: EmprendimientoCreateManyUsuarioInputEnvelope
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
  }

  export type FavoritoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<FavoritoCreateWithoutUsuarioInput, FavoritoUncheckedCreateWithoutUsuarioInput> | FavoritoCreateWithoutUsuarioInput[] | FavoritoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutUsuarioInput | FavoritoCreateOrConnectWithoutUsuarioInput[]
    createMany?: FavoritoCreateManyUsuarioInputEnvelope
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
  }

  export type RegistroAccesoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<RegistroAccesoCreateWithoutUsuarioInput, RegistroAccesoUncheckedCreateWithoutUsuarioInput> | RegistroAccesoCreateWithoutUsuarioInput[] | RegistroAccesoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RegistroAccesoCreateOrConnectWithoutUsuarioInput | RegistroAccesoCreateOrConnectWithoutUsuarioInput[]
    createMany?: RegistroAccesoCreateManyUsuarioInputEnvelope
    connect?: RegistroAccesoWhereUniqueInput | RegistroAccesoWhereUniqueInput[]
  }

  export type ResenaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput> | ResenaCreateWithoutUsuarioInput[] | ResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutUsuarioInput | ResenaCreateOrConnectWithoutUsuarioInput[]
    createMany?: ResenaCreateManyUsuarioInputEnvelope
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
  }

  export type TokenInvalidadoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<TokenInvalidadoCreateWithoutUsuarioInput, TokenInvalidadoUncheckedCreateWithoutUsuarioInput> | TokenInvalidadoCreateWithoutUsuarioInput[] | TokenInvalidadoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TokenInvalidadoCreateOrConnectWithoutUsuarioInput | TokenInvalidadoCreateOrConnectWithoutUsuarioInput[]
    createMany?: TokenInvalidadoCreateManyUsuarioInputEnvelope
    connect?: TokenInvalidadoWhereUniqueInput | TokenInvalidadoWhereUniqueInput[]
  }

  export type PersonaCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<PersonaCreateWithoutUsuarioInput, PersonaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: PersonaCreateOrConnectWithoutUsuarioInput
    connect?: PersonaWhereUniqueInput
  }

  export type UsuariosRolesCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<UsuariosRolesCreateWithoutUsuarioInput, UsuariosRolesUncheckedCreateWithoutUsuarioInput> | UsuariosRolesCreateWithoutUsuarioInput[] | UsuariosRolesUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuariosRolesCreateOrConnectWithoutUsuarioInput | UsuariosRolesCreateOrConnectWithoutUsuarioInput[]
    createMany?: UsuariosRolesCreateManyUsuarioInputEnvelope
    connect?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
  }

  export type EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EmprendimientoCreateWithoutUsuarioInput, EmprendimientoUncheckedCreateWithoutUsuarioInput> | EmprendimientoCreateWithoutUsuarioInput[] | EmprendimientoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutUsuarioInput | EmprendimientoCreateOrConnectWithoutUsuarioInput[]
    createMany?: EmprendimientoCreateManyUsuarioInputEnvelope
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
  }

  export type FavoritoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<FavoritoCreateWithoutUsuarioInput, FavoritoUncheckedCreateWithoutUsuarioInput> | FavoritoCreateWithoutUsuarioInput[] | FavoritoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutUsuarioInput | FavoritoCreateOrConnectWithoutUsuarioInput[]
    createMany?: FavoritoCreateManyUsuarioInputEnvelope
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
  }

  export type RegistroAccesoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<RegistroAccesoCreateWithoutUsuarioInput, RegistroAccesoUncheckedCreateWithoutUsuarioInput> | RegistroAccesoCreateWithoutUsuarioInput[] | RegistroAccesoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RegistroAccesoCreateOrConnectWithoutUsuarioInput | RegistroAccesoCreateOrConnectWithoutUsuarioInput[]
    createMany?: RegistroAccesoCreateManyUsuarioInputEnvelope
    connect?: RegistroAccesoWhereUniqueInput | RegistroAccesoWhereUniqueInput[]
  }

  export type ResenaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput> | ResenaCreateWithoutUsuarioInput[] | ResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutUsuarioInput | ResenaCreateOrConnectWithoutUsuarioInput[]
    createMany?: ResenaCreateManyUsuarioInputEnvelope
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
  }

  export type TokenInvalidadoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<TokenInvalidadoCreateWithoutUsuarioInput, TokenInvalidadoUncheckedCreateWithoutUsuarioInput> | TokenInvalidadoCreateWithoutUsuarioInput[] | TokenInvalidadoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TokenInvalidadoCreateOrConnectWithoutUsuarioInput | TokenInvalidadoCreateOrConnectWithoutUsuarioInput[]
    createMany?: TokenInvalidadoCreateManyUsuarioInputEnvelope
    connect?: TokenInvalidadoWhereUniqueInput | TokenInvalidadoWhereUniqueInput[]
  }

  export type UsuariosRolesUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<UsuariosRolesCreateWithoutUsuarioInput, UsuariosRolesUncheckedCreateWithoutUsuarioInput> | UsuariosRolesCreateWithoutUsuarioInput[] | UsuariosRolesUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuariosRolesCreateOrConnectWithoutUsuarioInput | UsuariosRolesCreateOrConnectWithoutUsuarioInput[]
    createMany?: UsuariosRolesCreateManyUsuarioInputEnvelope
    connect?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EmprendimientoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutUsuarioInput, EmprendimientoUncheckedCreateWithoutUsuarioInput> | EmprendimientoCreateWithoutUsuarioInput[] | EmprendimientoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutUsuarioInput | EmprendimientoCreateOrConnectWithoutUsuarioInput[]
    upsert?: EmprendimientoUpsertWithWhereUniqueWithoutUsuarioInput | EmprendimientoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EmprendimientoCreateManyUsuarioInputEnvelope
    set?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    disconnect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    delete?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    update?: EmprendimientoUpdateWithWhereUniqueWithoutUsuarioInput | EmprendimientoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EmprendimientoUpdateManyWithWhereWithoutUsuarioInput | EmprendimientoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EmprendimientoScalarWhereInput | EmprendimientoScalarWhereInput[]
  }

  export type FavoritoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<FavoritoCreateWithoutUsuarioInput, FavoritoUncheckedCreateWithoutUsuarioInput> | FavoritoCreateWithoutUsuarioInput[] | FavoritoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutUsuarioInput | FavoritoCreateOrConnectWithoutUsuarioInput[]
    upsert?: FavoritoUpsertWithWhereUniqueWithoutUsuarioInput | FavoritoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: FavoritoCreateManyUsuarioInputEnvelope
    set?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    disconnect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    delete?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    update?: FavoritoUpdateWithWhereUniqueWithoutUsuarioInput | FavoritoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: FavoritoUpdateManyWithWhereWithoutUsuarioInput | FavoritoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[]
  }

  export type RegistroAccesoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<RegistroAccesoCreateWithoutUsuarioInput, RegistroAccesoUncheckedCreateWithoutUsuarioInput> | RegistroAccesoCreateWithoutUsuarioInput[] | RegistroAccesoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RegistroAccesoCreateOrConnectWithoutUsuarioInput | RegistroAccesoCreateOrConnectWithoutUsuarioInput[]
    upsert?: RegistroAccesoUpsertWithWhereUniqueWithoutUsuarioInput | RegistroAccesoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: RegistroAccesoCreateManyUsuarioInputEnvelope
    set?: RegistroAccesoWhereUniqueInput | RegistroAccesoWhereUniqueInput[]
    disconnect?: RegistroAccesoWhereUniqueInput | RegistroAccesoWhereUniqueInput[]
    delete?: RegistroAccesoWhereUniqueInput | RegistroAccesoWhereUniqueInput[]
    connect?: RegistroAccesoWhereUniqueInput | RegistroAccesoWhereUniqueInput[]
    update?: RegistroAccesoUpdateWithWhereUniqueWithoutUsuarioInput | RegistroAccesoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: RegistroAccesoUpdateManyWithWhereWithoutUsuarioInput | RegistroAccesoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: RegistroAccesoScalarWhereInput | RegistroAccesoScalarWhereInput[]
  }

  export type ResenaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput> | ResenaCreateWithoutUsuarioInput[] | ResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutUsuarioInput | ResenaCreateOrConnectWithoutUsuarioInput[]
    upsert?: ResenaUpsertWithWhereUniqueWithoutUsuarioInput | ResenaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ResenaCreateManyUsuarioInputEnvelope
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    update?: ResenaUpdateWithWhereUniqueWithoutUsuarioInput | ResenaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ResenaUpdateManyWithWhereWithoutUsuarioInput | ResenaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
  }

  export type TokenInvalidadoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<TokenInvalidadoCreateWithoutUsuarioInput, TokenInvalidadoUncheckedCreateWithoutUsuarioInput> | TokenInvalidadoCreateWithoutUsuarioInput[] | TokenInvalidadoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TokenInvalidadoCreateOrConnectWithoutUsuarioInput | TokenInvalidadoCreateOrConnectWithoutUsuarioInput[]
    upsert?: TokenInvalidadoUpsertWithWhereUniqueWithoutUsuarioInput | TokenInvalidadoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: TokenInvalidadoCreateManyUsuarioInputEnvelope
    set?: TokenInvalidadoWhereUniqueInput | TokenInvalidadoWhereUniqueInput[]
    disconnect?: TokenInvalidadoWhereUniqueInput | TokenInvalidadoWhereUniqueInput[]
    delete?: TokenInvalidadoWhereUniqueInput | TokenInvalidadoWhereUniqueInput[]
    connect?: TokenInvalidadoWhereUniqueInput | TokenInvalidadoWhereUniqueInput[]
    update?: TokenInvalidadoUpdateWithWhereUniqueWithoutUsuarioInput | TokenInvalidadoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: TokenInvalidadoUpdateManyWithWhereWithoutUsuarioInput | TokenInvalidadoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: TokenInvalidadoScalarWhereInput | TokenInvalidadoScalarWhereInput[]
  }

  export type PersonaUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<PersonaCreateWithoutUsuarioInput, PersonaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: PersonaCreateOrConnectWithoutUsuarioInput
    upsert?: PersonaUpsertWithoutUsuarioInput
    connect?: PersonaWhereUniqueInput
    update?: XOR<XOR<PersonaUpdateToOneWithWhereWithoutUsuarioInput, PersonaUpdateWithoutUsuarioInput>, PersonaUncheckedUpdateWithoutUsuarioInput>
  }

  export type UsuariosRolesUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<UsuariosRolesCreateWithoutUsuarioInput, UsuariosRolesUncheckedCreateWithoutUsuarioInput> | UsuariosRolesCreateWithoutUsuarioInput[] | UsuariosRolesUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuariosRolesCreateOrConnectWithoutUsuarioInput | UsuariosRolesCreateOrConnectWithoutUsuarioInput[]
    upsert?: UsuariosRolesUpsertWithWhereUniqueWithoutUsuarioInput | UsuariosRolesUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: UsuariosRolesCreateManyUsuarioInputEnvelope
    set?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    disconnect?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    delete?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    connect?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    update?: UsuariosRolesUpdateWithWhereUniqueWithoutUsuarioInput | UsuariosRolesUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: UsuariosRolesUpdateManyWithWhereWithoutUsuarioInput | UsuariosRolesUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: UsuariosRolesScalarWhereInput | UsuariosRolesScalarWhereInput[]
  }

  export type EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutUsuarioInput, EmprendimientoUncheckedCreateWithoutUsuarioInput> | EmprendimientoCreateWithoutUsuarioInput[] | EmprendimientoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutUsuarioInput | EmprendimientoCreateOrConnectWithoutUsuarioInput[]
    upsert?: EmprendimientoUpsertWithWhereUniqueWithoutUsuarioInput | EmprendimientoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EmprendimientoCreateManyUsuarioInputEnvelope
    set?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    disconnect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    delete?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    update?: EmprendimientoUpdateWithWhereUniqueWithoutUsuarioInput | EmprendimientoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EmprendimientoUpdateManyWithWhereWithoutUsuarioInput | EmprendimientoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EmprendimientoScalarWhereInput | EmprendimientoScalarWhereInput[]
  }

  export type FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<FavoritoCreateWithoutUsuarioInput, FavoritoUncheckedCreateWithoutUsuarioInput> | FavoritoCreateWithoutUsuarioInput[] | FavoritoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutUsuarioInput | FavoritoCreateOrConnectWithoutUsuarioInput[]
    upsert?: FavoritoUpsertWithWhereUniqueWithoutUsuarioInput | FavoritoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: FavoritoCreateManyUsuarioInputEnvelope
    set?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    disconnect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    delete?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    update?: FavoritoUpdateWithWhereUniqueWithoutUsuarioInput | FavoritoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: FavoritoUpdateManyWithWhereWithoutUsuarioInput | FavoritoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[]
  }

  export type RegistroAccesoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<RegistroAccesoCreateWithoutUsuarioInput, RegistroAccesoUncheckedCreateWithoutUsuarioInput> | RegistroAccesoCreateWithoutUsuarioInput[] | RegistroAccesoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: RegistroAccesoCreateOrConnectWithoutUsuarioInput | RegistroAccesoCreateOrConnectWithoutUsuarioInput[]
    upsert?: RegistroAccesoUpsertWithWhereUniqueWithoutUsuarioInput | RegistroAccesoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: RegistroAccesoCreateManyUsuarioInputEnvelope
    set?: RegistroAccesoWhereUniqueInput | RegistroAccesoWhereUniqueInput[]
    disconnect?: RegistroAccesoWhereUniqueInput | RegistroAccesoWhereUniqueInput[]
    delete?: RegistroAccesoWhereUniqueInput | RegistroAccesoWhereUniqueInput[]
    connect?: RegistroAccesoWhereUniqueInput | RegistroAccesoWhereUniqueInput[]
    update?: RegistroAccesoUpdateWithWhereUniqueWithoutUsuarioInput | RegistroAccesoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: RegistroAccesoUpdateManyWithWhereWithoutUsuarioInput | RegistroAccesoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: RegistroAccesoScalarWhereInput | RegistroAccesoScalarWhereInput[]
  }

  export type ResenaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput> | ResenaCreateWithoutUsuarioInput[] | ResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutUsuarioInput | ResenaCreateOrConnectWithoutUsuarioInput[]
    upsert?: ResenaUpsertWithWhereUniqueWithoutUsuarioInput | ResenaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ResenaCreateManyUsuarioInputEnvelope
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    update?: ResenaUpdateWithWhereUniqueWithoutUsuarioInput | ResenaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ResenaUpdateManyWithWhereWithoutUsuarioInput | ResenaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
  }

  export type TokenInvalidadoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<TokenInvalidadoCreateWithoutUsuarioInput, TokenInvalidadoUncheckedCreateWithoutUsuarioInput> | TokenInvalidadoCreateWithoutUsuarioInput[] | TokenInvalidadoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TokenInvalidadoCreateOrConnectWithoutUsuarioInput | TokenInvalidadoCreateOrConnectWithoutUsuarioInput[]
    upsert?: TokenInvalidadoUpsertWithWhereUniqueWithoutUsuarioInput | TokenInvalidadoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: TokenInvalidadoCreateManyUsuarioInputEnvelope
    set?: TokenInvalidadoWhereUniqueInput | TokenInvalidadoWhereUniqueInput[]
    disconnect?: TokenInvalidadoWhereUniqueInput | TokenInvalidadoWhereUniqueInput[]
    delete?: TokenInvalidadoWhereUniqueInput | TokenInvalidadoWhereUniqueInput[]
    connect?: TokenInvalidadoWhereUniqueInput | TokenInvalidadoWhereUniqueInput[]
    update?: TokenInvalidadoUpdateWithWhereUniqueWithoutUsuarioInput | TokenInvalidadoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: TokenInvalidadoUpdateManyWithWhereWithoutUsuarioInput | TokenInvalidadoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: TokenInvalidadoScalarWhereInput | TokenInvalidadoScalarWhereInput[]
  }

  export type UsuariosRolesUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<UsuariosRolesCreateWithoutUsuarioInput, UsuariosRolesUncheckedCreateWithoutUsuarioInput> | UsuariosRolesCreateWithoutUsuarioInput[] | UsuariosRolesUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuariosRolesCreateOrConnectWithoutUsuarioInput | UsuariosRolesCreateOrConnectWithoutUsuarioInput[]
    upsert?: UsuariosRolesUpsertWithWhereUniqueWithoutUsuarioInput | UsuariosRolesUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: UsuariosRolesCreateManyUsuarioInputEnvelope
    set?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    disconnect?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    delete?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    connect?: UsuariosRolesWhereUniqueInput | UsuariosRolesWhereUniqueInput[]
    update?: UsuariosRolesUpdateWithWhereUniqueWithoutUsuarioInput | UsuariosRolesUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: UsuariosRolesUpdateManyWithWhereWithoutUsuarioInput | UsuariosRolesUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: UsuariosRolesScalarWhereInput | UsuariosRolesScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutUsuariosRolesInput = {
    create?: XOR<RoleCreateWithoutUsuariosRolesInput, RoleUncheckedCreateWithoutUsuariosRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsuariosRolesInput
    connect?: RoleWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutUsuariosRolesInput = {
    create?: XOR<UsuarioCreateWithoutUsuariosRolesInput, UsuarioUncheckedCreateWithoutUsuariosRolesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutUsuariosRolesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutUsuariosRolesNestedInput = {
    create?: XOR<RoleCreateWithoutUsuariosRolesInput, RoleUncheckedCreateWithoutUsuariosRolesInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsuariosRolesInput
    upsert?: RoleUpsertWithoutUsuariosRolesInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsuariosRolesInput, RoleUpdateWithoutUsuariosRolesInput>, RoleUncheckedUpdateWithoutUsuariosRolesInput>
  }

  export type UsuarioUpdateOneRequiredWithoutUsuariosRolesNestedInput = {
    create?: XOR<UsuarioCreateWithoutUsuariosRolesInput, UsuarioUncheckedCreateWithoutUsuariosRolesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutUsuariosRolesInput
    upsert?: UsuarioUpsertWithoutUsuariosRolesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutUsuariosRolesInput, UsuarioUpdateWithoutUsuariosRolesInput>, UsuarioUncheckedUpdateWithoutUsuariosRolesInput>
  }

  export type SubdivisionCreateNestedOneWithoutEmprendimientosInput = {
    create?: XOR<SubdivisionCreateWithoutEmprendimientosInput, SubdivisionUncheckedCreateWithoutEmprendimientosInput>
    connectOrCreate?: SubdivisionCreateOrConnectWithoutEmprendimientosInput
    connect?: SubdivisionWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutEmprendimientosInput = {
    create?: XOR<UsuarioCreateWithoutEmprendimientosInput, UsuarioUncheckedCreateWithoutEmprendimientosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEmprendimientosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type FavoritoCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<FavoritoCreateWithoutEmprendimientoInput, FavoritoUncheckedCreateWithoutEmprendimientoInput> | FavoritoCreateWithoutEmprendimientoInput[] | FavoritoUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutEmprendimientoInput | FavoritoCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: FavoritoCreateManyEmprendimientoInputEnvelope
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
  }

  export type PaqueteTuristicoCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<PaqueteTuristicoCreateWithoutEmprendimientoInput, PaqueteTuristicoUncheckedCreateWithoutEmprendimientoInput> | PaqueteTuristicoCreateWithoutEmprendimientoInput[] | PaqueteTuristicoUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: PaqueteTuristicoCreateOrConnectWithoutEmprendimientoInput | PaqueteTuristicoCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: PaqueteTuristicoCreateManyEmprendimientoInputEnvelope
    connect?: PaqueteTuristicoWhereUniqueInput | PaqueteTuristicoWhereUniqueInput[]
  }

  export type ServicioEmprendedorCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<ServicioEmprendedorCreateWithoutEmprendimientoInput, ServicioEmprendedorUncheckedCreateWithoutEmprendimientoInput> | ServicioEmprendedorCreateWithoutEmprendimientoInput[] | ServicioEmprendedorUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: ServicioEmprendedorCreateOrConnectWithoutEmprendimientoInput | ServicioEmprendedorCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: ServicioEmprendedorCreateManyEmprendimientoInputEnvelope
    connect?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
  }

  export type FavoritoUncheckedCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<FavoritoCreateWithoutEmprendimientoInput, FavoritoUncheckedCreateWithoutEmprendimientoInput> | FavoritoCreateWithoutEmprendimientoInput[] | FavoritoUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutEmprendimientoInput | FavoritoCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: FavoritoCreateManyEmprendimientoInputEnvelope
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
  }

  export type PaqueteTuristicoUncheckedCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<PaqueteTuristicoCreateWithoutEmprendimientoInput, PaqueteTuristicoUncheckedCreateWithoutEmprendimientoInput> | PaqueteTuristicoCreateWithoutEmprendimientoInput[] | PaqueteTuristicoUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: PaqueteTuristicoCreateOrConnectWithoutEmprendimientoInput | PaqueteTuristicoCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: PaqueteTuristicoCreateManyEmprendimientoInputEnvelope
    connect?: PaqueteTuristicoWhereUniqueInput | PaqueteTuristicoWhereUniqueInput[]
  }

  export type ServicioEmprendedorUncheckedCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<ServicioEmprendedorCreateWithoutEmprendimientoInput, ServicioEmprendedorUncheckedCreateWithoutEmprendimientoInput> | ServicioEmprendedorCreateWithoutEmprendimientoInput[] | ServicioEmprendedorUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: ServicioEmprendedorCreateOrConnectWithoutEmprendimientoInput | ServicioEmprendedorCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: ServicioEmprendedorCreateManyEmprendimientoInputEnvelope
    connect?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
  }

  export type SubdivisionUpdateOneWithoutEmprendimientosNestedInput = {
    create?: XOR<SubdivisionCreateWithoutEmprendimientosInput, SubdivisionUncheckedCreateWithoutEmprendimientosInput>
    connectOrCreate?: SubdivisionCreateOrConnectWithoutEmprendimientosInput
    upsert?: SubdivisionUpsertWithoutEmprendimientosInput
    disconnect?: SubdivisionWhereInput | boolean
    delete?: SubdivisionWhereInput | boolean
    connect?: SubdivisionWhereUniqueInput
    update?: XOR<XOR<SubdivisionUpdateToOneWithWhereWithoutEmprendimientosInput, SubdivisionUpdateWithoutEmprendimientosInput>, SubdivisionUncheckedUpdateWithoutEmprendimientosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput = {
    create?: XOR<UsuarioCreateWithoutEmprendimientosInput, UsuarioUncheckedCreateWithoutEmprendimientosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEmprendimientosInput
    upsert?: UsuarioUpsertWithoutEmprendimientosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEmprendimientosInput, UsuarioUpdateWithoutEmprendimientosInput>, UsuarioUncheckedUpdateWithoutEmprendimientosInput>
  }

  export type FavoritoUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<FavoritoCreateWithoutEmprendimientoInput, FavoritoUncheckedCreateWithoutEmprendimientoInput> | FavoritoCreateWithoutEmprendimientoInput[] | FavoritoUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutEmprendimientoInput | FavoritoCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: FavoritoUpsertWithWhereUniqueWithoutEmprendimientoInput | FavoritoUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: FavoritoCreateManyEmprendimientoInputEnvelope
    set?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    disconnect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    delete?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    update?: FavoritoUpdateWithWhereUniqueWithoutEmprendimientoInput | FavoritoUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: FavoritoUpdateManyWithWhereWithoutEmprendimientoInput | FavoritoUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[]
  }

  export type PaqueteTuristicoUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<PaqueteTuristicoCreateWithoutEmprendimientoInput, PaqueteTuristicoUncheckedCreateWithoutEmprendimientoInput> | PaqueteTuristicoCreateWithoutEmprendimientoInput[] | PaqueteTuristicoUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: PaqueteTuristicoCreateOrConnectWithoutEmprendimientoInput | PaqueteTuristicoCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: PaqueteTuristicoUpsertWithWhereUniqueWithoutEmprendimientoInput | PaqueteTuristicoUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: PaqueteTuristicoCreateManyEmprendimientoInputEnvelope
    set?: PaqueteTuristicoWhereUniqueInput | PaqueteTuristicoWhereUniqueInput[]
    disconnect?: PaqueteTuristicoWhereUniqueInput | PaqueteTuristicoWhereUniqueInput[]
    delete?: PaqueteTuristicoWhereUniqueInput | PaqueteTuristicoWhereUniqueInput[]
    connect?: PaqueteTuristicoWhereUniqueInput | PaqueteTuristicoWhereUniqueInput[]
    update?: PaqueteTuristicoUpdateWithWhereUniqueWithoutEmprendimientoInput | PaqueteTuristicoUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: PaqueteTuristicoUpdateManyWithWhereWithoutEmprendimientoInput | PaqueteTuristicoUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: PaqueteTuristicoScalarWhereInput | PaqueteTuristicoScalarWhereInput[]
  }

  export type ServicioEmprendedorUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<ServicioEmprendedorCreateWithoutEmprendimientoInput, ServicioEmprendedorUncheckedCreateWithoutEmprendimientoInput> | ServicioEmprendedorCreateWithoutEmprendimientoInput[] | ServicioEmprendedorUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: ServicioEmprendedorCreateOrConnectWithoutEmprendimientoInput | ServicioEmprendedorCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: ServicioEmprendedorUpsertWithWhereUniqueWithoutEmprendimientoInput | ServicioEmprendedorUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: ServicioEmprendedorCreateManyEmprendimientoInputEnvelope
    set?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    disconnect?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    delete?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    connect?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    update?: ServicioEmprendedorUpdateWithWhereUniqueWithoutEmprendimientoInput | ServicioEmprendedorUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: ServicioEmprendedorUpdateManyWithWhereWithoutEmprendimientoInput | ServicioEmprendedorUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: ServicioEmprendedorScalarWhereInput | ServicioEmprendedorScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FavoritoUncheckedUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<FavoritoCreateWithoutEmprendimientoInput, FavoritoUncheckedCreateWithoutEmprendimientoInput> | FavoritoCreateWithoutEmprendimientoInput[] | FavoritoUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: FavoritoCreateOrConnectWithoutEmprendimientoInput | FavoritoCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: FavoritoUpsertWithWhereUniqueWithoutEmprendimientoInput | FavoritoUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: FavoritoCreateManyEmprendimientoInputEnvelope
    set?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    disconnect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    delete?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    connect?: FavoritoWhereUniqueInput | FavoritoWhereUniqueInput[]
    update?: FavoritoUpdateWithWhereUniqueWithoutEmprendimientoInput | FavoritoUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: FavoritoUpdateManyWithWhereWithoutEmprendimientoInput | FavoritoUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[]
  }

  export type PaqueteTuristicoUncheckedUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<PaqueteTuristicoCreateWithoutEmprendimientoInput, PaqueteTuristicoUncheckedCreateWithoutEmprendimientoInput> | PaqueteTuristicoCreateWithoutEmprendimientoInput[] | PaqueteTuristicoUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: PaqueteTuristicoCreateOrConnectWithoutEmprendimientoInput | PaqueteTuristicoCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: PaqueteTuristicoUpsertWithWhereUniqueWithoutEmprendimientoInput | PaqueteTuristicoUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: PaqueteTuristicoCreateManyEmprendimientoInputEnvelope
    set?: PaqueteTuristicoWhereUniqueInput | PaqueteTuristicoWhereUniqueInput[]
    disconnect?: PaqueteTuristicoWhereUniqueInput | PaqueteTuristicoWhereUniqueInput[]
    delete?: PaqueteTuristicoWhereUniqueInput | PaqueteTuristicoWhereUniqueInput[]
    connect?: PaqueteTuristicoWhereUniqueInput | PaqueteTuristicoWhereUniqueInput[]
    update?: PaqueteTuristicoUpdateWithWhereUniqueWithoutEmprendimientoInput | PaqueteTuristicoUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: PaqueteTuristicoUpdateManyWithWhereWithoutEmprendimientoInput | PaqueteTuristicoUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: PaqueteTuristicoScalarWhereInput | PaqueteTuristicoScalarWhereInput[]
  }

  export type ServicioEmprendedorUncheckedUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<ServicioEmprendedorCreateWithoutEmprendimientoInput, ServicioEmprendedorUncheckedCreateWithoutEmprendimientoInput> | ServicioEmprendedorCreateWithoutEmprendimientoInput[] | ServicioEmprendedorUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: ServicioEmprendedorCreateOrConnectWithoutEmprendimientoInput | ServicioEmprendedorCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: ServicioEmprendedorUpsertWithWhereUniqueWithoutEmprendimientoInput | ServicioEmprendedorUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: ServicioEmprendedorCreateManyEmprendimientoInputEnvelope
    set?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    disconnect?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    delete?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    connect?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    update?: ServicioEmprendedorUpdateWithWhereUniqueWithoutEmprendimientoInput | ServicioEmprendedorUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: ServicioEmprendedorUpdateManyWithWhereWithoutEmprendimientoInput | ServicioEmprendedorUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: ServicioEmprendedorScalarWhereInput | ServicioEmprendedorScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutRegistroAccesosInput = {
    create?: XOR<UsuarioCreateWithoutRegistroAccesosInput, UsuarioUncheckedCreateWithoutRegistroAccesosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRegistroAccesosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutRegistroAccesosNestedInput = {
    create?: XOR<UsuarioCreateWithoutRegistroAccesosInput, UsuarioUncheckedCreateWithoutRegistroAccesosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRegistroAccesosInput
    upsert?: UsuarioUpsertWithoutRegistroAccesosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutRegistroAccesosInput, UsuarioUpdateWithoutRegistroAccesosInput>, UsuarioUncheckedUpdateWithoutRegistroAccesosInput>
  }

  export type UsuarioCreateNestedOneWithoutTokensInvalidadosInput = {
    create?: XOR<UsuarioCreateWithoutTokensInvalidadosInput, UsuarioUncheckedCreateWithoutTokensInvalidadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTokensInvalidadosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutTokensInvalidadosNestedInput = {
    create?: XOR<UsuarioCreateWithoutTokensInvalidadosInput, UsuarioUncheckedCreateWithoutTokensInvalidadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTokensInvalidadosInput
    upsert?: UsuarioUpsertWithoutTokensInvalidadosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutTokensInvalidadosInput, UsuarioUpdateWithoutTokensInvalidadosInput>, UsuarioUncheckedUpdateWithoutTokensInvalidadosInput>
  }

  export type ReservaCreateNestedManyWithoutTuristaInput = {
    create?: XOR<ReservaCreateWithoutTuristaInput, ReservaUncheckedCreateWithoutTuristaInput> | ReservaCreateWithoutTuristaInput[] | ReservaUncheckedCreateWithoutTuristaInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutTuristaInput | ReservaCreateOrConnectWithoutTuristaInput[]
    createMany?: ReservaCreateManyTuristaInputEnvelope
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
  }

  export type ReservaUncheckedCreateNestedManyWithoutTuristaInput = {
    create?: XOR<ReservaCreateWithoutTuristaInput, ReservaUncheckedCreateWithoutTuristaInput> | ReservaCreateWithoutTuristaInput[] | ReservaUncheckedCreateWithoutTuristaInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutTuristaInput | ReservaCreateOrConnectWithoutTuristaInput[]
    createMany?: ReservaCreateManyTuristaInputEnvelope
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ReservaUpdateManyWithoutTuristaNestedInput = {
    create?: XOR<ReservaCreateWithoutTuristaInput, ReservaUncheckedCreateWithoutTuristaInput> | ReservaCreateWithoutTuristaInput[] | ReservaUncheckedCreateWithoutTuristaInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutTuristaInput | ReservaCreateOrConnectWithoutTuristaInput[]
    upsert?: ReservaUpsertWithWhereUniqueWithoutTuristaInput | ReservaUpsertWithWhereUniqueWithoutTuristaInput[]
    createMany?: ReservaCreateManyTuristaInputEnvelope
    set?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    disconnect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    delete?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    update?: ReservaUpdateWithWhereUniqueWithoutTuristaInput | ReservaUpdateWithWhereUniqueWithoutTuristaInput[]
    updateMany?: ReservaUpdateManyWithWhereWithoutTuristaInput | ReservaUpdateManyWithWhereWithoutTuristaInput[]
    deleteMany?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
  }

  export type ReservaUncheckedUpdateManyWithoutTuristaNestedInput = {
    create?: XOR<ReservaCreateWithoutTuristaInput, ReservaUncheckedCreateWithoutTuristaInput> | ReservaCreateWithoutTuristaInput[] | ReservaUncheckedCreateWithoutTuristaInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutTuristaInput | ReservaCreateOrConnectWithoutTuristaInput[]
    upsert?: ReservaUpsertWithWhereUniqueWithoutTuristaInput | ReservaUpsertWithWhereUniqueWithoutTuristaInput[]
    createMany?: ReservaCreateManyTuristaInputEnvelope
    set?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    disconnect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    delete?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    update?: ReservaUpdateWithWhereUniqueWithoutTuristaInput | ReservaUpdateWithWhereUniqueWithoutTuristaInput[]
    updateMany?: ReservaUpdateManyWithWhereWithoutTuristaInput | ReservaUpdateManyWithWhereWithoutTuristaInput[]
    deleteMany?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
  }

  export type ItinerarioLugarCreateNestedManyWithoutLugarTuristicoInput = {
    create?: XOR<ItinerarioLugarCreateWithoutLugarTuristicoInput, ItinerarioLugarUncheckedCreateWithoutLugarTuristicoInput> | ItinerarioLugarCreateWithoutLugarTuristicoInput[] | ItinerarioLugarUncheckedCreateWithoutLugarTuristicoInput[]
    connectOrCreate?: ItinerarioLugarCreateOrConnectWithoutLugarTuristicoInput | ItinerarioLugarCreateOrConnectWithoutLugarTuristicoInput[]
    createMany?: ItinerarioLugarCreateManyLugarTuristicoInputEnvelope
    connect?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
  }

  export type ItinerarioLugarUncheckedCreateNestedManyWithoutLugarTuristicoInput = {
    create?: XOR<ItinerarioLugarCreateWithoutLugarTuristicoInput, ItinerarioLugarUncheckedCreateWithoutLugarTuristicoInput> | ItinerarioLugarCreateWithoutLugarTuristicoInput[] | ItinerarioLugarUncheckedCreateWithoutLugarTuristicoInput[]
    connectOrCreate?: ItinerarioLugarCreateOrConnectWithoutLugarTuristicoInput | ItinerarioLugarCreateOrConnectWithoutLugarTuristicoInput[]
    createMany?: ItinerarioLugarCreateManyLugarTuristicoInputEnvelope
    connect?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ItinerarioLugarUpdateManyWithoutLugarTuristicoNestedInput = {
    create?: XOR<ItinerarioLugarCreateWithoutLugarTuristicoInput, ItinerarioLugarUncheckedCreateWithoutLugarTuristicoInput> | ItinerarioLugarCreateWithoutLugarTuristicoInput[] | ItinerarioLugarUncheckedCreateWithoutLugarTuristicoInput[]
    connectOrCreate?: ItinerarioLugarCreateOrConnectWithoutLugarTuristicoInput | ItinerarioLugarCreateOrConnectWithoutLugarTuristicoInput[]
    upsert?: ItinerarioLugarUpsertWithWhereUniqueWithoutLugarTuristicoInput | ItinerarioLugarUpsertWithWhereUniqueWithoutLugarTuristicoInput[]
    createMany?: ItinerarioLugarCreateManyLugarTuristicoInputEnvelope
    set?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    disconnect?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    delete?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    connect?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    update?: ItinerarioLugarUpdateWithWhereUniqueWithoutLugarTuristicoInput | ItinerarioLugarUpdateWithWhereUniqueWithoutLugarTuristicoInput[]
    updateMany?: ItinerarioLugarUpdateManyWithWhereWithoutLugarTuristicoInput | ItinerarioLugarUpdateManyWithWhereWithoutLugarTuristicoInput[]
    deleteMany?: ItinerarioLugarScalarWhereInput | ItinerarioLugarScalarWhereInput[]
  }

  export type ItinerarioLugarUncheckedUpdateManyWithoutLugarTuristicoNestedInput = {
    create?: XOR<ItinerarioLugarCreateWithoutLugarTuristicoInput, ItinerarioLugarUncheckedCreateWithoutLugarTuristicoInput> | ItinerarioLugarCreateWithoutLugarTuristicoInput[] | ItinerarioLugarUncheckedCreateWithoutLugarTuristicoInput[]
    connectOrCreate?: ItinerarioLugarCreateOrConnectWithoutLugarTuristicoInput | ItinerarioLugarCreateOrConnectWithoutLugarTuristicoInput[]
    upsert?: ItinerarioLugarUpsertWithWhereUniqueWithoutLugarTuristicoInput | ItinerarioLugarUpsertWithWhereUniqueWithoutLugarTuristicoInput[]
    createMany?: ItinerarioLugarCreateManyLugarTuristicoInputEnvelope
    set?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    disconnect?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    delete?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    connect?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    update?: ItinerarioLugarUpdateWithWhereUniqueWithoutLugarTuristicoInput | ItinerarioLugarUpdateWithWhereUniqueWithoutLugarTuristicoInput[]
    updateMany?: ItinerarioLugarUpdateManyWithWhereWithoutLugarTuristicoInput | ItinerarioLugarUpdateManyWithWhereWithoutLugarTuristicoInput[]
    deleteMany?: ItinerarioLugarScalarWhereInput | ItinerarioLugarScalarWhereInput[]
  }

  export type EmprendimientoCreateNestedOneWithoutServiciosInput = {
    create?: XOR<EmprendimientoCreateWithoutServiciosInput, EmprendimientoUncheckedCreateWithoutServiciosInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutServiciosInput
    connect?: EmprendimientoWhereUniqueInput
  }

  export type ServicioCreateNestedOneWithoutServiciosEmprendedoresInput = {
    create?: XOR<ServicioCreateWithoutServiciosEmprendedoresInput, ServicioUncheckedCreateWithoutServiciosEmprendedoresInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutServiciosEmprendedoresInput
    connect?: ServicioWhereUniqueInput
  }

  export type EmprendimientoUpdateOneRequiredWithoutServiciosNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutServiciosInput, EmprendimientoUncheckedCreateWithoutServiciosInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutServiciosInput
    upsert?: EmprendimientoUpsertWithoutServiciosInput
    connect?: EmprendimientoWhereUniqueInput
    update?: XOR<XOR<EmprendimientoUpdateToOneWithWhereWithoutServiciosInput, EmprendimientoUpdateWithoutServiciosInput>, EmprendimientoUncheckedUpdateWithoutServiciosInput>
  }

  export type ServicioUpdateOneRequiredWithoutServiciosEmprendedoresNestedInput = {
    create?: XOR<ServicioCreateWithoutServiciosEmprendedoresInput, ServicioUncheckedCreateWithoutServiciosEmprendedoresInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutServiciosEmprendedoresInput
    upsert?: ServicioUpsertWithoutServiciosEmprendedoresInput
    connect?: ServicioWhereUniqueInput
    update?: XOR<XOR<ServicioUpdateToOneWithWhereWithoutServiciosEmprendedoresInput, ServicioUpdateWithoutServiciosEmprendedoresInput>, ServicioUncheckedUpdateWithoutServiciosEmprendedoresInput>
  }

  export type ItinerarioReservaCreateNestedManyWithoutServicioInput = {
    create?: XOR<ItinerarioReservaCreateWithoutServicioInput, ItinerarioReservaUncheckedCreateWithoutServicioInput> | ItinerarioReservaCreateWithoutServicioInput[] | ItinerarioReservaUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ItinerarioReservaCreateOrConnectWithoutServicioInput | ItinerarioReservaCreateOrConnectWithoutServicioInput[]
    createMany?: ItinerarioReservaCreateManyServicioInputEnvelope
    connect?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
  }

  export type PaqueteTuristicoServicioCreateNestedManyWithoutServicioInput = {
    create?: XOR<PaqueteTuristicoServicioCreateWithoutServicioInput, PaqueteTuristicoServicioUncheckedCreateWithoutServicioInput> | PaqueteTuristicoServicioCreateWithoutServicioInput[] | PaqueteTuristicoServicioUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: PaqueteTuristicoServicioCreateOrConnectWithoutServicioInput | PaqueteTuristicoServicioCreateOrConnectWithoutServicioInput[]
    createMany?: PaqueteTuristicoServicioCreateManyServicioInputEnvelope
    connect?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
  }

  export type TipoServicioCreateNestedOneWithoutServiciosInput = {
    create?: XOR<TipoServicioCreateWithoutServiciosInput, TipoServicioUncheckedCreateWithoutServiciosInput>
    connectOrCreate?: TipoServicioCreateOrConnectWithoutServiciosInput
    connect?: TipoServicioWhereUniqueInput
  }

  export type ServicioDisponibilidadCreateNestedManyWithoutServicioInput = {
    create?: XOR<ServicioDisponibilidadCreateWithoutServicioInput, ServicioDisponibilidadUncheckedCreateWithoutServicioInput> | ServicioDisponibilidadCreateWithoutServicioInput[] | ServicioDisponibilidadUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ServicioDisponibilidadCreateOrConnectWithoutServicioInput | ServicioDisponibilidadCreateOrConnectWithoutServicioInput[]
    createMany?: ServicioDisponibilidadCreateManyServicioInputEnvelope
    connect?: ServicioDisponibilidadWhereUniqueInput | ServicioDisponibilidadWhereUniqueInput[]
  }

  export type ServicioEmprendedorCreateNestedManyWithoutServicioInput = {
    create?: XOR<ServicioEmprendedorCreateWithoutServicioInput, ServicioEmprendedorUncheckedCreateWithoutServicioInput> | ServicioEmprendedorCreateWithoutServicioInput[] | ServicioEmprendedorUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ServicioEmprendedorCreateOrConnectWithoutServicioInput | ServicioEmprendedorCreateOrConnectWithoutServicioInput[]
    createMany?: ServicioEmprendedorCreateManyServicioInputEnvelope
    connect?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
  }

  export type ItinerarioReservaUncheckedCreateNestedManyWithoutServicioInput = {
    create?: XOR<ItinerarioReservaCreateWithoutServicioInput, ItinerarioReservaUncheckedCreateWithoutServicioInput> | ItinerarioReservaCreateWithoutServicioInput[] | ItinerarioReservaUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ItinerarioReservaCreateOrConnectWithoutServicioInput | ItinerarioReservaCreateOrConnectWithoutServicioInput[]
    createMany?: ItinerarioReservaCreateManyServicioInputEnvelope
    connect?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
  }

  export type PaqueteTuristicoServicioUncheckedCreateNestedManyWithoutServicioInput = {
    create?: XOR<PaqueteTuristicoServicioCreateWithoutServicioInput, PaqueteTuristicoServicioUncheckedCreateWithoutServicioInput> | PaqueteTuristicoServicioCreateWithoutServicioInput[] | PaqueteTuristicoServicioUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: PaqueteTuristicoServicioCreateOrConnectWithoutServicioInput | PaqueteTuristicoServicioCreateOrConnectWithoutServicioInput[]
    createMany?: PaqueteTuristicoServicioCreateManyServicioInputEnvelope
    connect?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
  }

  export type ServicioDisponibilidadUncheckedCreateNestedManyWithoutServicioInput = {
    create?: XOR<ServicioDisponibilidadCreateWithoutServicioInput, ServicioDisponibilidadUncheckedCreateWithoutServicioInput> | ServicioDisponibilidadCreateWithoutServicioInput[] | ServicioDisponibilidadUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ServicioDisponibilidadCreateOrConnectWithoutServicioInput | ServicioDisponibilidadCreateOrConnectWithoutServicioInput[]
    createMany?: ServicioDisponibilidadCreateManyServicioInputEnvelope
    connect?: ServicioDisponibilidadWhereUniqueInput | ServicioDisponibilidadWhereUniqueInput[]
  }

  export type ServicioEmprendedorUncheckedCreateNestedManyWithoutServicioInput = {
    create?: XOR<ServicioEmprendedorCreateWithoutServicioInput, ServicioEmprendedorUncheckedCreateWithoutServicioInput> | ServicioEmprendedorCreateWithoutServicioInput[] | ServicioEmprendedorUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ServicioEmprendedorCreateOrConnectWithoutServicioInput | ServicioEmprendedorCreateOrConnectWithoutServicioInput[]
    createMany?: ServicioEmprendedorCreateManyServicioInputEnvelope
    connect?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
  }

  export type ItinerarioReservaUpdateManyWithoutServicioNestedInput = {
    create?: XOR<ItinerarioReservaCreateWithoutServicioInput, ItinerarioReservaUncheckedCreateWithoutServicioInput> | ItinerarioReservaCreateWithoutServicioInput[] | ItinerarioReservaUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ItinerarioReservaCreateOrConnectWithoutServicioInput | ItinerarioReservaCreateOrConnectWithoutServicioInput[]
    upsert?: ItinerarioReservaUpsertWithWhereUniqueWithoutServicioInput | ItinerarioReservaUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: ItinerarioReservaCreateManyServicioInputEnvelope
    set?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    disconnect?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    delete?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    connect?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    update?: ItinerarioReservaUpdateWithWhereUniqueWithoutServicioInput | ItinerarioReservaUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: ItinerarioReservaUpdateManyWithWhereWithoutServicioInput | ItinerarioReservaUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: ItinerarioReservaScalarWhereInput | ItinerarioReservaScalarWhereInput[]
  }

  export type PaqueteTuristicoServicioUpdateManyWithoutServicioNestedInput = {
    create?: XOR<PaqueteTuristicoServicioCreateWithoutServicioInput, PaqueteTuristicoServicioUncheckedCreateWithoutServicioInput> | PaqueteTuristicoServicioCreateWithoutServicioInput[] | PaqueteTuristicoServicioUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: PaqueteTuristicoServicioCreateOrConnectWithoutServicioInput | PaqueteTuristicoServicioCreateOrConnectWithoutServicioInput[]
    upsert?: PaqueteTuristicoServicioUpsertWithWhereUniqueWithoutServicioInput | PaqueteTuristicoServicioUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: PaqueteTuristicoServicioCreateManyServicioInputEnvelope
    set?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    disconnect?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    delete?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    connect?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    update?: PaqueteTuristicoServicioUpdateWithWhereUniqueWithoutServicioInput | PaqueteTuristicoServicioUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: PaqueteTuristicoServicioUpdateManyWithWhereWithoutServicioInput | PaqueteTuristicoServicioUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: PaqueteTuristicoServicioScalarWhereInput | PaqueteTuristicoServicioScalarWhereInput[]
  }

  export type TipoServicioUpdateOneRequiredWithoutServiciosNestedInput = {
    create?: XOR<TipoServicioCreateWithoutServiciosInput, TipoServicioUncheckedCreateWithoutServiciosInput>
    connectOrCreate?: TipoServicioCreateOrConnectWithoutServiciosInput
    upsert?: TipoServicioUpsertWithoutServiciosInput
    connect?: TipoServicioWhereUniqueInput
    update?: XOR<XOR<TipoServicioUpdateToOneWithWhereWithoutServiciosInput, TipoServicioUpdateWithoutServiciosInput>, TipoServicioUncheckedUpdateWithoutServiciosInput>
  }

  export type ServicioDisponibilidadUpdateManyWithoutServicioNestedInput = {
    create?: XOR<ServicioDisponibilidadCreateWithoutServicioInput, ServicioDisponibilidadUncheckedCreateWithoutServicioInput> | ServicioDisponibilidadCreateWithoutServicioInput[] | ServicioDisponibilidadUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ServicioDisponibilidadCreateOrConnectWithoutServicioInput | ServicioDisponibilidadCreateOrConnectWithoutServicioInput[]
    upsert?: ServicioDisponibilidadUpsertWithWhereUniqueWithoutServicioInput | ServicioDisponibilidadUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: ServicioDisponibilidadCreateManyServicioInputEnvelope
    set?: ServicioDisponibilidadWhereUniqueInput | ServicioDisponibilidadWhereUniqueInput[]
    disconnect?: ServicioDisponibilidadWhereUniqueInput | ServicioDisponibilidadWhereUniqueInput[]
    delete?: ServicioDisponibilidadWhereUniqueInput | ServicioDisponibilidadWhereUniqueInput[]
    connect?: ServicioDisponibilidadWhereUniqueInput | ServicioDisponibilidadWhereUniqueInput[]
    update?: ServicioDisponibilidadUpdateWithWhereUniqueWithoutServicioInput | ServicioDisponibilidadUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: ServicioDisponibilidadUpdateManyWithWhereWithoutServicioInput | ServicioDisponibilidadUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: ServicioDisponibilidadScalarWhereInput | ServicioDisponibilidadScalarWhereInput[]
  }

  export type ServicioEmprendedorUpdateManyWithoutServicioNestedInput = {
    create?: XOR<ServicioEmprendedorCreateWithoutServicioInput, ServicioEmprendedorUncheckedCreateWithoutServicioInput> | ServicioEmprendedorCreateWithoutServicioInput[] | ServicioEmprendedorUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ServicioEmprendedorCreateOrConnectWithoutServicioInput | ServicioEmprendedorCreateOrConnectWithoutServicioInput[]
    upsert?: ServicioEmprendedorUpsertWithWhereUniqueWithoutServicioInput | ServicioEmprendedorUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: ServicioEmprendedorCreateManyServicioInputEnvelope
    set?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    disconnect?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    delete?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    connect?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    update?: ServicioEmprendedorUpdateWithWhereUniqueWithoutServicioInput | ServicioEmprendedorUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: ServicioEmprendedorUpdateManyWithWhereWithoutServicioInput | ServicioEmprendedorUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: ServicioEmprendedorScalarWhereInput | ServicioEmprendedorScalarWhereInput[]
  }

  export type ItinerarioReservaUncheckedUpdateManyWithoutServicioNestedInput = {
    create?: XOR<ItinerarioReservaCreateWithoutServicioInput, ItinerarioReservaUncheckedCreateWithoutServicioInput> | ItinerarioReservaCreateWithoutServicioInput[] | ItinerarioReservaUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ItinerarioReservaCreateOrConnectWithoutServicioInput | ItinerarioReservaCreateOrConnectWithoutServicioInput[]
    upsert?: ItinerarioReservaUpsertWithWhereUniqueWithoutServicioInput | ItinerarioReservaUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: ItinerarioReservaCreateManyServicioInputEnvelope
    set?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    disconnect?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    delete?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    connect?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    update?: ItinerarioReservaUpdateWithWhereUniqueWithoutServicioInput | ItinerarioReservaUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: ItinerarioReservaUpdateManyWithWhereWithoutServicioInput | ItinerarioReservaUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: ItinerarioReservaScalarWhereInput | ItinerarioReservaScalarWhereInput[]
  }

  export type PaqueteTuristicoServicioUncheckedUpdateManyWithoutServicioNestedInput = {
    create?: XOR<PaqueteTuristicoServicioCreateWithoutServicioInput, PaqueteTuristicoServicioUncheckedCreateWithoutServicioInput> | PaqueteTuristicoServicioCreateWithoutServicioInput[] | PaqueteTuristicoServicioUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: PaqueteTuristicoServicioCreateOrConnectWithoutServicioInput | PaqueteTuristicoServicioCreateOrConnectWithoutServicioInput[]
    upsert?: PaqueteTuristicoServicioUpsertWithWhereUniqueWithoutServicioInput | PaqueteTuristicoServicioUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: PaqueteTuristicoServicioCreateManyServicioInputEnvelope
    set?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    disconnect?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    delete?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    connect?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    update?: PaqueteTuristicoServicioUpdateWithWhereUniqueWithoutServicioInput | PaqueteTuristicoServicioUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: PaqueteTuristicoServicioUpdateManyWithWhereWithoutServicioInput | PaqueteTuristicoServicioUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: PaqueteTuristicoServicioScalarWhereInput | PaqueteTuristicoServicioScalarWhereInput[]
  }

  export type ServicioDisponibilidadUncheckedUpdateManyWithoutServicioNestedInput = {
    create?: XOR<ServicioDisponibilidadCreateWithoutServicioInput, ServicioDisponibilidadUncheckedCreateWithoutServicioInput> | ServicioDisponibilidadCreateWithoutServicioInput[] | ServicioDisponibilidadUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ServicioDisponibilidadCreateOrConnectWithoutServicioInput | ServicioDisponibilidadCreateOrConnectWithoutServicioInput[]
    upsert?: ServicioDisponibilidadUpsertWithWhereUniqueWithoutServicioInput | ServicioDisponibilidadUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: ServicioDisponibilidadCreateManyServicioInputEnvelope
    set?: ServicioDisponibilidadWhereUniqueInput | ServicioDisponibilidadWhereUniqueInput[]
    disconnect?: ServicioDisponibilidadWhereUniqueInput | ServicioDisponibilidadWhereUniqueInput[]
    delete?: ServicioDisponibilidadWhereUniqueInput | ServicioDisponibilidadWhereUniqueInput[]
    connect?: ServicioDisponibilidadWhereUniqueInput | ServicioDisponibilidadWhereUniqueInput[]
    update?: ServicioDisponibilidadUpdateWithWhereUniqueWithoutServicioInput | ServicioDisponibilidadUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: ServicioDisponibilidadUpdateManyWithWhereWithoutServicioInput | ServicioDisponibilidadUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: ServicioDisponibilidadScalarWhereInput | ServicioDisponibilidadScalarWhereInput[]
  }

  export type ServicioEmprendedorUncheckedUpdateManyWithoutServicioNestedInput = {
    create?: XOR<ServicioEmprendedorCreateWithoutServicioInput, ServicioEmprendedorUncheckedCreateWithoutServicioInput> | ServicioEmprendedorCreateWithoutServicioInput[] | ServicioEmprendedorUncheckedCreateWithoutServicioInput[]
    connectOrCreate?: ServicioEmprendedorCreateOrConnectWithoutServicioInput | ServicioEmprendedorCreateOrConnectWithoutServicioInput[]
    upsert?: ServicioEmprendedorUpsertWithWhereUniqueWithoutServicioInput | ServicioEmprendedorUpsertWithWhereUniqueWithoutServicioInput[]
    createMany?: ServicioEmprendedorCreateManyServicioInputEnvelope
    set?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    disconnect?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    delete?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    connect?: ServicioEmprendedorWhereUniqueInput | ServicioEmprendedorWhereUniqueInput[]
    update?: ServicioEmprendedorUpdateWithWhereUniqueWithoutServicioInput | ServicioEmprendedorUpdateWithWhereUniqueWithoutServicioInput[]
    updateMany?: ServicioEmprendedorUpdateManyWithWhereWithoutServicioInput | ServicioEmprendedorUpdateManyWithWhereWithoutServicioInput[]
    deleteMany?: ServicioEmprendedorScalarWhereInput | ServicioEmprendedorScalarWhereInput[]
  }

  export type PaqueteTuristicoCreateNestedOneWithoutServiciosInput = {
    create?: XOR<PaqueteTuristicoCreateWithoutServiciosInput, PaqueteTuristicoUncheckedCreateWithoutServiciosInput>
    connectOrCreate?: PaqueteTuristicoCreateOrConnectWithoutServiciosInput
    connect?: PaqueteTuristicoWhereUniqueInput
  }

  export type ServicioCreateNestedOneWithoutPaquetesServiciosInput = {
    create?: XOR<ServicioCreateWithoutPaquetesServiciosInput, ServicioUncheckedCreateWithoutPaquetesServiciosInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutPaquetesServiciosInput
    connect?: ServicioWhereUniqueInput
  }

  export type PaqueteTuristicoUpdateOneRequiredWithoutServiciosNestedInput = {
    create?: XOR<PaqueteTuristicoCreateWithoutServiciosInput, PaqueteTuristicoUncheckedCreateWithoutServiciosInput>
    connectOrCreate?: PaqueteTuristicoCreateOrConnectWithoutServiciosInput
    upsert?: PaqueteTuristicoUpsertWithoutServiciosInput
    connect?: PaqueteTuristicoWhereUniqueInput
    update?: XOR<XOR<PaqueteTuristicoUpdateToOneWithWhereWithoutServiciosInput, PaqueteTuristicoUpdateWithoutServiciosInput>, PaqueteTuristicoUncheckedUpdateWithoutServiciosInput>
  }

  export type ServicioUpdateOneRequiredWithoutPaquetesServiciosNestedInput = {
    create?: XOR<ServicioCreateWithoutPaquetesServiciosInput, ServicioUncheckedCreateWithoutPaquetesServiciosInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutPaquetesServiciosInput
    upsert?: ServicioUpsertWithoutPaquetesServiciosInput
    connect?: ServicioWhereUniqueInput
    update?: XOR<XOR<ServicioUpdateToOneWithWhereWithoutPaquetesServiciosInput, ServicioUpdateWithoutPaquetesServiciosInput>, ServicioUncheckedUpdateWithoutPaquetesServiciosInput>
  }

  export type DisponibilidadPaqueteCreateNestedManyWithoutPaqueteInput = {
    create?: XOR<DisponibilidadPaqueteCreateWithoutPaqueteInput, DisponibilidadPaqueteUncheckedCreateWithoutPaqueteInput> | DisponibilidadPaqueteCreateWithoutPaqueteInput[] | DisponibilidadPaqueteUncheckedCreateWithoutPaqueteInput[]
    connectOrCreate?: DisponibilidadPaqueteCreateOrConnectWithoutPaqueteInput | DisponibilidadPaqueteCreateOrConnectWithoutPaqueteInput[]
    createMany?: DisponibilidadPaqueteCreateManyPaqueteInputEnvelope
    connect?: DisponibilidadPaqueteWhereUniqueInput | DisponibilidadPaqueteWhereUniqueInput[]
  }

  export type EmprendimientoCreateNestedOneWithoutPaquetesTuristicosInput = {
    create?: XOR<EmprendimientoCreateWithoutPaquetesTuristicosInput, EmprendimientoUncheckedCreateWithoutPaquetesTuristicosInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutPaquetesTuristicosInput
    connect?: EmprendimientoWhereUniqueInput
  }

  export type PaqueteTuristicoServicioCreateNestedManyWithoutPaqueteTuristicoInput = {
    create?: XOR<PaqueteTuristicoServicioCreateWithoutPaqueteTuristicoInput, PaqueteTuristicoServicioUncheckedCreateWithoutPaqueteTuristicoInput> | PaqueteTuristicoServicioCreateWithoutPaqueteTuristicoInput[] | PaqueteTuristicoServicioUncheckedCreateWithoutPaqueteTuristicoInput[]
    connectOrCreate?: PaqueteTuristicoServicioCreateOrConnectWithoutPaqueteTuristicoInput | PaqueteTuristicoServicioCreateOrConnectWithoutPaqueteTuristicoInput[]
    createMany?: PaqueteTuristicoServicioCreateManyPaqueteTuristicoInputEnvelope
    connect?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
  }

  export type DisponibilidadPaqueteUncheckedCreateNestedManyWithoutPaqueteInput = {
    create?: XOR<DisponibilidadPaqueteCreateWithoutPaqueteInput, DisponibilidadPaqueteUncheckedCreateWithoutPaqueteInput> | DisponibilidadPaqueteCreateWithoutPaqueteInput[] | DisponibilidadPaqueteUncheckedCreateWithoutPaqueteInput[]
    connectOrCreate?: DisponibilidadPaqueteCreateOrConnectWithoutPaqueteInput | DisponibilidadPaqueteCreateOrConnectWithoutPaqueteInput[]
    createMany?: DisponibilidadPaqueteCreateManyPaqueteInputEnvelope
    connect?: DisponibilidadPaqueteWhereUniqueInput | DisponibilidadPaqueteWhereUniqueInput[]
  }

  export type PaqueteTuristicoServicioUncheckedCreateNestedManyWithoutPaqueteTuristicoInput = {
    create?: XOR<PaqueteTuristicoServicioCreateWithoutPaqueteTuristicoInput, PaqueteTuristicoServicioUncheckedCreateWithoutPaqueteTuristicoInput> | PaqueteTuristicoServicioCreateWithoutPaqueteTuristicoInput[] | PaqueteTuristicoServicioUncheckedCreateWithoutPaqueteTuristicoInput[]
    connectOrCreate?: PaqueteTuristicoServicioCreateOrConnectWithoutPaqueteTuristicoInput | PaqueteTuristicoServicioCreateOrConnectWithoutPaqueteTuristicoInput[]
    createMany?: PaqueteTuristicoServicioCreateManyPaqueteTuristicoInputEnvelope
    connect?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
  }

  export type DisponibilidadPaqueteUpdateManyWithoutPaqueteNestedInput = {
    create?: XOR<DisponibilidadPaqueteCreateWithoutPaqueteInput, DisponibilidadPaqueteUncheckedCreateWithoutPaqueteInput> | DisponibilidadPaqueteCreateWithoutPaqueteInput[] | DisponibilidadPaqueteUncheckedCreateWithoutPaqueteInput[]
    connectOrCreate?: DisponibilidadPaqueteCreateOrConnectWithoutPaqueteInput | DisponibilidadPaqueteCreateOrConnectWithoutPaqueteInput[]
    upsert?: DisponibilidadPaqueteUpsertWithWhereUniqueWithoutPaqueteInput | DisponibilidadPaqueteUpsertWithWhereUniqueWithoutPaqueteInput[]
    createMany?: DisponibilidadPaqueteCreateManyPaqueteInputEnvelope
    set?: DisponibilidadPaqueteWhereUniqueInput | DisponibilidadPaqueteWhereUniqueInput[]
    disconnect?: DisponibilidadPaqueteWhereUniqueInput | DisponibilidadPaqueteWhereUniqueInput[]
    delete?: DisponibilidadPaqueteWhereUniqueInput | DisponibilidadPaqueteWhereUniqueInput[]
    connect?: DisponibilidadPaqueteWhereUniqueInput | DisponibilidadPaqueteWhereUniqueInput[]
    update?: DisponibilidadPaqueteUpdateWithWhereUniqueWithoutPaqueteInput | DisponibilidadPaqueteUpdateWithWhereUniqueWithoutPaqueteInput[]
    updateMany?: DisponibilidadPaqueteUpdateManyWithWhereWithoutPaqueteInput | DisponibilidadPaqueteUpdateManyWithWhereWithoutPaqueteInput[]
    deleteMany?: DisponibilidadPaqueteScalarWhereInput | DisponibilidadPaqueteScalarWhereInput[]
  }

  export type EmprendimientoUpdateOneWithoutPaquetesTuristicosNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutPaquetesTuristicosInput, EmprendimientoUncheckedCreateWithoutPaquetesTuristicosInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutPaquetesTuristicosInput
    upsert?: EmprendimientoUpsertWithoutPaquetesTuristicosInput
    disconnect?: EmprendimientoWhereInput | boolean
    delete?: EmprendimientoWhereInput | boolean
    connect?: EmprendimientoWhereUniqueInput
    update?: XOR<XOR<EmprendimientoUpdateToOneWithWhereWithoutPaquetesTuristicosInput, EmprendimientoUpdateWithoutPaquetesTuristicosInput>, EmprendimientoUncheckedUpdateWithoutPaquetesTuristicosInput>
  }

  export type PaqueteTuristicoServicioUpdateManyWithoutPaqueteTuristicoNestedInput = {
    create?: XOR<PaqueteTuristicoServicioCreateWithoutPaqueteTuristicoInput, PaqueteTuristicoServicioUncheckedCreateWithoutPaqueteTuristicoInput> | PaqueteTuristicoServicioCreateWithoutPaqueteTuristicoInput[] | PaqueteTuristicoServicioUncheckedCreateWithoutPaqueteTuristicoInput[]
    connectOrCreate?: PaqueteTuristicoServicioCreateOrConnectWithoutPaqueteTuristicoInput | PaqueteTuristicoServicioCreateOrConnectWithoutPaqueteTuristicoInput[]
    upsert?: PaqueteTuristicoServicioUpsertWithWhereUniqueWithoutPaqueteTuristicoInput | PaqueteTuristicoServicioUpsertWithWhereUniqueWithoutPaqueteTuristicoInput[]
    createMany?: PaqueteTuristicoServicioCreateManyPaqueteTuristicoInputEnvelope
    set?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    disconnect?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    delete?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    connect?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    update?: PaqueteTuristicoServicioUpdateWithWhereUniqueWithoutPaqueteTuristicoInput | PaqueteTuristicoServicioUpdateWithWhereUniqueWithoutPaqueteTuristicoInput[]
    updateMany?: PaqueteTuristicoServicioUpdateManyWithWhereWithoutPaqueteTuristicoInput | PaqueteTuristicoServicioUpdateManyWithWhereWithoutPaqueteTuristicoInput[]
    deleteMany?: PaqueteTuristicoServicioScalarWhereInput | PaqueteTuristicoServicioScalarWhereInput[]
  }

  export type DisponibilidadPaqueteUncheckedUpdateManyWithoutPaqueteNestedInput = {
    create?: XOR<DisponibilidadPaqueteCreateWithoutPaqueteInput, DisponibilidadPaqueteUncheckedCreateWithoutPaqueteInput> | DisponibilidadPaqueteCreateWithoutPaqueteInput[] | DisponibilidadPaqueteUncheckedCreateWithoutPaqueteInput[]
    connectOrCreate?: DisponibilidadPaqueteCreateOrConnectWithoutPaqueteInput | DisponibilidadPaqueteCreateOrConnectWithoutPaqueteInput[]
    upsert?: DisponibilidadPaqueteUpsertWithWhereUniqueWithoutPaqueteInput | DisponibilidadPaqueteUpsertWithWhereUniqueWithoutPaqueteInput[]
    createMany?: DisponibilidadPaqueteCreateManyPaqueteInputEnvelope
    set?: DisponibilidadPaqueteWhereUniqueInput | DisponibilidadPaqueteWhereUniqueInput[]
    disconnect?: DisponibilidadPaqueteWhereUniqueInput | DisponibilidadPaqueteWhereUniqueInput[]
    delete?: DisponibilidadPaqueteWhereUniqueInput | DisponibilidadPaqueteWhereUniqueInput[]
    connect?: DisponibilidadPaqueteWhereUniqueInput | DisponibilidadPaqueteWhereUniqueInput[]
    update?: DisponibilidadPaqueteUpdateWithWhereUniqueWithoutPaqueteInput | DisponibilidadPaqueteUpdateWithWhereUniqueWithoutPaqueteInput[]
    updateMany?: DisponibilidadPaqueteUpdateManyWithWhereWithoutPaqueteInput | DisponibilidadPaqueteUpdateManyWithWhereWithoutPaqueteInput[]
    deleteMany?: DisponibilidadPaqueteScalarWhereInput | DisponibilidadPaqueteScalarWhereInput[]
  }

  export type PaqueteTuristicoServicioUncheckedUpdateManyWithoutPaqueteTuristicoNestedInput = {
    create?: XOR<PaqueteTuristicoServicioCreateWithoutPaqueteTuristicoInput, PaqueteTuristicoServicioUncheckedCreateWithoutPaqueteTuristicoInput> | PaqueteTuristicoServicioCreateWithoutPaqueteTuristicoInput[] | PaqueteTuristicoServicioUncheckedCreateWithoutPaqueteTuristicoInput[]
    connectOrCreate?: PaqueteTuristicoServicioCreateOrConnectWithoutPaqueteTuristicoInput | PaqueteTuristicoServicioCreateOrConnectWithoutPaqueteTuristicoInput[]
    upsert?: PaqueteTuristicoServicioUpsertWithWhereUniqueWithoutPaqueteTuristicoInput | PaqueteTuristicoServicioUpsertWithWhereUniqueWithoutPaqueteTuristicoInput[]
    createMany?: PaqueteTuristicoServicioCreateManyPaqueteTuristicoInputEnvelope
    set?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    disconnect?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    delete?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    connect?: PaqueteTuristicoServicioWhereUniqueInput | PaqueteTuristicoServicioWhereUniqueInput[]
    update?: PaqueteTuristicoServicioUpdateWithWhereUniqueWithoutPaqueteTuristicoInput | PaqueteTuristicoServicioUpdateWithWhereUniqueWithoutPaqueteTuristicoInput[]
    updateMany?: PaqueteTuristicoServicioUpdateManyWithWhereWithoutPaqueteTuristicoInput | PaqueteTuristicoServicioUpdateManyWithWhereWithoutPaqueteTuristicoInput[]
    deleteMany?: PaqueteTuristicoServicioScalarWhereInput | PaqueteTuristicoServicioScalarWhereInput[]
  }

  export type PaqueteTuristicoCreateNestedOneWithoutDisponibilidadInput = {
    create?: XOR<PaqueteTuristicoCreateWithoutDisponibilidadInput, PaqueteTuristicoUncheckedCreateWithoutDisponibilidadInput>
    connectOrCreate?: PaqueteTuristicoCreateOrConnectWithoutDisponibilidadInput
    connect?: PaqueteTuristicoWhereUniqueInput
  }

  export type PaqueteTuristicoUpdateOneRequiredWithoutDisponibilidadNestedInput = {
    create?: XOR<PaqueteTuristicoCreateWithoutDisponibilidadInput, PaqueteTuristicoUncheckedCreateWithoutDisponibilidadInput>
    connectOrCreate?: PaqueteTuristicoCreateOrConnectWithoutDisponibilidadInput
    upsert?: PaqueteTuristicoUpsertWithoutDisponibilidadInput
    connect?: PaqueteTuristicoWhereUniqueInput
    update?: XOR<XOR<PaqueteTuristicoUpdateToOneWithWhereWithoutDisponibilidadInput, PaqueteTuristicoUpdateWithoutDisponibilidadInput>, PaqueteTuristicoUncheckedUpdateWithoutDisponibilidadInput>
  }

  export type ServicioCreateNestedManyWithoutTipoServicioInput = {
    create?: XOR<ServicioCreateWithoutTipoServicioInput, ServicioUncheckedCreateWithoutTipoServicioInput> | ServicioCreateWithoutTipoServicioInput[] | ServicioUncheckedCreateWithoutTipoServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTipoServicioInput | ServicioCreateOrConnectWithoutTipoServicioInput[]
    createMany?: ServicioCreateManyTipoServicioInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type ServicioUncheckedCreateNestedManyWithoutTipoServicioInput = {
    create?: XOR<ServicioCreateWithoutTipoServicioInput, ServicioUncheckedCreateWithoutTipoServicioInput> | ServicioCreateWithoutTipoServicioInput[] | ServicioUncheckedCreateWithoutTipoServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTipoServicioInput | ServicioCreateOrConnectWithoutTipoServicioInput[]
    createMany?: ServicioCreateManyTipoServicioInputEnvelope
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
  }

  export type ServicioUpdateManyWithoutTipoServicioNestedInput = {
    create?: XOR<ServicioCreateWithoutTipoServicioInput, ServicioUncheckedCreateWithoutTipoServicioInput> | ServicioCreateWithoutTipoServicioInput[] | ServicioUncheckedCreateWithoutTipoServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTipoServicioInput | ServicioCreateOrConnectWithoutTipoServicioInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutTipoServicioInput | ServicioUpsertWithWhereUniqueWithoutTipoServicioInput[]
    createMany?: ServicioCreateManyTipoServicioInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutTipoServicioInput | ServicioUpdateWithWhereUniqueWithoutTipoServicioInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutTipoServicioInput | ServicioUpdateManyWithWhereWithoutTipoServicioInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type ServicioUncheckedUpdateManyWithoutTipoServicioNestedInput = {
    create?: XOR<ServicioCreateWithoutTipoServicioInput, ServicioUncheckedCreateWithoutTipoServicioInput> | ServicioCreateWithoutTipoServicioInput[] | ServicioUncheckedCreateWithoutTipoServicioInput[]
    connectOrCreate?: ServicioCreateOrConnectWithoutTipoServicioInput | ServicioCreateOrConnectWithoutTipoServicioInput[]
    upsert?: ServicioUpsertWithWhereUniqueWithoutTipoServicioInput | ServicioUpsertWithWhereUniqueWithoutTipoServicioInput[]
    createMany?: ServicioCreateManyTipoServicioInputEnvelope
    set?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    disconnect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    delete?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    connect?: ServicioWhereUniqueInput | ServicioWhereUniqueInput[]
    update?: ServicioUpdateWithWhereUniqueWithoutTipoServicioInput | ServicioUpdateWithWhereUniqueWithoutTipoServicioInput[]
    updateMany?: ServicioUpdateManyWithWhereWithoutTipoServicioInput | ServicioUpdateManyWithWhereWithoutTipoServicioInput[]
    deleteMany?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
  }

  export type ServicioCreateNestedOneWithoutDisponibilidadInput = {
    create?: XOR<ServicioCreateWithoutDisponibilidadInput, ServicioUncheckedCreateWithoutDisponibilidadInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutDisponibilidadInput
    connect?: ServicioWhereUniqueInput
  }

  export type ServicioUpdateOneRequiredWithoutDisponibilidadNestedInput = {
    create?: XOR<ServicioCreateWithoutDisponibilidadInput, ServicioUncheckedCreateWithoutDisponibilidadInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutDisponibilidadInput
    upsert?: ServicioUpsertWithoutDisponibilidadInput
    connect?: ServicioWhereUniqueInput
    update?: XOR<XOR<ServicioUpdateToOneWithWhereWithoutDisponibilidadInput, ServicioUpdateWithoutDisponibilidadInput>, ServicioUncheckedUpdateWithoutDisponibilidadInput>
  }

  export type UsuarioCreateNestedOneWithoutResenasInput = {
    create?: XOR<UsuarioCreateWithoutResenasInput, UsuarioUncheckedCreateWithoutResenasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutResenasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutResenasNestedInput = {
    create?: XOR<UsuarioCreateWithoutResenasInput, UsuarioUncheckedCreateWithoutResenasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutResenasInput
    upsert?: UsuarioUpsertWithoutResenasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutResenasInput, UsuarioUpdateWithoutResenasInput>, UsuarioUncheckedUpdateWithoutResenasInput>
  }

  export type EmprendimientoCreateNestedOneWithoutFavoritosInput = {
    create?: XOR<EmprendimientoCreateWithoutFavoritosInput, EmprendimientoUncheckedCreateWithoutFavoritosInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutFavoritosInput
    connect?: EmprendimientoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutFavoritosInput = {
    create?: XOR<UsuarioCreateWithoutFavoritosInput, UsuarioUncheckedCreateWithoutFavoritosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFavoritosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EmprendimientoUpdateOneRequiredWithoutFavoritosNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutFavoritosInput, EmprendimientoUncheckedCreateWithoutFavoritosInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutFavoritosInput
    upsert?: EmprendimientoUpsertWithoutFavoritosInput
    connect?: EmprendimientoWhereUniqueInput
    update?: XOR<XOR<EmprendimientoUpdateToOneWithWhereWithoutFavoritosInput, EmprendimientoUpdateWithoutFavoritosInput>, EmprendimientoUncheckedUpdateWithoutFavoritosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutFavoritosNestedInput = {
    create?: XOR<UsuarioCreateWithoutFavoritosInput, UsuarioUncheckedCreateWithoutFavoritosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutFavoritosInput
    upsert?: UsuarioUpsertWithoutFavoritosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutFavoritosInput, UsuarioUpdateWithoutFavoritosInput>, UsuarioUncheckedUpdateWithoutFavoritosInput>
  }

  export type ItinerarioReservaCreateNestedManyWithoutReservaInput = {
    create?: XOR<ItinerarioReservaCreateWithoutReservaInput, ItinerarioReservaUncheckedCreateWithoutReservaInput> | ItinerarioReservaCreateWithoutReservaInput[] | ItinerarioReservaUncheckedCreateWithoutReservaInput[]
    connectOrCreate?: ItinerarioReservaCreateOrConnectWithoutReservaInput | ItinerarioReservaCreateOrConnectWithoutReservaInput[]
    createMany?: ItinerarioReservaCreateManyReservaInputEnvelope
    connect?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
  }

  export type PagoCreateNestedManyWithoutReservaInput = {
    create?: XOR<PagoCreateWithoutReservaInput, PagoUncheckedCreateWithoutReservaInput> | PagoCreateWithoutReservaInput[] | PagoUncheckedCreateWithoutReservaInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutReservaInput | PagoCreateOrConnectWithoutReservaInput[]
    createMany?: PagoCreateManyReservaInputEnvelope
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
  }

  export type TuristaCreateNestedOneWithoutReservasInput = {
    create?: XOR<TuristaCreateWithoutReservasInput, TuristaUncheckedCreateWithoutReservasInput>
    connectOrCreate?: TuristaCreateOrConnectWithoutReservasInput
    connect?: TuristaWhereUniqueInput
  }

  export type ItinerarioReservaUncheckedCreateNestedManyWithoutReservaInput = {
    create?: XOR<ItinerarioReservaCreateWithoutReservaInput, ItinerarioReservaUncheckedCreateWithoutReservaInput> | ItinerarioReservaCreateWithoutReservaInput[] | ItinerarioReservaUncheckedCreateWithoutReservaInput[]
    connectOrCreate?: ItinerarioReservaCreateOrConnectWithoutReservaInput | ItinerarioReservaCreateOrConnectWithoutReservaInput[]
    createMany?: ItinerarioReservaCreateManyReservaInputEnvelope
    connect?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
  }

  export type PagoUncheckedCreateNestedManyWithoutReservaInput = {
    create?: XOR<PagoCreateWithoutReservaInput, PagoUncheckedCreateWithoutReservaInput> | PagoCreateWithoutReservaInput[] | PagoUncheckedCreateWithoutReservaInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutReservaInput | PagoCreateOrConnectWithoutReservaInput[]
    createMany?: PagoCreateManyReservaInputEnvelope
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
  }

  export type ItinerarioReservaUpdateManyWithoutReservaNestedInput = {
    create?: XOR<ItinerarioReservaCreateWithoutReservaInput, ItinerarioReservaUncheckedCreateWithoutReservaInput> | ItinerarioReservaCreateWithoutReservaInput[] | ItinerarioReservaUncheckedCreateWithoutReservaInput[]
    connectOrCreate?: ItinerarioReservaCreateOrConnectWithoutReservaInput | ItinerarioReservaCreateOrConnectWithoutReservaInput[]
    upsert?: ItinerarioReservaUpsertWithWhereUniqueWithoutReservaInput | ItinerarioReservaUpsertWithWhereUniqueWithoutReservaInput[]
    createMany?: ItinerarioReservaCreateManyReservaInputEnvelope
    set?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    disconnect?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    delete?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    connect?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    update?: ItinerarioReservaUpdateWithWhereUniqueWithoutReservaInput | ItinerarioReservaUpdateWithWhereUniqueWithoutReservaInput[]
    updateMany?: ItinerarioReservaUpdateManyWithWhereWithoutReservaInput | ItinerarioReservaUpdateManyWithWhereWithoutReservaInput[]
    deleteMany?: ItinerarioReservaScalarWhereInput | ItinerarioReservaScalarWhereInput[]
  }

  export type PagoUpdateManyWithoutReservaNestedInput = {
    create?: XOR<PagoCreateWithoutReservaInput, PagoUncheckedCreateWithoutReservaInput> | PagoCreateWithoutReservaInput[] | PagoUncheckedCreateWithoutReservaInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutReservaInput | PagoCreateOrConnectWithoutReservaInput[]
    upsert?: PagoUpsertWithWhereUniqueWithoutReservaInput | PagoUpsertWithWhereUniqueWithoutReservaInput[]
    createMany?: PagoCreateManyReservaInputEnvelope
    set?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    disconnect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    delete?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    update?: PagoUpdateWithWhereUniqueWithoutReservaInput | PagoUpdateWithWhereUniqueWithoutReservaInput[]
    updateMany?: PagoUpdateManyWithWhereWithoutReservaInput | PagoUpdateManyWithWhereWithoutReservaInput[]
    deleteMany?: PagoScalarWhereInput | PagoScalarWhereInput[]
  }

  export type TuristaUpdateOneRequiredWithoutReservasNestedInput = {
    create?: XOR<TuristaCreateWithoutReservasInput, TuristaUncheckedCreateWithoutReservasInput>
    connectOrCreate?: TuristaCreateOrConnectWithoutReservasInput
    upsert?: TuristaUpsertWithoutReservasInput
    connect?: TuristaWhereUniqueInput
    update?: XOR<XOR<TuristaUpdateToOneWithWhereWithoutReservasInput, TuristaUpdateWithoutReservasInput>, TuristaUncheckedUpdateWithoutReservasInput>
  }

  export type ItinerarioReservaUncheckedUpdateManyWithoutReservaNestedInput = {
    create?: XOR<ItinerarioReservaCreateWithoutReservaInput, ItinerarioReservaUncheckedCreateWithoutReservaInput> | ItinerarioReservaCreateWithoutReservaInput[] | ItinerarioReservaUncheckedCreateWithoutReservaInput[]
    connectOrCreate?: ItinerarioReservaCreateOrConnectWithoutReservaInput | ItinerarioReservaCreateOrConnectWithoutReservaInput[]
    upsert?: ItinerarioReservaUpsertWithWhereUniqueWithoutReservaInput | ItinerarioReservaUpsertWithWhereUniqueWithoutReservaInput[]
    createMany?: ItinerarioReservaCreateManyReservaInputEnvelope
    set?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    disconnect?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    delete?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    connect?: ItinerarioReservaWhereUniqueInput | ItinerarioReservaWhereUniqueInput[]
    update?: ItinerarioReservaUpdateWithWhereUniqueWithoutReservaInput | ItinerarioReservaUpdateWithWhereUniqueWithoutReservaInput[]
    updateMany?: ItinerarioReservaUpdateManyWithWhereWithoutReservaInput | ItinerarioReservaUpdateManyWithWhereWithoutReservaInput[]
    deleteMany?: ItinerarioReservaScalarWhereInput | ItinerarioReservaScalarWhereInput[]
  }

  export type PagoUncheckedUpdateManyWithoutReservaNestedInput = {
    create?: XOR<PagoCreateWithoutReservaInput, PagoUncheckedCreateWithoutReservaInput> | PagoCreateWithoutReservaInput[] | PagoUncheckedCreateWithoutReservaInput[]
    connectOrCreate?: PagoCreateOrConnectWithoutReservaInput | PagoCreateOrConnectWithoutReservaInput[]
    upsert?: PagoUpsertWithWhereUniqueWithoutReservaInput | PagoUpsertWithWhereUniqueWithoutReservaInput[]
    createMany?: PagoCreateManyReservaInputEnvelope
    set?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    disconnect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    delete?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    connect?: PagoWhereUniqueInput | PagoWhereUniqueInput[]
    update?: PagoUpdateWithWhereUniqueWithoutReservaInput | PagoUpdateWithWhereUniqueWithoutReservaInput[]
    updateMany?: PagoUpdateManyWithWhereWithoutReservaInput | PagoUpdateManyWithWhereWithoutReservaInput[]
    deleteMany?: PagoScalarWhereInput | PagoScalarWhereInput[]
  }

  export type ItinerarioLugarCreateNestedManyWithoutItinerarioReservaInput = {
    create?: XOR<ItinerarioLugarCreateWithoutItinerarioReservaInput, ItinerarioLugarUncheckedCreateWithoutItinerarioReservaInput> | ItinerarioLugarCreateWithoutItinerarioReservaInput[] | ItinerarioLugarUncheckedCreateWithoutItinerarioReservaInput[]
    connectOrCreate?: ItinerarioLugarCreateOrConnectWithoutItinerarioReservaInput | ItinerarioLugarCreateOrConnectWithoutItinerarioReservaInput[]
    createMany?: ItinerarioLugarCreateManyItinerarioReservaInputEnvelope
    connect?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
  }

  export type ReservaCreateNestedOneWithoutItinerariosInput = {
    create?: XOR<ReservaCreateWithoutItinerariosInput, ReservaUncheckedCreateWithoutItinerariosInput>
    connectOrCreate?: ReservaCreateOrConnectWithoutItinerariosInput
    connect?: ReservaWhereUniqueInput
  }

  export type ServicioCreateNestedOneWithoutItinerariosReservaInput = {
    create?: XOR<ServicioCreateWithoutItinerariosReservaInput, ServicioUncheckedCreateWithoutItinerariosReservaInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutItinerariosReservaInput
    connect?: ServicioWhereUniqueInput
  }

  export type ItinerarioLugarUncheckedCreateNestedManyWithoutItinerarioReservaInput = {
    create?: XOR<ItinerarioLugarCreateWithoutItinerarioReservaInput, ItinerarioLugarUncheckedCreateWithoutItinerarioReservaInput> | ItinerarioLugarCreateWithoutItinerarioReservaInput[] | ItinerarioLugarUncheckedCreateWithoutItinerarioReservaInput[]
    connectOrCreate?: ItinerarioLugarCreateOrConnectWithoutItinerarioReservaInput | ItinerarioLugarCreateOrConnectWithoutItinerarioReservaInput[]
    createMany?: ItinerarioLugarCreateManyItinerarioReservaInputEnvelope
    connect?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
  }

  export type ItinerarioLugarUpdateManyWithoutItinerarioReservaNestedInput = {
    create?: XOR<ItinerarioLugarCreateWithoutItinerarioReservaInput, ItinerarioLugarUncheckedCreateWithoutItinerarioReservaInput> | ItinerarioLugarCreateWithoutItinerarioReservaInput[] | ItinerarioLugarUncheckedCreateWithoutItinerarioReservaInput[]
    connectOrCreate?: ItinerarioLugarCreateOrConnectWithoutItinerarioReservaInput | ItinerarioLugarCreateOrConnectWithoutItinerarioReservaInput[]
    upsert?: ItinerarioLugarUpsertWithWhereUniqueWithoutItinerarioReservaInput | ItinerarioLugarUpsertWithWhereUniqueWithoutItinerarioReservaInput[]
    createMany?: ItinerarioLugarCreateManyItinerarioReservaInputEnvelope
    set?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    disconnect?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    delete?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    connect?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    update?: ItinerarioLugarUpdateWithWhereUniqueWithoutItinerarioReservaInput | ItinerarioLugarUpdateWithWhereUniqueWithoutItinerarioReservaInput[]
    updateMany?: ItinerarioLugarUpdateManyWithWhereWithoutItinerarioReservaInput | ItinerarioLugarUpdateManyWithWhereWithoutItinerarioReservaInput[]
    deleteMany?: ItinerarioLugarScalarWhereInput | ItinerarioLugarScalarWhereInput[]
  }

  export type ReservaUpdateOneRequiredWithoutItinerariosNestedInput = {
    create?: XOR<ReservaCreateWithoutItinerariosInput, ReservaUncheckedCreateWithoutItinerariosInput>
    connectOrCreate?: ReservaCreateOrConnectWithoutItinerariosInput
    upsert?: ReservaUpsertWithoutItinerariosInput
    connect?: ReservaWhereUniqueInput
    update?: XOR<XOR<ReservaUpdateToOneWithWhereWithoutItinerariosInput, ReservaUpdateWithoutItinerariosInput>, ReservaUncheckedUpdateWithoutItinerariosInput>
  }

  export type ServicioUpdateOneWithoutItinerariosReservaNestedInput = {
    create?: XOR<ServicioCreateWithoutItinerariosReservaInput, ServicioUncheckedCreateWithoutItinerariosReservaInput>
    connectOrCreate?: ServicioCreateOrConnectWithoutItinerariosReservaInput
    upsert?: ServicioUpsertWithoutItinerariosReservaInput
    disconnect?: ServicioWhereInput | boolean
    delete?: ServicioWhereInput | boolean
    connect?: ServicioWhereUniqueInput
    update?: XOR<XOR<ServicioUpdateToOneWithWhereWithoutItinerariosReservaInput, ServicioUpdateWithoutItinerariosReservaInput>, ServicioUncheckedUpdateWithoutItinerariosReservaInput>
  }

  export type ItinerarioLugarUncheckedUpdateManyWithoutItinerarioReservaNestedInput = {
    create?: XOR<ItinerarioLugarCreateWithoutItinerarioReservaInput, ItinerarioLugarUncheckedCreateWithoutItinerarioReservaInput> | ItinerarioLugarCreateWithoutItinerarioReservaInput[] | ItinerarioLugarUncheckedCreateWithoutItinerarioReservaInput[]
    connectOrCreate?: ItinerarioLugarCreateOrConnectWithoutItinerarioReservaInput | ItinerarioLugarCreateOrConnectWithoutItinerarioReservaInput[]
    upsert?: ItinerarioLugarUpsertWithWhereUniqueWithoutItinerarioReservaInput | ItinerarioLugarUpsertWithWhereUniqueWithoutItinerarioReservaInput[]
    createMany?: ItinerarioLugarCreateManyItinerarioReservaInputEnvelope
    set?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    disconnect?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    delete?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    connect?: ItinerarioLugarWhereUniqueInput | ItinerarioLugarWhereUniqueInput[]
    update?: ItinerarioLugarUpdateWithWhereUniqueWithoutItinerarioReservaInput | ItinerarioLugarUpdateWithWhereUniqueWithoutItinerarioReservaInput[]
    updateMany?: ItinerarioLugarUpdateManyWithWhereWithoutItinerarioReservaInput | ItinerarioLugarUpdateManyWithWhereWithoutItinerarioReservaInput[]
    deleteMany?: ItinerarioLugarScalarWhereInput | ItinerarioLugarScalarWhereInput[]
  }

  export type ItinerarioReservaCreateNestedOneWithoutItinerarioLugaresInput = {
    create?: XOR<ItinerarioReservaCreateWithoutItinerarioLugaresInput, ItinerarioReservaUncheckedCreateWithoutItinerarioLugaresInput>
    connectOrCreate?: ItinerarioReservaCreateOrConnectWithoutItinerarioLugaresInput
    connect?: ItinerarioReservaWhereUniqueInput
  }

  export type LugarTuristicoCreateNestedOneWithoutItinerarioLugaresInput = {
    create?: XOR<LugarTuristicoCreateWithoutItinerarioLugaresInput, LugarTuristicoUncheckedCreateWithoutItinerarioLugaresInput>
    connectOrCreate?: LugarTuristicoCreateOrConnectWithoutItinerarioLugaresInput
    connect?: LugarTuristicoWhereUniqueInput
  }

  export type ItinerarioReservaUpdateOneRequiredWithoutItinerarioLugaresNestedInput = {
    create?: XOR<ItinerarioReservaCreateWithoutItinerarioLugaresInput, ItinerarioReservaUncheckedCreateWithoutItinerarioLugaresInput>
    connectOrCreate?: ItinerarioReservaCreateOrConnectWithoutItinerarioLugaresInput
    upsert?: ItinerarioReservaUpsertWithoutItinerarioLugaresInput
    connect?: ItinerarioReservaWhereUniqueInput
    update?: XOR<XOR<ItinerarioReservaUpdateToOneWithWhereWithoutItinerarioLugaresInput, ItinerarioReservaUpdateWithoutItinerarioLugaresInput>, ItinerarioReservaUncheckedUpdateWithoutItinerarioLugaresInput>
  }

  export type LugarTuristicoUpdateOneRequiredWithoutItinerarioLugaresNestedInput = {
    create?: XOR<LugarTuristicoCreateWithoutItinerarioLugaresInput, LugarTuristicoUncheckedCreateWithoutItinerarioLugaresInput>
    connectOrCreate?: LugarTuristicoCreateOrConnectWithoutItinerarioLugaresInput
    upsert?: LugarTuristicoUpsertWithoutItinerarioLugaresInput
    connect?: LugarTuristicoWhereUniqueInput
    update?: XOR<XOR<LugarTuristicoUpdateToOneWithWhereWithoutItinerarioLugaresInput, LugarTuristicoUpdateWithoutItinerarioLugaresInput>, LugarTuristicoUncheckedUpdateWithoutItinerarioLugaresInput>
  }

  export type ComprobanteCreateNestedOneWithoutPagoInput = {
    create?: XOR<ComprobanteCreateWithoutPagoInput, ComprobanteUncheckedCreateWithoutPagoInput>
    connectOrCreate?: ComprobanteCreateOrConnectWithoutPagoInput
    connect?: ComprobanteWhereUniqueInput
  }

  export type ReservaCreateNestedOneWithoutPagosInput = {
    create?: XOR<ReservaCreateWithoutPagosInput, ReservaUncheckedCreateWithoutPagosInput>
    connectOrCreate?: ReservaCreateOrConnectWithoutPagosInput
    connect?: ReservaWhereUniqueInput
  }

  export type PagoDetalleCreateNestedManyWithoutPagoInput = {
    create?: XOR<PagoDetalleCreateWithoutPagoInput, PagoDetalleUncheckedCreateWithoutPagoInput> | PagoDetalleCreateWithoutPagoInput[] | PagoDetalleUncheckedCreateWithoutPagoInput[]
    connectOrCreate?: PagoDetalleCreateOrConnectWithoutPagoInput | PagoDetalleCreateOrConnectWithoutPagoInput[]
    createMany?: PagoDetalleCreateManyPagoInputEnvelope
    connect?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
  }

  export type ComprobanteUncheckedCreateNestedOneWithoutPagoInput = {
    create?: XOR<ComprobanteCreateWithoutPagoInput, ComprobanteUncheckedCreateWithoutPagoInput>
    connectOrCreate?: ComprobanteCreateOrConnectWithoutPagoInput
    connect?: ComprobanteWhereUniqueInput
  }

  export type PagoDetalleUncheckedCreateNestedManyWithoutPagoInput = {
    create?: XOR<PagoDetalleCreateWithoutPagoInput, PagoDetalleUncheckedCreateWithoutPagoInput> | PagoDetalleCreateWithoutPagoInput[] | PagoDetalleUncheckedCreateWithoutPagoInput[]
    connectOrCreate?: PagoDetalleCreateOrConnectWithoutPagoInput | PagoDetalleCreateOrConnectWithoutPagoInput[]
    createMany?: PagoDetalleCreateManyPagoInputEnvelope
    connect?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
  }

  export type ComprobanteUpdateOneWithoutPagoNestedInput = {
    create?: XOR<ComprobanteCreateWithoutPagoInput, ComprobanteUncheckedCreateWithoutPagoInput>
    connectOrCreate?: ComprobanteCreateOrConnectWithoutPagoInput
    upsert?: ComprobanteUpsertWithoutPagoInput
    disconnect?: ComprobanteWhereInput | boolean
    delete?: ComprobanteWhereInput | boolean
    connect?: ComprobanteWhereUniqueInput
    update?: XOR<XOR<ComprobanteUpdateToOneWithWhereWithoutPagoInput, ComprobanteUpdateWithoutPagoInput>, ComprobanteUncheckedUpdateWithoutPagoInput>
  }

  export type ReservaUpdateOneRequiredWithoutPagosNestedInput = {
    create?: XOR<ReservaCreateWithoutPagosInput, ReservaUncheckedCreateWithoutPagosInput>
    connectOrCreate?: ReservaCreateOrConnectWithoutPagosInput
    upsert?: ReservaUpsertWithoutPagosInput
    connect?: ReservaWhereUniqueInput
    update?: XOR<XOR<ReservaUpdateToOneWithWhereWithoutPagosInput, ReservaUpdateWithoutPagosInput>, ReservaUncheckedUpdateWithoutPagosInput>
  }

  export type PagoDetalleUpdateManyWithoutPagoNestedInput = {
    create?: XOR<PagoDetalleCreateWithoutPagoInput, PagoDetalleUncheckedCreateWithoutPagoInput> | PagoDetalleCreateWithoutPagoInput[] | PagoDetalleUncheckedCreateWithoutPagoInput[]
    connectOrCreate?: PagoDetalleCreateOrConnectWithoutPagoInput | PagoDetalleCreateOrConnectWithoutPagoInput[]
    upsert?: PagoDetalleUpsertWithWhereUniqueWithoutPagoInput | PagoDetalleUpsertWithWhereUniqueWithoutPagoInput[]
    createMany?: PagoDetalleCreateManyPagoInputEnvelope
    set?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    disconnect?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    delete?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    connect?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    update?: PagoDetalleUpdateWithWhereUniqueWithoutPagoInput | PagoDetalleUpdateWithWhereUniqueWithoutPagoInput[]
    updateMany?: PagoDetalleUpdateManyWithWhereWithoutPagoInput | PagoDetalleUpdateManyWithWhereWithoutPagoInput[]
    deleteMany?: PagoDetalleScalarWhereInput | PagoDetalleScalarWhereInput[]
  }

  export type ComprobanteUncheckedUpdateOneWithoutPagoNestedInput = {
    create?: XOR<ComprobanteCreateWithoutPagoInput, ComprobanteUncheckedCreateWithoutPagoInput>
    connectOrCreate?: ComprobanteCreateOrConnectWithoutPagoInput
    upsert?: ComprobanteUpsertWithoutPagoInput
    disconnect?: ComprobanteWhereInput | boolean
    delete?: ComprobanteWhereInput | boolean
    connect?: ComprobanteWhereUniqueInput
    update?: XOR<XOR<ComprobanteUpdateToOneWithWhereWithoutPagoInput, ComprobanteUpdateWithoutPagoInput>, ComprobanteUncheckedUpdateWithoutPagoInput>
  }

  export type PagoDetalleUncheckedUpdateManyWithoutPagoNestedInput = {
    create?: XOR<PagoDetalleCreateWithoutPagoInput, PagoDetalleUncheckedCreateWithoutPagoInput> | PagoDetalleCreateWithoutPagoInput[] | PagoDetalleUncheckedCreateWithoutPagoInput[]
    connectOrCreate?: PagoDetalleCreateOrConnectWithoutPagoInput | PagoDetalleCreateOrConnectWithoutPagoInput[]
    upsert?: PagoDetalleUpsertWithWhereUniqueWithoutPagoInput | PagoDetalleUpsertWithWhereUniqueWithoutPagoInput[]
    createMany?: PagoDetalleCreateManyPagoInputEnvelope
    set?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    disconnect?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    delete?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    connect?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    update?: PagoDetalleUpdateWithWhereUniqueWithoutPagoInput | PagoDetalleUpdateWithWhereUniqueWithoutPagoInput[]
    updateMany?: PagoDetalleUpdateManyWithWhereWithoutPagoInput | PagoDetalleUpdateManyWithWhereWithoutPagoInput[]
    deleteMany?: PagoDetalleScalarWhereInput | PagoDetalleScalarWhereInput[]
  }

  export type PagoCreateNestedOneWithoutDetallesInput = {
    create?: XOR<PagoCreateWithoutDetallesInput, PagoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: PagoCreateOrConnectWithoutDetallesInput
    connect?: PagoWhereUniqueInput
  }

  export type TipoPagoCreateNestedOneWithoutPagoDetallesInput = {
    create?: XOR<TipoPagoCreateWithoutPagoDetallesInput, TipoPagoUncheckedCreateWithoutPagoDetallesInput>
    connectOrCreate?: TipoPagoCreateOrConnectWithoutPagoDetallesInput
    connect?: TipoPagoWhereUniqueInput
  }

  export type PagoUpdateOneRequiredWithoutDetallesNestedInput = {
    create?: XOR<PagoCreateWithoutDetallesInput, PagoUncheckedCreateWithoutDetallesInput>
    connectOrCreate?: PagoCreateOrConnectWithoutDetallesInput
    upsert?: PagoUpsertWithoutDetallesInput
    connect?: PagoWhereUniqueInput
    update?: XOR<XOR<PagoUpdateToOneWithWhereWithoutDetallesInput, PagoUpdateWithoutDetallesInput>, PagoUncheckedUpdateWithoutDetallesInput>
  }

  export type TipoPagoUpdateOneRequiredWithoutPagoDetallesNestedInput = {
    create?: XOR<TipoPagoCreateWithoutPagoDetallesInput, TipoPagoUncheckedCreateWithoutPagoDetallesInput>
    connectOrCreate?: TipoPagoCreateOrConnectWithoutPagoDetallesInput
    upsert?: TipoPagoUpsertWithoutPagoDetallesInput
    connect?: TipoPagoWhereUniqueInput
    update?: XOR<XOR<TipoPagoUpdateToOneWithWhereWithoutPagoDetallesInput, TipoPagoUpdateWithoutPagoDetallesInput>, TipoPagoUncheckedUpdateWithoutPagoDetallesInput>
  }

  export type PagoDetalleCreateNestedManyWithoutTipoPagoInput = {
    create?: XOR<PagoDetalleCreateWithoutTipoPagoInput, PagoDetalleUncheckedCreateWithoutTipoPagoInput> | PagoDetalleCreateWithoutTipoPagoInput[] | PagoDetalleUncheckedCreateWithoutTipoPagoInput[]
    connectOrCreate?: PagoDetalleCreateOrConnectWithoutTipoPagoInput | PagoDetalleCreateOrConnectWithoutTipoPagoInput[]
    createMany?: PagoDetalleCreateManyTipoPagoInputEnvelope
    connect?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
  }

  export type PagoDetalleUncheckedCreateNestedManyWithoutTipoPagoInput = {
    create?: XOR<PagoDetalleCreateWithoutTipoPagoInput, PagoDetalleUncheckedCreateWithoutTipoPagoInput> | PagoDetalleCreateWithoutTipoPagoInput[] | PagoDetalleUncheckedCreateWithoutTipoPagoInput[]
    connectOrCreate?: PagoDetalleCreateOrConnectWithoutTipoPagoInput | PagoDetalleCreateOrConnectWithoutTipoPagoInput[]
    createMany?: PagoDetalleCreateManyTipoPagoInputEnvelope
    connect?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
  }

  export type PagoDetalleUpdateManyWithoutTipoPagoNestedInput = {
    create?: XOR<PagoDetalleCreateWithoutTipoPagoInput, PagoDetalleUncheckedCreateWithoutTipoPagoInput> | PagoDetalleCreateWithoutTipoPagoInput[] | PagoDetalleUncheckedCreateWithoutTipoPagoInput[]
    connectOrCreate?: PagoDetalleCreateOrConnectWithoutTipoPagoInput | PagoDetalleCreateOrConnectWithoutTipoPagoInput[]
    upsert?: PagoDetalleUpsertWithWhereUniqueWithoutTipoPagoInput | PagoDetalleUpsertWithWhereUniqueWithoutTipoPagoInput[]
    createMany?: PagoDetalleCreateManyTipoPagoInputEnvelope
    set?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    disconnect?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    delete?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    connect?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    update?: PagoDetalleUpdateWithWhereUniqueWithoutTipoPagoInput | PagoDetalleUpdateWithWhereUniqueWithoutTipoPagoInput[]
    updateMany?: PagoDetalleUpdateManyWithWhereWithoutTipoPagoInput | PagoDetalleUpdateManyWithWhereWithoutTipoPagoInput[]
    deleteMany?: PagoDetalleScalarWhereInput | PagoDetalleScalarWhereInput[]
  }

  export type PagoDetalleUncheckedUpdateManyWithoutTipoPagoNestedInput = {
    create?: XOR<PagoDetalleCreateWithoutTipoPagoInput, PagoDetalleUncheckedCreateWithoutTipoPagoInput> | PagoDetalleCreateWithoutTipoPagoInput[] | PagoDetalleUncheckedCreateWithoutTipoPagoInput[]
    connectOrCreate?: PagoDetalleCreateOrConnectWithoutTipoPagoInput | PagoDetalleCreateOrConnectWithoutTipoPagoInput[]
    upsert?: PagoDetalleUpsertWithWhereUniqueWithoutTipoPagoInput | PagoDetalleUpsertWithWhereUniqueWithoutTipoPagoInput[]
    createMany?: PagoDetalleCreateManyTipoPagoInputEnvelope
    set?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    disconnect?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    delete?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    connect?: PagoDetalleWhereUniqueInput | PagoDetalleWhereUniqueInput[]
    update?: PagoDetalleUpdateWithWhereUniqueWithoutTipoPagoInput | PagoDetalleUpdateWithWhereUniqueWithoutTipoPagoInput[]
    updateMany?: PagoDetalleUpdateManyWithWhereWithoutTipoPagoInput | PagoDetalleUpdateManyWithWhereWithoutTipoPagoInput[]
    deleteMany?: PagoDetalleScalarWhereInput | PagoDetalleScalarWhereInput[]
  }

  export type PagoCreateNestedOneWithoutComprobanteInput = {
    create?: XOR<PagoCreateWithoutComprobanteInput, PagoUncheckedCreateWithoutComprobanteInput>
    connectOrCreate?: PagoCreateOrConnectWithoutComprobanteInput
    connect?: PagoWhereUniqueInput
  }

  export type PagoUpdateOneRequiredWithoutComprobanteNestedInput = {
    create?: XOR<PagoCreateWithoutComprobanteInput, PagoUncheckedCreateWithoutComprobanteInput>
    connectOrCreate?: PagoCreateOrConnectWithoutComprobanteInput
    upsert?: PagoUpsertWithoutComprobanteInput
    connect?: PagoWhereUniqueInput
    update?: XOR<XOR<PagoUpdateToOneWithWhereWithoutComprobanteInput, PagoUpdateWithoutComprobanteInput>, PagoUncheckedUpdateWithoutComprobanteInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type RolesPermisosCreateWithoutRolInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    permiso: PermisoCreateNestedOneWithoutRolesPermisosInput
  }

  export type RolesPermisosUncheckedCreateWithoutRolInput = {
    id?: number
    permisoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolesPermisosCreateOrConnectWithoutRolInput = {
    where: RolesPermisosWhereUniqueInput
    create: XOR<RolesPermisosCreateWithoutRolInput, RolesPermisosUncheckedCreateWithoutRolInput>
  }

  export type RolesPermisosCreateManyRolInputEnvelope = {
    data: RolesPermisosCreateManyRolInput | RolesPermisosCreateManyRolInput[]
    skipDuplicates?: boolean
  }

  export type UsuariosRolesCreateWithoutRolInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutUsuariosRolesInput
  }

  export type UsuariosRolesUncheckedCreateWithoutRolInput = {
    id?: number
    usuarioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuariosRolesCreateOrConnectWithoutRolInput = {
    where: UsuariosRolesWhereUniqueInput
    create: XOR<UsuariosRolesCreateWithoutRolInput, UsuariosRolesUncheckedCreateWithoutRolInput>
  }

  export type UsuariosRolesCreateManyRolInputEnvelope = {
    data: UsuariosRolesCreateManyRolInput | UsuariosRolesCreateManyRolInput[]
    skipDuplicates?: boolean
  }

  export type RolesPermisosUpsertWithWhereUniqueWithoutRolInput = {
    where: RolesPermisosWhereUniqueInput
    update: XOR<RolesPermisosUpdateWithoutRolInput, RolesPermisosUncheckedUpdateWithoutRolInput>
    create: XOR<RolesPermisosCreateWithoutRolInput, RolesPermisosUncheckedCreateWithoutRolInput>
  }

  export type RolesPermisosUpdateWithWhereUniqueWithoutRolInput = {
    where: RolesPermisosWhereUniqueInput
    data: XOR<RolesPermisosUpdateWithoutRolInput, RolesPermisosUncheckedUpdateWithoutRolInput>
  }

  export type RolesPermisosUpdateManyWithWhereWithoutRolInput = {
    where: RolesPermisosScalarWhereInput
    data: XOR<RolesPermisosUpdateManyMutationInput, RolesPermisosUncheckedUpdateManyWithoutRolInput>
  }

  export type RolesPermisosScalarWhereInput = {
    AND?: RolesPermisosScalarWhereInput | RolesPermisosScalarWhereInput[]
    OR?: RolesPermisosScalarWhereInput[]
    NOT?: RolesPermisosScalarWhereInput | RolesPermisosScalarWhereInput[]
    id?: IntFilter<"RolesPermisos"> | number
    rolId?: IntFilter<"RolesPermisos"> | number
    permisoId?: IntFilter<"RolesPermisos"> | number
    createdAt?: DateTimeFilter<"RolesPermisos"> | Date | string
    updatedAt?: DateTimeFilter<"RolesPermisos"> | Date | string
  }

  export type UsuariosRolesUpsertWithWhereUniqueWithoutRolInput = {
    where: UsuariosRolesWhereUniqueInput
    update: XOR<UsuariosRolesUpdateWithoutRolInput, UsuariosRolesUncheckedUpdateWithoutRolInput>
    create: XOR<UsuariosRolesCreateWithoutRolInput, UsuariosRolesUncheckedCreateWithoutRolInput>
  }

  export type UsuariosRolesUpdateWithWhereUniqueWithoutRolInput = {
    where: UsuariosRolesWhereUniqueInput
    data: XOR<UsuariosRolesUpdateWithoutRolInput, UsuariosRolesUncheckedUpdateWithoutRolInput>
  }

  export type UsuariosRolesUpdateManyWithWhereWithoutRolInput = {
    where: UsuariosRolesScalarWhereInput
    data: XOR<UsuariosRolesUpdateManyMutationInput, UsuariosRolesUncheckedUpdateManyWithoutRolInput>
  }

  export type UsuariosRolesScalarWhereInput = {
    AND?: UsuariosRolesScalarWhereInput | UsuariosRolesScalarWhereInput[]
    OR?: UsuariosRolesScalarWhereInput[]
    NOT?: UsuariosRolesScalarWhereInput | UsuariosRolesScalarWhereInput[]
    id?: IntFilter<"UsuariosRoles"> | number
    rolId?: IntFilter<"UsuariosRoles"> | number
    usuarioId?: IntFilter<"UsuariosRoles"> | number
    createdAt?: DateTimeFilter<"UsuariosRoles"> | Date | string
    updatedAt?: DateTimeFilter<"UsuariosRoles"> | Date | string
  }

  export type RolesPermisosCreateWithoutPermisoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    rol: RoleCreateNestedOneWithoutRolesPermisosInput
  }

  export type RolesPermisosUncheckedCreateWithoutPermisoInput = {
    id?: number
    rolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolesPermisosCreateOrConnectWithoutPermisoInput = {
    where: RolesPermisosWhereUniqueInput
    create: XOR<RolesPermisosCreateWithoutPermisoInput, RolesPermisosUncheckedCreateWithoutPermisoInput>
  }

  export type RolesPermisosCreateManyPermisoInputEnvelope = {
    data: RolesPermisosCreateManyPermisoInput | RolesPermisosCreateManyPermisoInput[]
    skipDuplicates?: boolean
  }

  export type RolesPermisosUpsertWithWhereUniqueWithoutPermisoInput = {
    where: RolesPermisosWhereUniqueInput
    update: XOR<RolesPermisosUpdateWithoutPermisoInput, RolesPermisosUncheckedUpdateWithoutPermisoInput>
    create: XOR<RolesPermisosCreateWithoutPermisoInput, RolesPermisosUncheckedCreateWithoutPermisoInput>
  }

  export type RolesPermisosUpdateWithWhereUniqueWithoutPermisoInput = {
    where: RolesPermisosWhereUniqueInput
    data: XOR<RolesPermisosUpdateWithoutPermisoInput, RolesPermisosUncheckedUpdateWithoutPermisoInput>
  }

  export type RolesPermisosUpdateManyWithWhereWithoutPermisoInput = {
    where: RolesPermisosScalarWhereInput
    data: XOR<RolesPermisosUpdateManyMutationInput, RolesPermisosUncheckedUpdateManyWithoutPermisoInput>
  }

  export type PermisoCreateWithoutRolesPermisosInput = {
    nombre: string
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermisoUncheckedCreateWithoutRolesPermisosInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermisoCreateOrConnectWithoutRolesPermisosInput = {
    where: PermisoWhereUniqueInput
    create: XOR<PermisoCreateWithoutRolesPermisosInput, PermisoUncheckedCreateWithoutRolesPermisosInput>
  }

  export type RoleCreateWithoutRolesPermisosInput = {
    nombre: string
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usuariosRoles?: UsuariosRolesCreateNestedManyWithoutRolInput
  }

  export type RoleUncheckedCreateWithoutRolesPermisosInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usuariosRoles?: UsuariosRolesUncheckedCreateNestedManyWithoutRolInput
  }

  export type RoleCreateOrConnectWithoutRolesPermisosInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutRolesPermisosInput, RoleUncheckedCreateWithoutRolesPermisosInput>
  }

  export type PermisoUpsertWithoutRolesPermisosInput = {
    update: XOR<PermisoUpdateWithoutRolesPermisosInput, PermisoUncheckedUpdateWithoutRolesPermisosInput>
    create: XOR<PermisoCreateWithoutRolesPermisosInput, PermisoUncheckedCreateWithoutRolesPermisosInput>
    where?: PermisoWhereInput
  }

  export type PermisoUpdateToOneWithWhereWithoutRolesPermisosInput = {
    where?: PermisoWhereInput
    data: XOR<PermisoUpdateWithoutRolesPermisosInput, PermisoUncheckedUpdateWithoutRolesPermisosInput>
  }

  export type PermisoUpdateWithoutRolesPermisosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermisoUncheckedUpdateWithoutRolesPermisosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpsertWithoutRolesPermisosInput = {
    update: XOR<RoleUpdateWithoutRolesPermisosInput, RoleUncheckedUpdateWithoutRolesPermisosInput>
    create: XOR<RoleCreateWithoutRolesPermisosInput, RoleUncheckedCreateWithoutRolesPermisosInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutRolesPermisosInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutRolesPermisosInput, RoleUncheckedUpdateWithoutRolesPermisosInput>
  }

  export type RoleUpdateWithoutRolesPermisosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosRoles?: UsuariosRolesUpdateManyWithoutRolNestedInput
  }

  export type RoleUncheckedUpdateWithoutRolesPermisosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosRoles?: UsuariosRolesUncheckedUpdateManyWithoutRolNestedInput
  }

  export type SubdivisionCreateWithoutCountryInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoCreateNestedManyWithoutSubdivisionInput
    personas?: PersonaCreateNestedManyWithoutSubdivisionInput
  }

  export type SubdivisionUncheckedCreateWithoutCountryInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutSubdivisionInput
    personas?: PersonaUncheckedCreateNestedManyWithoutSubdivisionInput
  }

  export type SubdivisionCreateOrConnectWithoutCountryInput = {
    where: SubdivisionWhereUniqueInput
    create: XOR<SubdivisionCreateWithoutCountryInput, SubdivisionUncheckedCreateWithoutCountryInput>
  }

  export type SubdivisionCreateManyCountryInputEnvelope = {
    data: SubdivisionCreateManyCountryInput | SubdivisionCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type SubdivisionUpsertWithWhereUniqueWithoutCountryInput = {
    where: SubdivisionWhereUniqueInput
    update: XOR<SubdivisionUpdateWithoutCountryInput, SubdivisionUncheckedUpdateWithoutCountryInput>
    create: XOR<SubdivisionCreateWithoutCountryInput, SubdivisionUncheckedCreateWithoutCountryInput>
  }

  export type SubdivisionUpdateWithWhereUniqueWithoutCountryInput = {
    where: SubdivisionWhereUniqueInput
    data: XOR<SubdivisionUpdateWithoutCountryInput, SubdivisionUncheckedUpdateWithoutCountryInput>
  }

  export type SubdivisionUpdateManyWithWhereWithoutCountryInput = {
    where: SubdivisionScalarWhereInput
    data: XOR<SubdivisionUpdateManyMutationInput, SubdivisionUncheckedUpdateManyWithoutCountryInput>
  }

  export type SubdivisionScalarWhereInput = {
    AND?: SubdivisionScalarWhereInput | SubdivisionScalarWhereInput[]
    OR?: SubdivisionScalarWhereInput[]
    NOT?: SubdivisionScalarWhereInput | SubdivisionScalarWhereInput[]
    id?: IntFilter<"Subdivision"> | number
    countryId?: IntFilter<"Subdivision"> | number
    name?: StringFilter<"Subdivision"> | string
    createdAt?: DateTimeFilter<"Subdivision"> | Date | string
    updatedAt?: DateTimeFilter<"Subdivision"> | Date | string
  }

  export type EmprendimientoCreateWithoutSubdivisionInput = {
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutEmprendimientosInput
    favoritos?: FavoritoCreateNestedManyWithoutEmprendimientoInput
    paquetesTuristicos?: PaqueteTuristicoCreateNestedManyWithoutEmprendimientoInput
    servicios?: ServicioEmprendedorCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateWithoutSubdivisionInput = {
    id?: number
    usuarioId: number
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutEmprendimientoInput
    paquetesTuristicos?: PaqueteTuristicoUncheckedCreateNestedManyWithoutEmprendimientoInput
    servicios?: ServicioEmprendedorUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoCreateOrConnectWithoutSubdivisionInput = {
    where: EmprendimientoWhereUniqueInput
    create: XOR<EmprendimientoCreateWithoutSubdivisionInput, EmprendimientoUncheckedCreateWithoutSubdivisionInput>
  }

  export type EmprendimientoCreateManySubdivisionInputEnvelope = {
    data: EmprendimientoCreateManySubdivisionInput | EmprendimientoCreateManySubdivisionInput[]
    skipDuplicates?: boolean
  }

  export type PersonaCreateWithoutSubdivisionInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    direccion?: string | null
    fotoPerfilUrl?: string | null
    fechaNacimiento?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario?: UsuarioCreateNestedOneWithoutPersonaInput
  }

  export type PersonaUncheckedCreateWithoutSubdivisionInput = {
    id?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    direccion?: string | null
    fotoPerfilUrl?: string | null
    fechaNacimiento?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    usuario?: UsuarioUncheckedCreateNestedOneWithoutPersonaInput
  }

  export type PersonaCreateOrConnectWithoutSubdivisionInput = {
    where: PersonaWhereUniqueInput
    create: XOR<PersonaCreateWithoutSubdivisionInput, PersonaUncheckedCreateWithoutSubdivisionInput>
  }

  export type PersonaCreateManySubdivisionInputEnvelope = {
    data: PersonaCreateManySubdivisionInput | PersonaCreateManySubdivisionInput[]
    skipDuplicates?: boolean
  }

  export type CountryCreateWithoutSubdivisionsInput = {
    name: string
    codeIso: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryUncheckedCreateWithoutSubdivisionsInput = {
    id?: number
    name: string
    codeIso: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CountryCreateOrConnectWithoutSubdivisionsInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutSubdivisionsInput, CountryUncheckedCreateWithoutSubdivisionsInput>
  }

  export type EmprendimientoUpsertWithWhereUniqueWithoutSubdivisionInput = {
    where: EmprendimientoWhereUniqueInput
    update: XOR<EmprendimientoUpdateWithoutSubdivisionInput, EmprendimientoUncheckedUpdateWithoutSubdivisionInput>
    create: XOR<EmprendimientoCreateWithoutSubdivisionInput, EmprendimientoUncheckedCreateWithoutSubdivisionInput>
  }

  export type EmprendimientoUpdateWithWhereUniqueWithoutSubdivisionInput = {
    where: EmprendimientoWhereUniqueInput
    data: XOR<EmprendimientoUpdateWithoutSubdivisionInput, EmprendimientoUncheckedUpdateWithoutSubdivisionInput>
  }

  export type EmprendimientoUpdateManyWithWhereWithoutSubdivisionInput = {
    where: EmprendimientoScalarWhereInput
    data: XOR<EmprendimientoUpdateManyMutationInput, EmprendimientoUncheckedUpdateManyWithoutSubdivisionInput>
  }

  export type EmprendimientoScalarWhereInput = {
    AND?: EmprendimientoScalarWhereInput | EmprendimientoScalarWhereInput[]
    OR?: EmprendimientoScalarWhereInput[]
    NOT?: EmprendimientoScalarWhereInput | EmprendimientoScalarWhereInput[]
    id?: IntFilter<"Emprendimiento"> | number
    usuarioId?: IntFilter<"Emprendimiento"> | number
    nombre?: StringFilter<"Emprendimiento"> | string
    descripcion?: StringNullableFilter<"Emprendimiento"> | string | null
    tipo?: StringFilter<"Emprendimiento"> | string
    direccion?: StringNullableFilter<"Emprendimiento"> | string | null
    subdivisionId?: IntNullableFilter<"Emprendimiento"> | number | null
    coordenadas?: StringNullableFilter<"Emprendimiento"> | string | null
    contactoTelefono?: StringNullableFilter<"Emprendimiento"> | string | null
    contactoEmail?: StringNullableFilter<"Emprendimiento"> | string | null
    sitioWeb?: StringNullableFilter<"Emprendimiento"> | string | null
    redesSociales?: JsonNullableFilter<"Emprendimiento">
    estado?: StringFilter<"Emprendimiento"> | string
    fechaAprobacion?: DateTimeNullableFilter<"Emprendimiento"> | Date | string | null
    createdAt?: DateTimeFilter<"Emprendimiento"> | Date | string
    updatedAt?: DateTimeFilter<"Emprendimiento"> | Date | string
  }

  export type PersonaUpsertWithWhereUniqueWithoutSubdivisionInput = {
    where: PersonaWhereUniqueInput
    update: XOR<PersonaUpdateWithoutSubdivisionInput, PersonaUncheckedUpdateWithoutSubdivisionInput>
    create: XOR<PersonaCreateWithoutSubdivisionInput, PersonaUncheckedCreateWithoutSubdivisionInput>
  }

  export type PersonaUpdateWithWhereUniqueWithoutSubdivisionInput = {
    where: PersonaWhereUniqueInput
    data: XOR<PersonaUpdateWithoutSubdivisionInput, PersonaUncheckedUpdateWithoutSubdivisionInput>
  }

  export type PersonaUpdateManyWithWhereWithoutSubdivisionInput = {
    where: PersonaScalarWhereInput
    data: XOR<PersonaUpdateManyMutationInput, PersonaUncheckedUpdateManyWithoutSubdivisionInput>
  }

  export type PersonaScalarWhereInput = {
    AND?: PersonaScalarWhereInput | PersonaScalarWhereInput[]
    OR?: PersonaScalarWhereInput[]
    NOT?: PersonaScalarWhereInput | PersonaScalarWhereInput[]
    id?: IntFilter<"Persona"> | number
    nombre?: StringFilter<"Persona"> | string
    apellidos?: StringFilter<"Persona"> | string
    telefono?: StringNullableFilter<"Persona"> | string | null
    direccion?: StringNullableFilter<"Persona"> | string | null
    fotoPerfilUrl?: StringNullableFilter<"Persona"> | string | null
    fechaNacimiento?: DateTimeNullableFilter<"Persona"> | Date | string | null
    subdivisionId?: IntFilter<"Persona"> | number
    createdAt?: DateTimeFilter<"Persona"> | Date | string
    updatedAt?: DateTimeFilter<"Persona"> | Date | string
  }

  export type CountryUpsertWithoutSubdivisionsInput = {
    update: XOR<CountryUpdateWithoutSubdivisionsInput, CountryUncheckedUpdateWithoutSubdivisionsInput>
    create: XOR<CountryCreateWithoutSubdivisionsInput, CountryUncheckedCreateWithoutSubdivisionsInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutSubdivisionsInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutSubdivisionsInput, CountryUncheckedUpdateWithoutSubdivisionsInput>
  }

  export type CountryUpdateWithoutSubdivisionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    codeIso?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CountryUncheckedUpdateWithoutSubdivisionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    codeIso?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdivisionCreateWithoutPersonasInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoCreateNestedManyWithoutSubdivisionInput
    country: CountryCreateNestedOneWithoutSubdivisionsInput
  }

  export type SubdivisionUncheckedCreateWithoutPersonasInput = {
    id?: number
    countryId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutSubdivisionInput
  }

  export type SubdivisionCreateOrConnectWithoutPersonasInput = {
    where: SubdivisionWhereUniqueInput
    create: XOR<SubdivisionCreateWithoutPersonasInput, SubdivisionUncheckedCreateWithoutPersonasInput>
  }

  export type UsuarioCreateWithoutPersonaInput = {
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoCreateNestedManyWithoutUsuarioInput
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoCreateNestedManyWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPersonaInput = {
    id?: number
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoUncheckedCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoUncheckedCreateNestedManyWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPersonaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPersonaInput, UsuarioUncheckedCreateWithoutPersonaInput>
  }

  export type SubdivisionUpsertWithoutPersonasInput = {
    update: XOR<SubdivisionUpdateWithoutPersonasInput, SubdivisionUncheckedUpdateWithoutPersonasInput>
    create: XOR<SubdivisionCreateWithoutPersonasInput, SubdivisionUncheckedCreateWithoutPersonasInput>
    where?: SubdivisionWhereInput
  }

  export type SubdivisionUpdateToOneWithWhereWithoutPersonasInput = {
    where?: SubdivisionWhereInput
    data: XOR<SubdivisionUpdateWithoutPersonasInput, SubdivisionUncheckedUpdateWithoutPersonasInput>
  }

  export type SubdivisionUpdateWithoutPersonasInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUpdateManyWithoutSubdivisionNestedInput
    country?: CountryUpdateOneRequiredWithoutSubdivisionsNestedInput
  }

  export type SubdivisionUncheckedUpdateWithoutPersonasInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutSubdivisionNestedInput
  }

  export type UsuarioUpsertWithoutPersonaInput = {
    update: XOR<UsuarioUpdateWithoutPersonaInput, UsuarioUncheckedUpdateWithoutPersonaInput>
    create: XOR<UsuarioCreateWithoutPersonaInput, UsuarioUncheckedCreateWithoutPersonaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPersonaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPersonaInput, UsuarioUncheckedUpdateWithoutPersonaInput>
  }

  export type UsuarioUpdateWithoutPersonaInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUpdateManyWithoutUsuarioNestedInput
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUpdateManyWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPersonaInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUncheckedUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUncheckedUpdateManyWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type EmprendimientoCreateWithoutUsuarioInput = {
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subdivision?: SubdivisionCreateNestedOneWithoutEmprendimientosInput
    favoritos?: FavoritoCreateNestedManyWithoutEmprendimientoInput
    paquetesTuristicos?: PaqueteTuristicoCreateNestedManyWithoutEmprendimientoInput
    servicios?: ServicioEmprendedorCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    subdivisionId?: number | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutEmprendimientoInput
    paquetesTuristicos?: PaqueteTuristicoUncheckedCreateNestedManyWithoutEmprendimientoInput
    servicios?: ServicioEmprendedorUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoCreateOrConnectWithoutUsuarioInput = {
    where: EmprendimientoWhereUniqueInput
    create: XOR<EmprendimientoCreateWithoutUsuarioInput, EmprendimientoUncheckedCreateWithoutUsuarioInput>
  }

  export type EmprendimientoCreateManyUsuarioInputEnvelope = {
    data: EmprendimientoCreateManyUsuarioInput | EmprendimientoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type FavoritoCreateWithoutUsuarioInput = {
    estado?: string
    createdAt?: Date | string
    emprendimiento: EmprendimientoCreateNestedOneWithoutFavoritosInput
  }

  export type FavoritoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    estado?: string
    emprendimientoId: number
    createdAt?: Date | string
  }

  export type FavoritoCreateOrConnectWithoutUsuarioInput = {
    where: FavoritoWhereUniqueInput
    create: XOR<FavoritoCreateWithoutUsuarioInput, FavoritoUncheckedCreateWithoutUsuarioInput>
  }

  export type FavoritoCreateManyUsuarioInputEnvelope = {
    data: FavoritoCreateManyUsuarioInput | FavoritoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type RegistroAccesoCreateWithoutUsuarioInput = {
    ipAddress: string
    userAgent: string
    tipoEvento: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegistroAccesoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    ipAddress: string
    userAgent: string
    tipoEvento: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RegistroAccesoCreateOrConnectWithoutUsuarioInput = {
    where: RegistroAccesoWhereUniqueInput
    create: XOR<RegistroAccesoCreateWithoutUsuarioInput, RegistroAccesoUncheckedCreateWithoutUsuarioInput>
  }

  export type RegistroAccesoCreateManyUsuarioInputEnvelope = {
    data: RegistroAccesoCreateManyUsuarioInput | RegistroAccesoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ResenaCreateWithoutUsuarioInput = {
    tipoObjeto: string
    calificacion: number
    comentario?: string | null
    fechaExperiencia?: Date | string | null
    respuestaOwner?: string | null
    fechaRespuesta?: Date | string | null
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResenaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    tipoObjeto: string
    calificacion: number
    comentario?: string | null
    fechaExperiencia?: Date | string | null
    respuestaOwner?: string | null
    fechaRespuesta?: Date | string | null
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResenaCreateOrConnectWithoutUsuarioInput = {
    where: ResenaWhereUniqueInput
    create: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput>
  }

  export type ResenaCreateManyUsuarioInputEnvelope = {
    data: ResenaCreateManyUsuarioInput | ResenaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type TokenInvalidadoCreateWithoutUsuarioInput = {
    tokenHash: string
    invalidadoEn: Date | string
    expiraEn: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TokenInvalidadoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    tokenHash: string
    invalidadoEn: Date | string
    expiraEn: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TokenInvalidadoCreateOrConnectWithoutUsuarioInput = {
    where: TokenInvalidadoWhereUniqueInput
    create: XOR<TokenInvalidadoCreateWithoutUsuarioInput, TokenInvalidadoUncheckedCreateWithoutUsuarioInput>
  }

  export type TokenInvalidadoCreateManyUsuarioInputEnvelope = {
    data: TokenInvalidadoCreateManyUsuarioInput | TokenInvalidadoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type PersonaCreateWithoutUsuarioInput = {
    nombre: string
    apellidos: string
    telefono?: string | null
    direccion?: string | null
    fotoPerfilUrl?: string | null
    fechaNacimiento?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subdivision: SubdivisionCreateNestedOneWithoutPersonasInput
  }

  export type PersonaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    direccion?: string | null
    fotoPerfilUrl?: string | null
    fechaNacimiento?: Date | string | null
    subdivisionId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonaCreateOrConnectWithoutUsuarioInput = {
    where: PersonaWhereUniqueInput
    create: XOR<PersonaCreateWithoutUsuarioInput, PersonaUncheckedCreateWithoutUsuarioInput>
  }

  export type UsuariosRolesCreateWithoutUsuarioInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    rol: RoleCreateNestedOneWithoutUsuariosRolesInput
  }

  export type UsuariosRolesUncheckedCreateWithoutUsuarioInput = {
    id?: number
    rolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuariosRolesCreateOrConnectWithoutUsuarioInput = {
    where: UsuariosRolesWhereUniqueInput
    create: XOR<UsuariosRolesCreateWithoutUsuarioInput, UsuariosRolesUncheckedCreateWithoutUsuarioInput>
  }

  export type UsuariosRolesCreateManyUsuarioInputEnvelope = {
    data: UsuariosRolesCreateManyUsuarioInput | UsuariosRolesCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type EmprendimientoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: EmprendimientoWhereUniqueInput
    update: XOR<EmprendimientoUpdateWithoutUsuarioInput, EmprendimientoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EmprendimientoCreateWithoutUsuarioInput, EmprendimientoUncheckedCreateWithoutUsuarioInput>
  }

  export type EmprendimientoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: EmprendimientoWhereUniqueInput
    data: XOR<EmprendimientoUpdateWithoutUsuarioInput, EmprendimientoUncheckedUpdateWithoutUsuarioInput>
  }

  export type EmprendimientoUpdateManyWithWhereWithoutUsuarioInput = {
    where: EmprendimientoScalarWhereInput
    data: XOR<EmprendimientoUpdateManyMutationInput, EmprendimientoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type FavoritoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: FavoritoWhereUniqueInput
    update: XOR<FavoritoUpdateWithoutUsuarioInput, FavoritoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<FavoritoCreateWithoutUsuarioInput, FavoritoUncheckedCreateWithoutUsuarioInput>
  }

  export type FavoritoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: FavoritoWhereUniqueInput
    data: XOR<FavoritoUpdateWithoutUsuarioInput, FavoritoUncheckedUpdateWithoutUsuarioInput>
  }

  export type FavoritoUpdateManyWithWhereWithoutUsuarioInput = {
    where: FavoritoScalarWhereInput
    data: XOR<FavoritoUpdateManyMutationInput, FavoritoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type FavoritoScalarWhereInput = {
    AND?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[]
    OR?: FavoritoScalarWhereInput[]
    NOT?: FavoritoScalarWhereInput | FavoritoScalarWhereInput[]
    id?: IntFilter<"Favorito"> | number
    estado?: StringFilter<"Favorito"> | string
    usuarioId?: IntFilter<"Favorito"> | number
    emprendimientoId?: IntFilter<"Favorito"> | number
    createdAt?: DateTimeFilter<"Favorito"> | Date | string
  }

  export type RegistroAccesoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: RegistroAccesoWhereUniqueInput
    update: XOR<RegistroAccesoUpdateWithoutUsuarioInput, RegistroAccesoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<RegistroAccesoCreateWithoutUsuarioInput, RegistroAccesoUncheckedCreateWithoutUsuarioInput>
  }

  export type RegistroAccesoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: RegistroAccesoWhereUniqueInput
    data: XOR<RegistroAccesoUpdateWithoutUsuarioInput, RegistroAccesoUncheckedUpdateWithoutUsuarioInput>
  }

  export type RegistroAccesoUpdateManyWithWhereWithoutUsuarioInput = {
    where: RegistroAccesoScalarWhereInput
    data: XOR<RegistroAccesoUpdateManyMutationInput, RegistroAccesoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type RegistroAccesoScalarWhereInput = {
    AND?: RegistroAccesoScalarWhereInput | RegistroAccesoScalarWhereInput[]
    OR?: RegistroAccesoScalarWhereInput[]
    NOT?: RegistroAccesoScalarWhereInput | RegistroAccesoScalarWhereInput[]
    id?: IntFilter<"RegistroAcceso"> | number
    usuarioId?: IntFilter<"RegistroAcceso"> | number
    ipAddress?: StringFilter<"RegistroAcceso"> | string
    userAgent?: StringFilter<"RegistroAcceso"> | string
    tipoEvento?: StringFilter<"RegistroAcceso"> | string
    detalles?: JsonNullableFilter<"RegistroAcceso">
    createdAt?: DateTimeFilter<"RegistroAcceso"> | Date | string
    updatedAt?: DateTimeFilter<"RegistroAcceso"> | Date | string
  }

  export type ResenaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ResenaWhereUniqueInput
    update: XOR<ResenaUpdateWithoutUsuarioInput, ResenaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput>
  }

  export type ResenaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ResenaWhereUniqueInput
    data: XOR<ResenaUpdateWithoutUsuarioInput, ResenaUncheckedUpdateWithoutUsuarioInput>
  }

  export type ResenaUpdateManyWithWhereWithoutUsuarioInput = {
    where: ResenaScalarWhereInput
    data: XOR<ResenaUpdateManyMutationInput, ResenaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ResenaScalarWhereInput = {
    AND?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
    OR?: ResenaScalarWhereInput[]
    NOT?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
    id?: IntFilter<"Resena"> | number
    usuarioId?: IntFilter<"Resena"> | number
    tipoObjeto?: StringFilter<"Resena"> | string
    calificacion?: IntFilter<"Resena"> | number
    comentario?: StringNullableFilter<"Resena"> | string | null
    fechaExperiencia?: DateTimeNullableFilter<"Resena"> | Date | string | null
    respuestaOwner?: StringNullableFilter<"Resena"> | string | null
    fechaRespuesta?: DateTimeNullableFilter<"Resena"> | Date | string | null
    estado?: StringFilter<"Resena"> | string
    createdAt?: DateTimeFilter<"Resena"> | Date | string
    updatedAt?: DateTimeFilter<"Resena"> | Date | string
  }

  export type TokenInvalidadoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: TokenInvalidadoWhereUniqueInput
    update: XOR<TokenInvalidadoUpdateWithoutUsuarioInput, TokenInvalidadoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<TokenInvalidadoCreateWithoutUsuarioInput, TokenInvalidadoUncheckedCreateWithoutUsuarioInput>
  }

  export type TokenInvalidadoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: TokenInvalidadoWhereUniqueInput
    data: XOR<TokenInvalidadoUpdateWithoutUsuarioInput, TokenInvalidadoUncheckedUpdateWithoutUsuarioInput>
  }

  export type TokenInvalidadoUpdateManyWithWhereWithoutUsuarioInput = {
    where: TokenInvalidadoScalarWhereInput
    data: XOR<TokenInvalidadoUpdateManyMutationInput, TokenInvalidadoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type TokenInvalidadoScalarWhereInput = {
    AND?: TokenInvalidadoScalarWhereInput | TokenInvalidadoScalarWhereInput[]
    OR?: TokenInvalidadoScalarWhereInput[]
    NOT?: TokenInvalidadoScalarWhereInput | TokenInvalidadoScalarWhereInput[]
    id?: IntFilter<"TokenInvalidado"> | number
    tokenHash?: StringFilter<"TokenInvalidado"> | string
    usuarioId?: IntFilter<"TokenInvalidado"> | number
    invalidadoEn?: DateTimeFilter<"TokenInvalidado"> | Date | string
    expiraEn?: DateTimeFilter<"TokenInvalidado"> | Date | string
    metadata?: JsonFilter<"TokenInvalidado">
    createdAt?: DateTimeFilter<"TokenInvalidado"> | Date | string
  }

  export type PersonaUpsertWithoutUsuarioInput = {
    update: XOR<PersonaUpdateWithoutUsuarioInput, PersonaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PersonaCreateWithoutUsuarioInput, PersonaUncheckedCreateWithoutUsuarioInput>
    where?: PersonaWhereInput
  }

  export type PersonaUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: PersonaWhereInput
    data: XOR<PersonaUpdateWithoutUsuarioInput, PersonaUncheckedUpdateWithoutUsuarioInput>
  }

  export type PersonaUpdateWithoutUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fotoPerfilUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subdivision?: SubdivisionUpdateOneRequiredWithoutPersonasNestedInput
  }

  export type PersonaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fotoPerfilUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subdivisionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuariosRolesUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: UsuariosRolesWhereUniqueInput
    update: XOR<UsuariosRolesUpdateWithoutUsuarioInput, UsuariosRolesUncheckedUpdateWithoutUsuarioInput>
    create: XOR<UsuariosRolesCreateWithoutUsuarioInput, UsuariosRolesUncheckedCreateWithoutUsuarioInput>
  }

  export type UsuariosRolesUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: UsuariosRolesWhereUniqueInput
    data: XOR<UsuariosRolesUpdateWithoutUsuarioInput, UsuariosRolesUncheckedUpdateWithoutUsuarioInput>
  }

  export type UsuariosRolesUpdateManyWithWhereWithoutUsuarioInput = {
    where: UsuariosRolesScalarWhereInput
    data: XOR<UsuariosRolesUpdateManyMutationInput, UsuariosRolesUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type RoleCreateWithoutUsuariosRolesInput = {
    nombre: string
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolesPermisos?: RolesPermisosCreateNestedManyWithoutRolInput
  }

  export type RoleUncheckedCreateWithoutUsuariosRolesInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rolesPermisos?: RolesPermisosUncheckedCreateNestedManyWithoutRolInput
  }

  export type RoleCreateOrConnectWithoutUsuariosRolesInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsuariosRolesInput, RoleUncheckedCreateWithoutUsuariosRolesInput>
  }

  export type UsuarioCreateWithoutUsuariosRolesInput = {
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoCreateNestedManyWithoutUsuarioInput
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoCreateNestedManyWithoutUsuarioInput
    persona: PersonaCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutUsuariosRolesInput = {
    id?: number
    personaId: number
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoUncheckedCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutUsuariosRolesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutUsuariosRolesInput, UsuarioUncheckedCreateWithoutUsuariosRolesInput>
  }

  export type RoleUpsertWithoutUsuariosRolesInput = {
    update: XOR<RoleUpdateWithoutUsuariosRolesInput, RoleUncheckedUpdateWithoutUsuariosRolesInput>
    create: XOR<RoleCreateWithoutUsuariosRolesInput, RoleUncheckedCreateWithoutUsuariosRolesInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsuariosRolesInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsuariosRolesInput, RoleUncheckedUpdateWithoutUsuariosRolesInput>
  }

  export type RoleUpdateWithoutUsuariosRolesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolesPermisos?: RolesPermisosUpdateManyWithoutRolNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsuariosRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolesPermisos?: RolesPermisosUncheckedUpdateManyWithoutRolNestedInput
  }

  export type UsuarioUpsertWithoutUsuariosRolesInput = {
    update: XOR<UsuarioUpdateWithoutUsuariosRolesInput, UsuarioUncheckedUpdateWithoutUsuariosRolesInput>
    create: XOR<UsuarioCreateWithoutUsuariosRolesInput, UsuarioUncheckedCreateWithoutUsuariosRolesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutUsuariosRolesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutUsuariosRolesInput, UsuarioUncheckedUpdateWithoutUsuariosRolesInput>
  }

  export type UsuarioUpdateWithoutUsuariosRolesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUpdateManyWithoutUsuarioNestedInput
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUpdateManyWithoutUsuarioNestedInput
    persona?: PersonaUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutUsuariosRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    personaId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUncheckedUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type SubdivisionCreateWithoutEmprendimientosInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personas?: PersonaCreateNestedManyWithoutSubdivisionInput
    country: CountryCreateNestedOneWithoutSubdivisionsInput
  }

  export type SubdivisionUncheckedCreateWithoutEmprendimientosInput = {
    id?: number
    countryId: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personas?: PersonaUncheckedCreateNestedManyWithoutSubdivisionInput
  }

  export type SubdivisionCreateOrConnectWithoutEmprendimientosInput = {
    where: SubdivisionWhereUniqueInput
    create: XOR<SubdivisionCreateWithoutEmprendimientosInput, SubdivisionUncheckedCreateWithoutEmprendimientosInput>
  }

  export type UsuarioCreateWithoutEmprendimientosInput = {
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoCreateNestedManyWithoutUsuarioInput
    persona: PersonaCreateNestedOneWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutEmprendimientosInput = {
    id?: number
    personaId: number
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoUncheckedCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoUncheckedCreateNestedManyWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutEmprendimientosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEmprendimientosInput, UsuarioUncheckedCreateWithoutEmprendimientosInput>
  }

  export type FavoritoCreateWithoutEmprendimientoInput = {
    estado?: string
    createdAt?: Date | string
    usuario: UsuarioCreateNestedOneWithoutFavoritosInput
  }

  export type FavoritoUncheckedCreateWithoutEmprendimientoInput = {
    id?: number
    estado?: string
    usuarioId: number
    createdAt?: Date | string
  }

  export type FavoritoCreateOrConnectWithoutEmprendimientoInput = {
    where: FavoritoWhereUniqueInput
    create: XOR<FavoritoCreateWithoutEmprendimientoInput, FavoritoUncheckedCreateWithoutEmprendimientoInput>
  }

  export type FavoritoCreateManyEmprendimientoInputEnvelope = {
    data: FavoritoCreateManyEmprendimientoInput | FavoritoCreateManyEmprendimientoInput[]
    skipDuplicates?: boolean
  }

  export type PaqueteTuristicoCreateWithoutEmprendimientoInput = {
    nombre: string
    descripcion: string
    duracionDias: number
    duracionNoches?: number | null
    precioPorPersona: Decimal | DecimalJsLike | number | string
    moneda?: string
    capacidadMaxima?: number | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: string | null
    incluye?: string | null
    noIncluye?: string | null
    estado?: string
    esPersonalizable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    disponibilidad?: DisponibilidadPaqueteCreateNestedManyWithoutPaqueteInput
    servicios?: PaqueteTuristicoServicioCreateNestedManyWithoutPaqueteTuristicoInput
  }

  export type PaqueteTuristicoUncheckedCreateWithoutEmprendimientoInput = {
    id?: number
    nombre: string
    descripcion: string
    duracionDias: number
    duracionNoches?: number | null
    precioPorPersona: Decimal | DecimalJsLike | number | string
    moneda?: string
    capacidadMaxima?: number | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: string | null
    incluye?: string | null
    noIncluye?: string | null
    estado?: string
    esPersonalizable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    disponibilidad?: DisponibilidadPaqueteUncheckedCreateNestedManyWithoutPaqueteInput
    servicios?: PaqueteTuristicoServicioUncheckedCreateNestedManyWithoutPaqueteTuristicoInput
  }

  export type PaqueteTuristicoCreateOrConnectWithoutEmprendimientoInput = {
    where: PaqueteTuristicoWhereUniqueInput
    create: XOR<PaqueteTuristicoCreateWithoutEmprendimientoInput, PaqueteTuristicoUncheckedCreateWithoutEmprendimientoInput>
  }

  export type PaqueteTuristicoCreateManyEmprendimientoInputEnvelope = {
    data: PaqueteTuristicoCreateManyEmprendimientoInput | PaqueteTuristicoCreateManyEmprendimientoInput[]
    skipDuplicates?: boolean
  }

  export type ServicioEmprendedorCreateWithoutEmprendimientoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    servicio: ServicioCreateNestedOneWithoutServiciosEmprendedoresInput
  }

  export type ServicioEmprendedorUncheckedCreateWithoutEmprendimientoInput = {
    id?: number
    servicioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicioEmprendedorCreateOrConnectWithoutEmprendimientoInput = {
    where: ServicioEmprendedorWhereUniqueInput
    create: XOR<ServicioEmprendedorCreateWithoutEmprendimientoInput, ServicioEmprendedorUncheckedCreateWithoutEmprendimientoInput>
  }

  export type ServicioEmprendedorCreateManyEmprendimientoInputEnvelope = {
    data: ServicioEmprendedorCreateManyEmprendimientoInput | ServicioEmprendedorCreateManyEmprendimientoInput[]
    skipDuplicates?: boolean
  }

  export type SubdivisionUpsertWithoutEmprendimientosInput = {
    update: XOR<SubdivisionUpdateWithoutEmprendimientosInput, SubdivisionUncheckedUpdateWithoutEmprendimientosInput>
    create: XOR<SubdivisionCreateWithoutEmprendimientosInput, SubdivisionUncheckedCreateWithoutEmprendimientosInput>
    where?: SubdivisionWhereInput
  }

  export type SubdivisionUpdateToOneWithWhereWithoutEmprendimientosInput = {
    where?: SubdivisionWhereInput
    data: XOR<SubdivisionUpdateWithoutEmprendimientosInput, SubdivisionUncheckedUpdateWithoutEmprendimientosInput>
  }

  export type SubdivisionUpdateWithoutEmprendimientosInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personas?: PersonaUpdateManyWithoutSubdivisionNestedInput
    country?: CountryUpdateOneRequiredWithoutSubdivisionsNestedInput
  }

  export type SubdivisionUncheckedUpdateWithoutEmprendimientosInput = {
    id?: IntFieldUpdateOperationsInput | number
    countryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personas?: PersonaUncheckedUpdateManyWithoutSubdivisionNestedInput
  }

  export type UsuarioUpsertWithoutEmprendimientosInput = {
    update: XOR<UsuarioUpdateWithoutEmprendimientosInput, UsuarioUncheckedUpdateWithoutEmprendimientosInput>
    create: XOR<UsuarioCreateWithoutEmprendimientosInput, UsuarioUncheckedCreateWithoutEmprendimientosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEmprendimientosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEmprendimientosInput, UsuarioUncheckedUpdateWithoutEmprendimientosInput>
  }

  export type UsuarioUpdateWithoutEmprendimientosInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUpdateManyWithoutUsuarioNestedInput
    persona?: PersonaUpdateOneRequiredWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEmprendimientosInput = {
    id?: IntFieldUpdateOperationsInput | number
    personaId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUncheckedUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUncheckedUpdateManyWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type FavoritoUpsertWithWhereUniqueWithoutEmprendimientoInput = {
    where: FavoritoWhereUniqueInput
    update: XOR<FavoritoUpdateWithoutEmprendimientoInput, FavoritoUncheckedUpdateWithoutEmprendimientoInput>
    create: XOR<FavoritoCreateWithoutEmprendimientoInput, FavoritoUncheckedCreateWithoutEmprendimientoInput>
  }

  export type FavoritoUpdateWithWhereUniqueWithoutEmprendimientoInput = {
    where: FavoritoWhereUniqueInput
    data: XOR<FavoritoUpdateWithoutEmprendimientoInput, FavoritoUncheckedUpdateWithoutEmprendimientoInput>
  }

  export type FavoritoUpdateManyWithWhereWithoutEmprendimientoInput = {
    where: FavoritoScalarWhereInput
    data: XOR<FavoritoUpdateManyMutationInput, FavoritoUncheckedUpdateManyWithoutEmprendimientoInput>
  }

  export type PaqueteTuristicoUpsertWithWhereUniqueWithoutEmprendimientoInput = {
    where: PaqueteTuristicoWhereUniqueInput
    update: XOR<PaqueteTuristicoUpdateWithoutEmprendimientoInput, PaqueteTuristicoUncheckedUpdateWithoutEmprendimientoInput>
    create: XOR<PaqueteTuristicoCreateWithoutEmprendimientoInput, PaqueteTuristicoUncheckedCreateWithoutEmprendimientoInput>
  }

  export type PaqueteTuristicoUpdateWithWhereUniqueWithoutEmprendimientoInput = {
    where: PaqueteTuristicoWhereUniqueInput
    data: XOR<PaqueteTuristicoUpdateWithoutEmprendimientoInput, PaqueteTuristicoUncheckedUpdateWithoutEmprendimientoInput>
  }

  export type PaqueteTuristicoUpdateManyWithWhereWithoutEmprendimientoInput = {
    where: PaqueteTuristicoScalarWhereInput
    data: XOR<PaqueteTuristicoUpdateManyMutationInput, PaqueteTuristicoUncheckedUpdateManyWithoutEmprendimientoInput>
  }

  export type PaqueteTuristicoScalarWhereInput = {
    AND?: PaqueteTuristicoScalarWhereInput | PaqueteTuristicoScalarWhereInput[]
    OR?: PaqueteTuristicoScalarWhereInput[]
    NOT?: PaqueteTuristicoScalarWhereInput | PaqueteTuristicoScalarWhereInput[]
    id?: IntFilter<"PaqueteTuristico"> | number
    emprendimientoId?: IntNullableFilter<"PaqueteTuristico"> | number | null
    nombre?: StringFilter<"PaqueteTuristico"> | string
    descripcion?: StringFilter<"PaqueteTuristico"> | string
    duracionDias?: IntFilter<"PaqueteTuristico"> | number
    duracionNoches?: IntNullableFilter<"PaqueteTuristico"> | number | null
    precioPorPersona?: DecimalFilter<"PaqueteTuristico"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"PaqueteTuristico"> | string
    capacidadMaxima?: IntNullableFilter<"PaqueteTuristico"> | number | null
    fechaInicio?: DateTimeNullableFilter<"PaqueteTuristico"> | Date | string | null
    fechaFin?: DateTimeNullableFilter<"PaqueteTuristico"> | Date | string | null
    lugaresVisitados?: JsonNullableFilter<"PaqueteTuristico">
    requisitos?: StringNullableFilter<"PaqueteTuristico"> | string | null
    incluye?: StringNullableFilter<"PaqueteTuristico"> | string | null
    noIncluye?: StringNullableFilter<"PaqueteTuristico"> | string | null
    estado?: StringFilter<"PaqueteTuristico"> | string
    esPersonalizable?: BoolFilter<"PaqueteTuristico"> | boolean
    createdAt?: DateTimeFilter<"PaqueteTuristico"> | Date | string
    updatedAt?: DateTimeFilter<"PaqueteTuristico"> | Date | string
  }

  export type ServicioEmprendedorUpsertWithWhereUniqueWithoutEmprendimientoInput = {
    where: ServicioEmprendedorWhereUniqueInput
    update: XOR<ServicioEmprendedorUpdateWithoutEmprendimientoInput, ServicioEmprendedorUncheckedUpdateWithoutEmprendimientoInput>
    create: XOR<ServicioEmprendedorCreateWithoutEmprendimientoInput, ServicioEmprendedorUncheckedCreateWithoutEmprendimientoInput>
  }

  export type ServicioEmprendedorUpdateWithWhereUniqueWithoutEmprendimientoInput = {
    where: ServicioEmprendedorWhereUniqueInput
    data: XOR<ServicioEmprendedorUpdateWithoutEmprendimientoInput, ServicioEmprendedorUncheckedUpdateWithoutEmprendimientoInput>
  }

  export type ServicioEmprendedorUpdateManyWithWhereWithoutEmprendimientoInput = {
    where: ServicioEmprendedorScalarWhereInput
    data: XOR<ServicioEmprendedorUpdateManyMutationInput, ServicioEmprendedorUncheckedUpdateManyWithoutEmprendimientoInput>
  }

  export type ServicioEmprendedorScalarWhereInput = {
    AND?: ServicioEmprendedorScalarWhereInput | ServicioEmprendedorScalarWhereInput[]
    OR?: ServicioEmprendedorScalarWhereInput[]
    NOT?: ServicioEmprendedorScalarWhereInput | ServicioEmprendedorScalarWhereInput[]
    id?: IntFilter<"ServicioEmprendedor"> | number
    servicioId?: IntFilter<"ServicioEmprendedor"> | number
    emprendimientoId?: IntFilter<"ServicioEmprendedor"> | number
    createdAt?: DateTimeFilter<"ServicioEmprendedor"> | Date | string
    updatedAt?: DateTimeFilter<"ServicioEmprendedor"> | Date | string
  }

  export type UsuarioCreateWithoutRegistroAccesosInput = {
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoCreateNestedManyWithoutUsuarioInput
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoCreateNestedManyWithoutUsuarioInput
    persona: PersonaCreateNestedOneWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutRegistroAccesosInput = {
    id?: number
    personaId: number
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoUncheckedCreateNestedManyWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutRegistroAccesosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRegistroAccesosInput, UsuarioUncheckedCreateWithoutRegistroAccesosInput>
  }

  export type UsuarioUpsertWithoutRegistroAccesosInput = {
    update: XOR<UsuarioUpdateWithoutRegistroAccesosInput, UsuarioUncheckedUpdateWithoutRegistroAccesosInput>
    create: XOR<UsuarioCreateWithoutRegistroAccesosInput, UsuarioUncheckedCreateWithoutRegistroAccesosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutRegistroAccesosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutRegistroAccesosInput, UsuarioUncheckedUpdateWithoutRegistroAccesosInput>
  }

  export type UsuarioUpdateWithoutRegistroAccesosInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUpdateManyWithoutUsuarioNestedInput
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUpdateManyWithoutUsuarioNestedInput
    persona?: PersonaUpdateOneRequiredWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutRegistroAccesosInput = {
    id?: IntFieldUpdateOperationsInput | number
    personaId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUncheckedUpdateManyWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutTokensInvalidadosInput = {
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoCreateNestedManyWithoutUsuarioInput
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
    persona: PersonaCreateNestedOneWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutTokensInvalidadosInput = {
    id?: number
    personaId: number
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoUncheckedCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutTokensInvalidadosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutTokensInvalidadosInput, UsuarioUncheckedCreateWithoutTokensInvalidadosInput>
  }

  export type UsuarioUpsertWithoutTokensInvalidadosInput = {
    update: XOR<UsuarioUpdateWithoutTokensInvalidadosInput, UsuarioUncheckedUpdateWithoutTokensInvalidadosInput>
    create: XOR<UsuarioCreateWithoutTokensInvalidadosInput, UsuarioUncheckedCreateWithoutTokensInvalidadosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutTokensInvalidadosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutTokensInvalidadosInput, UsuarioUncheckedUpdateWithoutTokensInvalidadosInput>
  }

  export type UsuarioUpdateWithoutTokensInvalidadosInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUpdateManyWithoutUsuarioNestedInput
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
    persona?: PersonaUpdateOneRequiredWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutTokensInvalidadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    personaId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUncheckedUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type ReservaCreateWithoutTuristaInput = {
    codigoReserva: string
    tipoReserva: string
    fechaReserva?: Date | string
    fechaInicio: Date | string
    hora?: string | null
    fechaFin?: Date | string | null
    cantidadPersonas?: number
    precioTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    metodoPago?: string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: string | null
    motivoCancelacion?: string | null
    fechaCancelacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarios?: ItinerarioReservaCreateNestedManyWithoutReservaInput
    pagos?: PagoCreateNestedManyWithoutReservaInput
  }

  export type ReservaUncheckedCreateWithoutTuristaInput = {
    id?: number
    codigoReserva: string
    tipoReserva: string
    fechaReserva?: Date | string
    fechaInicio: Date | string
    hora?: string | null
    fechaFin?: Date | string | null
    cantidadPersonas?: number
    precioTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    metodoPago?: string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: string | null
    motivoCancelacion?: string | null
    fechaCancelacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarios?: ItinerarioReservaUncheckedCreateNestedManyWithoutReservaInput
    pagos?: PagoUncheckedCreateNestedManyWithoutReservaInput
  }

  export type ReservaCreateOrConnectWithoutTuristaInput = {
    where: ReservaWhereUniqueInput
    create: XOR<ReservaCreateWithoutTuristaInput, ReservaUncheckedCreateWithoutTuristaInput>
  }

  export type ReservaCreateManyTuristaInputEnvelope = {
    data: ReservaCreateManyTuristaInput | ReservaCreateManyTuristaInput[]
    skipDuplicates?: boolean
  }

  export type ReservaUpsertWithWhereUniqueWithoutTuristaInput = {
    where: ReservaWhereUniqueInput
    update: XOR<ReservaUpdateWithoutTuristaInput, ReservaUncheckedUpdateWithoutTuristaInput>
    create: XOR<ReservaCreateWithoutTuristaInput, ReservaUncheckedCreateWithoutTuristaInput>
  }

  export type ReservaUpdateWithWhereUniqueWithoutTuristaInput = {
    where: ReservaWhereUniqueInput
    data: XOR<ReservaUpdateWithoutTuristaInput, ReservaUncheckedUpdateWithoutTuristaInput>
  }

  export type ReservaUpdateManyWithWhereWithoutTuristaInput = {
    where: ReservaScalarWhereInput
    data: XOR<ReservaUpdateManyMutationInput, ReservaUncheckedUpdateManyWithoutTuristaInput>
  }

  export type ReservaScalarWhereInput = {
    AND?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
    OR?: ReservaScalarWhereInput[]
    NOT?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
    id?: IntFilter<"Reserva"> | number
    codigoReserva?: StringFilter<"Reserva"> | string
    turistaId?: IntFilter<"Reserva"> | number
    tipoReserva?: StringFilter<"Reserva"> | string
    fechaReserva?: DateTimeFilter<"Reserva"> | Date | string
    fechaInicio?: DateTimeFilter<"Reserva"> | Date | string
    hora?: StringNullableFilter<"Reserva"> | string | null
    fechaFin?: DateTimeNullableFilter<"Reserva"> | Date | string | null
    cantidadPersonas?: IntFilter<"Reserva"> | number
    precioTotal?: DecimalFilter<"Reserva"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Reserva"> | string
    estado?: StringFilter<"Reserva"> | string
    metodoPago?: StringNullableFilter<"Reserva"> | string | null
    datosPago?: JsonNullableFilter<"Reserva">
    notas?: StringNullableFilter<"Reserva"> | string | null
    motivoCancelacion?: StringNullableFilter<"Reserva"> | string | null
    fechaCancelacion?: DateTimeNullableFilter<"Reserva"> | Date | string | null
    createdAt?: DateTimeFilter<"Reserva"> | Date | string
    updatedAt?: DateTimeFilter<"Reserva"> | Date | string
  }

  export type ItinerarioLugarCreateWithoutLugarTuristicoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarioReserva: ItinerarioReservaCreateNestedOneWithoutItinerarioLugaresInput
  }

  export type ItinerarioLugarUncheckedCreateWithoutLugarTuristicoInput = {
    id?: number
    itinerarioReservaId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItinerarioLugarCreateOrConnectWithoutLugarTuristicoInput = {
    where: ItinerarioLugarWhereUniqueInput
    create: XOR<ItinerarioLugarCreateWithoutLugarTuristicoInput, ItinerarioLugarUncheckedCreateWithoutLugarTuristicoInput>
  }

  export type ItinerarioLugarCreateManyLugarTuristicoInputEnvelope = {
    data: ItinerarioLugarCreateManyLugarTuristicoInput | ItinerarioLugarCreateManyLugarTuristicoInput[]
    skipDuplicates?: boolean
  }

  export type ItinerarioLugarUpsertWithWhereUniqueWithoutLugarTuristicoInput = {
    where: ItinerarioLugarWhereUniqueInput
    update: XOR<ItinerarioLugarUpdateWithoutLugarTuristicoInput, ItinerarioLugarUncheckedUpdateWithoutLugarTuristicoInput>
    create: XOR<ItinerarioLugarCreateWithoutLugarTuristicoInput, ItinerarioLugarUncheckedCreateWithoutLugarTuristicoInput>
  }

  export type ItinerarioLugarUpdateWithWhereUniqueWithoutLugarTuristicoInput = {
    where: ItinerarioLugarWhereUniqueInput
    data: XOR<ItinerarioLugarUpdateWithoutLugarTuristicoInput, ItinerarioLugarUncheckedUpdateWithoutLugarTuristicoInput>
  }

  export type ItinerarioLugarUpdateManyWithWhereWithoutLugarTuristicoInput = {
    where: ItinerarioLugarScalarWhereInput
    data: XOR<ItinerarioLugarUpdateManyMutationInput, ItinerarioLugarUncheckedUpdateManyWithoutLugarTuristicoInput>
  }

  export type ItinerarioLugarScalarWhereInput = {
    AND?: ItinerarioLugarScalarWhereInput | ItinerarioLugarScalarWhereInput[]
    OR?: ItinerarioLugarScalarWhereInput[]
    NOT?: ItinerarioLugarScalarWhereInput | ItinerarioLugarScalarWhereInput[]
    id?: IntFilter<"ItinerarioLugar"> | number
    itinerarioReservaId?: IntFilter<"ItinerarioLugar"> | number
    lugarTuristicoId?: IntFilter<"ItinerarioLugar"> | number
    createdAt?: DateTimeFilter<"ItinerarioLugar"> | Date | string
    updatedAt?: DateTimeFilter<"ItinerarioLugar"> | Date | string
  }

  export type EmprendimientoCreateWithoutServiciosInput = {
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subdivision?: SubdivisionCreateNestedOneWithoutEmprendimientosInput
    usuario: UsuarioCreateNestedOneWithoutEmprendimientosInput
    favoritos?: FavoritoCreateNestedManyWithoutEmprendimientoInput
    paquetesTuristicos?: PaqueteTuristicoCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateWithoutServiciosInput = {
    id?: number
    usuarioId: number
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    subdivisionId?: number | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutEmprendimientoInput
    paquetesTuristicos?: PaqueteTuristicoUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoCreateOrConnectWithoutServiciosInput = {
    where: EmprendimientoWhereUniqueInput
    create: XOR<EmprendimientoCreateWithoutServiciosInput, EmprendimientoUncheckedCreateWithoutServiciosInput>
  }

  export type ServicioCreateWithoutServiciosEmprendedoresInput = {
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerariosReserva?: ItinerarioReservaCreateNestedManyWithoutServicioInput
    paquetesServicios?: PaqueteTuristicoServicioCreateNestedManyWithoutServicioInput
    tipoServicio: TipoServicioCreateNestedOneWithoutServiciosInput
    disponibilidad?: ServicioDisponibilidadCreateNestedManyWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutServiciosEmprendedoresInput = {
    id?: number
    tipoServicioId: number
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerariosReserva?: ItinerarioReservaUncheckedCreateNestedManyWithoutServicioInput
    paquetesServicios?: PaqueteTuristicoServicioUncheckedCreateNestedManyWithoutServicioInput
    disponibilidad?: ServicioDisponibilidadUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioCreateOrConnectWithoutServiciosEmprendedoresInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutServiciosEmprendedoresInput, ServicioUncheckedCreateWithoutServiciosEmprendedoresInput>
  }

  export type EmprendimientoUpsertWithoutServiciosInput = {
    update: XOR<EmprendimientoUpdateWithoutServiciosInput, EmprendimientoUncheckedUpdateWithoutServiciosInput>
    create: XOR<EmprendimientoCreateWithoutServiciosInput, EmprendimientoUncheckedCreateWithoutServiciosInput>
    where?: EmprendimientoWhereInput
  }

  export type EmprendimientoUpdateToOneWithWhereWithoutServiciosInput = {
    where?: EmprendimientoWhereInput
    data: XOR<EmprendimientoUpdateWithoutServiciosInput, EmprendimientoUncheckedUpdateWithoutServiciosInput>
  }

  export type EmprendimientoUpdateWithoutServiciosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subdivision?: SubdivisionUpdateOneWithoutEmprendimientosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput
    favoritos?: FavoritoUpdateManyWithoutEmprendimientoNestedInput
    paquetesTuristicos?: PaqueteTuristicoUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateWithoutServiciosInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    subdivisionId?: NullableIntFieldUpdateOperationsInput | number | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favoritos?: FavoritoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    paquetesTuristicos?: PaqueteTuristicoUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type ServicioUpsertWithoutServiciosEmprendedoresInput = {
    update: XOR<ServicioUpdateWithoutServiciosEmprendedoresInput, ServicioUncheckedUpdateWithoutServiciosEmprendedoresInput>
    create: XOR<ServicioCreateWithoutServiciosEmprendedoresInput, ServicioUncheckedCreateWithoutServiciosEmprendedoresInput>
    where?: ServicioWhereInput
  }

  export type ServicioUpdateToOneWithWhereWithoutServiciosEmprendedoresInput = {
    where?: ServicioWhereInput
    data: XOR<ServicioUpdateWithoutServiciosEmprendedoresInput, ServicioUncheckedUpdateWithoutServiciosEmprendedoresInput>
  }

  export type ServicioUpdateWithoutServiciosEmprendedoresInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerariosReserva?: ItinerarioReservaUpdateManyWithoutServicioNestedInput
    paquetesServicios?: PaqueteTuristicoServicioUpdateManyWithoutServicioNestedInput
    tipoServicio?: TipoServicioUpdateOneRequiredWithoutServiciosNestedInput
    disponibilidad?: ServicioDisponibilidadUpdateManyWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutServiciosEmprendedoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoServicioId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerariosReserva?: ItinerarioReservaUncheckedUpdateManyWithoutServicioNestedInput
    paquetesServicios?: PaqueteTuristicoServicioUncheckedUpdateManyWithoutServicioNestedInput
    disponibilidad?: ServicioDisponibilidadUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type ItinerarioReservaCreateWithoutServicioInput = {
    fecha: Date | string
    hora?: Date | string | null
    tipoEvento: string
    descripcion: string
    notas?: string | null
    duracion?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarioLugares?: ItinerarioLugarCreateNestedManyWithoutItinerarioReservaInput
    reserva: ReservaCreateNestedOneWithoutItinerariosInput
  }

  export type ItinerarioReservaUncheckedCreateWithoutServicioInput = {
    id?: number
    fecha: Date | string
    hora?: Date | string | null
    tipoEvento: string
    descripcion: string
    notas?: string | null
    duracion?: number | null
    reservaId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarioLugares?: ItinerarioLugarUncheckedCreateNestedManyWithoutItinerarioReservaInput
  }

  export type ItinerarioReservaCreateOrConnectWithoutServicioInput = {
    where: ItinerarioReservaWhereUniqueInput
    create: XOR<ItinerarioReservaCreateWithoutServicioInput, ItinerarioReservaUncheckedCreateWithoutServicioInput>
  }

  export type ItinerarioReservaCreateManyServicioInputEnvelope = {
    data: ItinerarioReservaCreateManyServicioInput | ItinerarioReservaCreateManyServicioInput[]
    skipDuplicates?: boolean
  }

  export type PaqueteTuristicoServicioCreateWithoutServicioInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    paqueteTuristico: PaqueteTuristicoCreateNestedOneWithoutServiciosInput
  }

  export type PaqueteTuristicoServicioUncheckedCreateWithoutServicioInput = {
    id?: number
    paqueteTuristicoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaqueteTuristicoServicioCreateOrConnectWithoutServicioInput = {
    where: PaqueteTuristicoServicioWhereUniqueInput
    create: XOR<PaqueteTuristicoServicioCreateWithoutServicioInput, PaqueteTuristicoServicioUncheckedCreateWithoutServicioInput>
  }

  export type PaqueteTuristicoServicioCreateManyServicioInputEnvelope = {
    data: PaqueteTuristicoServicioCreateManyServicioInput | PaqueteTuristicoServicioCreateManyServicioInput[]
    skipDuplicates?: boolean
  }

  export type TipoServicioCreateWithoutServiciosInput = {
    nombre: string
    descripcion?: string | null
    imagenUrl: string
    requiereCupo?: boolean
    createdAt?: Date | string
  }

  export type TipoServicioUncheckedCreateWithoutServiciosInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    imagenUrl: string
    requiereCupo?: boolean
    createdAt?: Date | string
  }

  export type TipoServicioCreateOrConnectWithoutServiciosInput = {
    where: TipoServicioWhereUniqueInput
    create: XOR<TipoServicioCreateWithoutServiciosInput, TipoServicioUncheckedCreateWithoutServiciosInput>
  }

  export type ServicioDisponibilidadCreateWithoutServicioInput = {
    fecha: Date | string
    cuposDisponibles: number
    precioEspecial?: Decimal | DecimalJsLike | number | string | null
  }

  export type ServicioDisponibilidadUncheckedCreateWithoutServicioInput = {
    id?: number
    fecha: Date | string
    cuposDisponibles: number
    precioEspecial?: Decimal | DecimalJsLike | number | string | null
  }

  export type ServicioDisponibilidadCreateOrConnectWithoutServicioInput = {
    where: ServicioDisponibilidadWhereUniqueInput
    create: XOR<ServicioDisponibilidadCreateWithoutServicioInput, ServicioDisponibilidadUncheckedCreateWithoutServicioInput>
  }

  export type ServicioDisponibilidadCreateManyServicioInputEnvelope = {
    data: ServicioDisponibilidadCreateManyServicioInput | ServicioDisponibilidadCreateManyServicioInput[]
    skipDuplicates?: boolean
  }

  export type ServicioEmprendedorCreateWithoutServicioInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimiento: EmprendimientoCreateNestedOneWithoutServiciosInput
  }

  export type ServicioEmprendedorUncheckedCreateWithoutServicioInput = {
    id?: number
    emprendimientoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicioEmprendedorCreateOrConnectWithoutServicioInput = {
    where: ServicioEmprendedorWhereUniqueInput
    create: XOR<ServicioEmprendedorCreateWithoutServicioInput, ServicioEmprendedorUncheckedCreateWithoutServicioInput>
  }

  export type ServicioEmprendedorCreateManyServicioInputEnvelope = {
    data: ServicioEmprendedorCreateManyServicioInput | ServicioEmprendedorCreateManyServicioInput[]
    skipDuplicates?: boolean
  }

  export type ItinerarioReservaUpsertWithWhereUniqueWithoutServicioInput = {
    where: ItinerarioReservaWhereUniqueInput
    update: XOR<ItinerarioReservaUpdateWithoutServicioInput, ItinerarioReservaUncheckedUpdateWithoutServicioInput>
    create: XOR<ItinerarioReservaCreateWithoutServicioInput, ItinerarioReservaUncheckedCreateWithoutServicioInput>
  }

  export type ItinerarioReservaUpdateWithWhereUniqueWithoutServicioInput = {
    where: ItinerarioReservaWhereUniqueInput
    data: XOR<ItinerarioReservaUpdateWithoutServicioInput, ItinerarioReservaUncheckedUpdateWithoutServicioInput>
  }

  export type ItinerarioReservaUpdateManyWithWhereWithoutServicioInput = {
    where: ItinerarioReservaScalarWhereInput
    data: XOR<ItinerarioReservaUpdateManyMutationInput, ItinerarioReservaUncheckedUpdateManyWithoutServicioInput>
  }

  export type ItinerarioReservaScalarWhereInput = {
    AND?: ItinerarioReservaScalarWhereInput | ItinerarioReservaScalarWhereInput[]
    OR?: ItinerarioReservaScalarWhereInput[]
    NOT?: ItinerarioReservaScalarWhereInput | ItinerarioReservaScalarWhereInput[]
    id?: IntFilter<"ItinerarioReserva"> | number
    fecha?: DateTimeFilter<"ItinerarioReserva"> | Date | string
    hora?: DateTimeNullableFilter<"ItinerarioReserva"> | Date | string | null
    tipoEvento?: StringFilter<"ItinerarioReserva"> | string
    descripcion?: StringFilter<"ItinerarioReserva"> | string
    notas?: StringNullableFilter<"ItinerarioReserva"> | string | null
    duracion?: IntNullableFilter<"ItinerarioReserva"> | number | null
    reservaId?: IntFilter<"ItinerarioReserva"> | number
    servicioId?: IntNullableFilter<"ItinerarioReserva"> | number | null
    createdAt?: DateTimeFilter<"ItinerarioReserva"> | Date | string
    updatedAt?: DateTimeFilter<"ItinerarioReserva"> | Date | string
  }

  export type PaqueteTuristicoServicioUpsertWithWhereUniqueWithoutServicioInput = {
    where: PaqueteTuristicoServicioWhereUniqueInput
    update: XOR<PaqueteTuristicoServicioUpdateWithoutServicioInput, PaqueteTuristicoServicioUncheckedUpdateWithoutServicioInput>
    create: XOR<PaqueteTuristicoServicioCreateWithoutServicioInput, PaqueteTuristicoServicioUncheckedCreateWithoutServicioInput>
  }

  export type PaqueteTuristicoServicioUpdateWithWhereUniqueWithoutServicioInput = {
    where: PaqueteTuristicoServicioWhereUniqueInput
    data: XOR<PaqueteTuristicoServicioUpdateWithoutServicioInput, PaqueteTuristicoServicioUncheckedUpdateWithoutServicioInput>
  }

  export type PaqueteTuristicoServicioUpdateManyWithWhereWithoutServicioInput = {
    where: PaqueteTuristicoServicioScalarWhereInput
    data: XOR<PaqueteTuristicoServicioUpdateManyMutationInput, PaqueteTuristicoServicioUncheckedUpdateManyWithoutServicioInput>
  }

  export type PaqueteTuristicoServicioScalarWhereInput = {
    AND?: PaqueteTuristicoServicioScalarWhereInput | PaqueteTuristicoServicioScalarWhereInput[]
    OR?: PaqueteTuristicoServicioScalarWhereInput[]
    NOT?: PaqueteTuristicoServicioScalarWhereInput | PaqueteTuristicoServicioScalarWhereInput[]
    id?: IntFilter<"PaqueteTuristicoServicio"> | number
    servicioId?: IntFilter<"PaqueteTuristicoServicio"> | number
    paqueteTuristicoId?: IntFilter<"PaqueteTuristicoServicio"> | number
    createdAt?: DateTimeFilter<"PaqueteTuristicoServicio"> | Date | string
    updatedAt?: DateTimeFilter<"PaqueteTuristicoServicio"> | Date | string
  }

  export type TipoServicioUpsertWithoutServiciosInput = {
    update: XOR<TipoServicioUpdateWithoutServiciosInput, TipoServicioUncheckedUpdateWithoutServiciosInput>
    create: XOR<TipoServicioCreateWithoutServiciosInput, TipoServicioUncheckedCreateWithoutServiciosInput>
    where?: TipoServicioWhereInput
  }

  export type TipoServicioUpdateToOneWithWhereWithoutServiciosInput = {
    where?: TipoServicioWhereInput
    data: XOR<TipoServicioUpdateWithoutServiciosInput, TipoServicioUncheckedUpdateWithoutServiciosInput>
  }

  export type TipoServicioUpdateWithoutServiciosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    imagenUrl?: StringFieldUpdateOperationsInput | string
    requiereCupo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoServicioUncheckedUpdateWithoutServiciosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    imagenUrl?: StringFieldUpdateOperationsInput | string
    requiereCupo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicioDisponibilidadUpsertWithWhereUniqueWithoutServicioInput = {
    where: ServicioDisponibilidadWhereUniqueInput
    update: XOR<ServicioDisponibilidadUpdateWithoutServicioInput, ServicioDisponibilidadUncheckedUpdateWithoutServicioInput>
    create: XOR<ServicioDisponibilidadCreateWithoutServicioInput, ServicioDisponibilidadUncheckedCreateWithoutServicioInput>
  }

  export type ServicioDisponibilidadUpdateWithWhereUniqueWithoutServicioInput = {
    where: ServicioDisponibilidadWhereUniqueInput
    data: XOR<ServicioDisponibilidadUpdateWithoutServicioInput, ServicioDisponibilidadUncheckedUpdateWithoutServicioInput>
  }

  export type ServicioDisponibilidadUpdateManyWithWhereWithoutServicioInput = {
    where: ServicioDisponibilidadScalarWhereInput
    data: XOR<ServicioDisponibilidadUpdateManyMutationInput, ServicioDisponibilidadUncheckedUpdateManyWithoutServicioInput>
  }

  export type ServicioDisponibilidadScalarWhereInput = {
    AND?: ServicioDisponibilidadScalarWhereInput | ServicioDisponibilidadScalarWhereInput[]
    OR?: ServicioDisponibilidadScalarWhereInput[]
    NOT?: ServicioDisponibilidadScalarWhereInput | ServicioDisponibilidadScalarWhereInput[]
    id?: IntFilter<"ServicioDisponibilidad"> | number
    servicioId?: IntFilter<"ServicioDisponibilidad"> | number
    fecha?: DateTimeFilter<"ServicioDisponibilidad"> | Date | string
    cuposDisponibles?: IntFilter<"ServicioDisponibilidad"> | number
    precioEspecial?: DecimalNullableFilter<"ServicioDisponibilidad"> | Decimal | DecimalJsLike | number | string | null
  }

  export type ServicioEmprendedorUpsertWithWhereUniqueWithoutServicioInput = {
    where: ServicioEmprendedorWhereUniqueInput
    update: XOR<ServicioEmprendedorUpdateWithoutServicioInput, ServicioEmprendedorUncheckedUpdateWithoutServicioInput>
    create: XOR<ServicioEmprendedorCreateWithoutServicioInput, ServicioEmprendedorUncheckedCreateWithoutServicioInput>
  }

  export type ServicioEmprendedorUpdateWithWhereUniqueWithoutServicioInput = {
    where: ServicioEmprendedorWhereUniqueInput
    data: XOR<ServicioEmprendedorUpdateWithoutServicioInput, ServicioEmprendedorUncheckedUpdateWithoutServicioInput>
  }

  export type ServicioEmprendedorUpdateManyWithWhereWithoutServicioInput = {
    where: ServicioEmprendedorScalarWhereInput
    data: XOR<ServicioEmprendedorUpdateManyMutationInput, ServicioEmprendedorUncheckedUpdateManyWithoutServicioInput>
  }

  export type PaqueteTuristicoCreateWithoutServiciosInput = {
    nombre: string
    descripcion: string
    duracionDias: number
    duracionNoches?: number | null
    precioPorPersona: Decimal | DecimalJsLike | number | string
    moneda?: string
    capacidadMaxima?: number | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: string | null
    incluye?: string | null
    noIncluye?: string | null
    estado?: string
    esPersonalizable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    disponibilidad?: DisponibilidadPaqueteCreateNestedManyWithoutPaqueteInput
    emprendimiento?: EmprendimientoCreateNestedOneWithoutPaquetesTuristicosInput
  }

  export type PaqueteTuristicoUncheckedCreateWithoutServiciosInput = {
    id?: number
    emprendimientoId?: number | null
    nombre: string
    descripcion: string
    duracionDias: number
    duracionNoches?: number | null
    precioPorPersona: Decimal | DecimalJsLike | number | string
    moneda?: string
    capacidadMaxima?: number | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: string | null
    incluye?: string | null
    noIncluye?: string | null
    estado?: string
    esPersonalizable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    disponibilidad?: DisponibilidadPaqueteUncheckedCreateNestedManyWithoutPaqueteInput
  }

  export type PaqueteTuristicoCreateOrConnectWithoutServiciosInput = {
    where: PaqueteTuristicoWhereUniqueInput
    create: XOR<PaqueteTuristicoCreateWithoutServiciosInput, PaqueteTuristicoUncheckedCreateWithoutServiciosInput>
  }

  export type ServicioCreateWithoutPaquetesServiciosInput = {
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerariosReserva?: ItinerarioReservaCreateNestedManyWithoutServicioInput
    tipoServicio: TipoServicioCreateNestedOneWithoutServiciosInput
    disponibilidad?: ServicioDisponibilidadCreateNestedManyWithoutServicioInput
    serviciosEmprendedores?: ServicioEmprendedorCreateNestedManyWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutPaquetesServiciosInput = {
    id?: number
    tipoServicioId: number
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerariosReserva?: ItinerarioReservaUncheckedCreateNestedManyWithoutServicioInput
    disponibilidad?: ServicioDisponibilidadUncheckedCreateNestedManyWithoutServicioInput
    serviciosEmprendedores?: ServicioEmprendedorUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioCreateOrConnectWithoutPaquetesServiciosInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutPaquetesServiciosInput, ServicioUncheckedCreateWithoutPaquetesServiciosInput>
  }

  export type PaqueteTuristicoUpsertWithoutServiciosInput = {
    update: XOR<PaqueteTuristicoUpdateWithoutServiciosInput, PaqueteTuristicoUncheckedUpdateWithoutServiciosInput>
    create: XOR<PaqueteTuristicoCreateWithoutServiciosInput, PaqueteTuristicoUncheckedCreateWithoutServiciosInput>
    where?: PaqueteTuristicoWhereInput
  }

  export type PaqueteTuristicoUpdateToOneWithWhereWithoutServiciosInput = {
    where?: PaqueteTuristicoWhereInput
    data: XOR<PaqueteTuristicoUpdateWithoutServiciosInput, PaqueteTuristicoUncheckedUpdateWithoutServiciosInput>
  }

  export type PaqueteTuristicoUpdateWithoutServiciosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracionDias?: IntFieldUpdateOperationsInput | number
    duracionNoches?: NullableIntFieldUpdateOperationsInput | number | null
    precioPorPersona?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    capacidadMaxima?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null
    incluye?: NullableStringFieldUpdateOperationsInput | string | null
    noIncluye?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    esPersonalizable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disponibilidad?: DisponibilidadPaqueteUpdateManyWithoutPaqueteNestedInput
    emprendimiento?: EmprendimientoUpdateOneWithoutPaquetesTuristicosNestedInput
  }

  export type PaqueteTuristicoUncheckedUpdateWithoutServiciosInput = {
    id?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracionDias?: IntFieldUpdateOperationsInput | number
    duracionNoches?: NullableIntFieldUpdateOperationsInput | number | null
    precioPorPersona?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    capacidadMaxima?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null
    incluye?: NullableStringFieldUpdateOperationsInput | string | null
    noIncluye?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    esPersonalizable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disponibilidad?: DisponibilidadPaqueteUncheckedUpdateManyWithoutPaqueteNestedInput
  }

  export type ServicioUpsertWithoutPaquetesServiciosInput = {
    update: XOR<ServicioUpdateWithoutPaquetesServiciosInput, ServicioUncheckedUpdateWithoutPaquetesServiciosInput>
    create: XOR<ServicioCreateWithoutPaquetesServiciosInput, ServicioUncheckedCreateWithoutPaquetesServiciosInput>
    where?: ServicioWhereInput
  }

  export type ServicioUpdateToOneWithWhereWithoutPaquetesServiciosInput = {
    where?: ServicioWhereInput
    data: XOR<ServicioUpdateWithoutPaquetesServiciosInput, ServicioUncheckedUpdateWithoutPaquetesServiciosInput>
  }

  export type ServicioUpdateWithoutPaquetesServiciosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerariosReserva?: ItinerarioReservaUpdateManyWithoutServicioNestedInput
    tipoServicio?: TipoServicioUpdateOneRequiredWithoutServiciosNestedInput
    disponibilidad?: ServicioDisponibilidadUpdateManyWithoutServicioNestedInput
    serviciosEmprendedores?: ServicioEmprendedorUpdateManyWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutPaquetesServiciosInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoServicioId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerariosReserva?: ItinerarioReservaUncheckedUpdateManyWithoutServicioNestedInput
    disponibilidad?: ServicioDisponibilidadUncheckedUpdateManyWithoutServicioNestedInput
    serviciosEmprendedores?: ServicioEmprendedorUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type DisponibilidadPaqueteCreateWithoutPaqueteInput = {
    fechaInicio: Date | string
    fechaFin: Date | string
    cuposDisponibles: number
    precioEspecial?: Decimal | DecimalJsLike | number | string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisponibilidadPaqueteUncheckedCreateWithoutPaqueteInput = {
    id?: number
    fechaInicio: Date | string
    fechaFin: Date | string
    cuposDisponibles: number
    precioEspecial?: Decimal | DecimalJsLike | number | string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisponibilidadPaqueteCreateOrConnectWithoutPaqueteInput = {
    where: DisponibilidadPaqueteWhereUniqueInput
    create: XOR<DisponibilidadPaqueteCreateWithoutPaqueteInput, DisponibilidadPaqueteUncheckedCreateWithoutPaqueteInput>
  }

  export type DisponibilidadPaqueteCreateManyPaqueteInputEnvelope = {
    data: DisponibilidadPaqueteCreateManyPaqueteInput | DisponibilidadPaqueteCreateManyPaqueteInput[]
    skipDuplicates?: boolean
  }

  export type EmprendimientoCreateWithoutPaquetesTuristicosInput = {
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subdivision?: SubdivisionCreateNestedOneWithoutEmprendimientosInput
    usuario: UsuarioCreateNestedOneWithoutEmprendimientosInput
    favoritos?: FavoritoCreateNestedManyWithoutEmprendimientoInput
    servicios?: ServicioEmprendedorCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateWithoutPaquetesTuristicosInput = {
    id?: number
    usuarioId: number
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    subdivisionId?: number | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutEmprendimientoInput
    servicios?: ServicioEmprendedorUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoCreateOrConnectWithoutPaquetesTuristicosInput = {
    where: EmprendimientoWhereUniqueInput
    create: XOR<EmprendimientoCreateWithoutPaquetesTuristicosInput, EmprendimientoUncheckedCreateWithoutPaquetesTuristicosInput>
  }

  export type PaqueteTuristicoServicioCreateWithoutPaqueteTuristicoInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    servicio: ServicioCreateNestedOneWithoutPaquetesServiciosInput
  }

  export type PaqueteTuristicoServicioUncheckedCreateWithoutPaqueteTuristicoInput = {
    id?: number
    servicioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaqueteTuristicoServicioCreateOrConnectWithoutPaqueteTuristicoInput = {
    where: PaqueteTuristicoServicioWhereUniqueInput
    create: XOR<PaqueteTuristicoServicioCreateWithoutPaqueteTuristicoInput, PaqueteTuristicoServicioUncheckedCreateWithoutPaqueteTuristicoInput>
  }

  export type PaqueteTuristicoServicioCreateManyPaqueteTuristicoInputEnvelope = {
    data: PaqueteTuristicoServicioCreateManyPaqueteTuristicoInput | PaqueteTuristicoServicioCreateManyPaqueteTuristicoInput[]
    skipDuplicates?: boolean
  }

  export type DisponibilidadPaqueteUpsertWithWhereUniqueWithoutPaqueteInput = {
    where: DisponibilidadPaqueteWhereUniqueInput
    update: XOR<DisponibilidadPaqueteUpdateWithoutPaqueteInput, DisponibilidadPaqueteUncheckedUpdateWithoutPaqueteInput>
    create: XOR<DisponibilidadPaqueteCreateWithoutPaqueteInput, DisponibilidadPaqueteUncheckedCreateWithoutPaqueteInput>
  }

  export type DisponibilidadPaqueteUpdateWithWhereUniqueWithoutPaqueteInput = {
    where: DisponibilidadPaqueteWhereUniqueInput
    data: XOR<DisponibilidadPaqueteUpdateWithoutPaqueteInput, DisponibilidadPaqueteUncheckedUpdateWithoutPaqueteInput>
  }

  export type DisponibilidadPaqueteUpdateManyWithWhereWithoutPaqueteInput = {
    where: DisponibilidadPaqueteScalarWhereInput
    data: XOR<DisponibilidadPaqueteUpdateManyMutationInput, DisponibilidadPaqueteUncheckedUpdateManyWithoutPaqueteInput>
  }

  export type DisponibilidadPaqueteScalarWhereInput = {
    AND?: DisponibilidadPaqueteScalarWhereInput | DisponibilidadPaqueteScalarWhereInput[]
    OR?: DisponibilidadPaqueteScalarWhereInput[]
    NOT?: DisponibilidadPaqueteScalarWhereInput | DisponibilidadPaqueteScalarWhereInput[]
    id?: IntFilter<"DisponibilidadPaquete"> | number
    paqueteId?: IntFilter<"DisponibilidadPaquete"> | number
    fechaInicio?: DateTimeFilter<"DisponibilidadPaquete"> | Date | string
    fechaFin?: DateTimeFilter<"DisponibilidadPaquete"> | Date | string
    cuposDisponibles?: IntFilter<"DisponibilidadPaquete"> | number
    precioEspecial?: DecimalNullableFilter<"DisponibilidadPaquete"> | Decimal | DecimalJsLike | number | string | null
    notas?: StringNullableFilter<"DisponibilidadPaquete"> | string | null
    createdAt?: DateTimeFilter<"DisponibilidadPaquete"> | Date | string
    updatedAt?: DateTimeFilter<"DisponibilidadPaquete"> | Date | string
  }

  export type EmprendimientoUpsertWithoutPaquetesTuristicosInput = {
    update: XOR<EmprendimientoUpdateWithoutPaquetesTuristicosInput, EmprendimientoUncheckedUpdateWithoutPaquetesTuristicosInput>
    create: XOR<EmprendimientoCreateWithoutPaquetesTuristicosInput, EmprendimientoUncheckedCreateWithoutPaquetesTuristicosInput>
    where?: EmprendimientoWhereInput
  }

  export type EmprendimientoUpdateToOneWithWhereWithoutPaquetesTuristicosInput = {
    where?: EmprendimientoWhereInput
    data: XOR<EmprendimientoUpdateWithoutPaquetesTuristicosInput, EmprendimientoUncheckedUpdateWithoutPaquetesTuristicosInput>
  }

  export type EmprendimientoUpdateWithoutPaquetesTuristicosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subdivision?: SubdivisionUpdateOneWithoutEmprendimientosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput
    favoritos?: FavoritoUpdateManyWithoutEmprendimientoNestedInput
    servicios?: ServicioEmprendedorUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateWithoutPaquetesTuristicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    subdivisionId?: NullableIntFieldUpdateOperationsInput | number | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favoritos?: FavoritoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    servicios?: ServicioEmprendedorUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type PaqueteTuristicoServicioUpsertWithWhereUniqueWithoutPaqueteTuristicoInput = {
    where: PaqueteTuristicoServicioWhereUniqueInput
    update: XOR<PaqueteTuristicoServicioUpdateWithoutPaqueteTuristicoInput, PaqueteTuristicoServicioUncheckedUpdateWithoutPaqueteTuristicoInput>
    create: XOR<PaqueteTuristicoServicioCreateWithoutPaqueteTuristicoInput, PaqueteTuristicoServicioUncheckedCreateWithoutPaqueteTuristicoInput>
  }

  export type PaqueteTuristicoServicioUpdateWithWhereUniqueWithoutPaqueteTuristicoInput = {
    where: PaqueteTuristicoServicioWhereUniqueInput
    data: XOR<PaqueteTuristicoServicioUpdateWithoutPaqueteTuristicoInput, PaqueteTuristicoServicioUncheckedUpdateWithoutPaqueteTuristicoInput>
  }

  export type PaqueteTuristicoServicioUpdateManyWithWhereWithoutPaqueteTuristicoInput = {
    where: PaqueteTuristicoServicioScalarWhereInput
    data: XOR<PaqueteTuristicoServicioUpdateManyMutationInput, PaqueteTuristicoServicioUncheckedUpdateManyWithoutPaqueteTuristicoInput>
  }

  export type PaqueteTuristicoCreateWithoutDisponibilidadInput = {
    nombre: string
    descripcion: string
    duracionDias: number
    duracionNoches?: number | null
    precioPorPersona: Decimal | DecimalJsLike | number | string
    moneda?: string
    capacidadMaxima?: number | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: string | null
    incluye?: string | null
    noIncluye?: string | null
    estado?: string
    esPersonalizable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimiento?: EmprendimientoCreateNestedOneWithoutPaquetesTuristicosInput
    servicios?: PaqueteTuristicoServicioCreateNestedManyWithoutPaqueteTuristicoInput
  }

  export type PaqueteTuristicoUncheckedCreateWithoutDisponibilidadInput = {
    id?: number
    emprendimientoId?: number | null
    nombre: string
    descripcion: string
    duracionDias: number
    duracionNoches?: number | null
    precioPorPersona: Decimal | DecimalJsLike | number | string
    moneda?: string
    capacidadMaxima?: number | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: string | null
    incluye?: string | null
    noIncluye?: string | null
    estado?: string
    esPersonalizable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    servicios?: PaqueteTuristicoServicioUncheckedCreateNestedManyWithoutPaqueteTuristicoInput
  }

  export type PaqueteTuristicoCreateOrConnectWithoutDisponibilidadInput = {
    where: PaqueteTuristicoWhereUniqueInput
    create: XOR<PaqueteTuristicoCreateWithoutDisponibilidadInput, PaqueteTuristicoUncheckedCreateWithoutDisponibilidadInput>
  }

  export type PaqueteTuristicoUpsertWithoutDisponibilidadInput = {
    update: XOR<PaqueteTuristicoUpdateWithoutDisponibilidadInput, PaqueteTuristicoUncheckedUpdateWithoutDisponibilidadInput>
    create: XOR<PaqueteTuristicoCreateWithoutDisponibilidadInput, PaqueteTuristicoUncheckedCreateWithoutDisponibilidadInput>
    where?: PaqueteTuristicoWhereInput
  }

  export type PaqueteTuristicoUpdateToOneWithWhereWithoutDisponibilidadInput = {
    where?: PaqueteTuristicoWhereInput
    data: XOR<PaqueteTuristicoUpdateWithoutDisponibilidadInput, PaqueteTuristicoUncheckedUpdateWithoutDisponibilidadInput>
  }

  export type PaqueteTuristicoUpdateWithoutDisponibilidadInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracionDias?: IntFieldUpdateOperationsInput | number
    duracionNoches?: NullableIntFieldUpdateOperationsInput | number | null
    precioPorPersona?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    capacidadMaxima?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null
    incluye?: NullableStringFieldUpdateOperationsInput | string | null
    noIncluye?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    esPersonalizable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimiento?: EmprendimientoUpdateOneWithoutPaquetesTuristicosNestedInput
    servicios?: PaqueteTuristicoServicioUpdateManyWithoutPaqueteTuristicoNestedInput
  }

  export type PaqueteTuristicoUncheckedUpdateWithoutDisponibilidadInput = {
    id?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: NullableIntFieldUpdateOperationsInput | number | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracionDias?: IntFieldUpdateOperationsInput | number
    duracionNoches?: NullableIntFieldUpdateOperationsInput | number | null
    precioPorPersona?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    capacidadMaxima?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null
    incluye?: NullableStringFieldUpdateOperationsInput | string | null
    noIncluye?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    esPersonalizable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicios?: PaqueteTuristicoServicioUncheckedUpdateManyWithoutPaqueteTuristicoNestedInput
  }

  export type ServicioCreateWithoutTipoServicioInput = {
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerariosReserva?: ItinerarioReservaCreateNestedManyWithoutServicioInput
    paquetesServicios?: PaqueteTuristicoServicioCreateNestedManyWithoutServicioInput
    disponibilidad?: ServicioDisponibilidadCreateNestedManyWithoutServicioInput
    serviciosEmprendedores?: ServicioEmprendedorCreateNestedManyWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutTipoServicioInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerariosReserva?: ItinerarioReservaUncheckedCreateNestedManyWithoutServicioInput
    paquetesServicios?: PaqueteTuristicoServicioUncheckedCreateNestedManyWithoutServicioInput
    disponibilidad?: ServicioDisponibilidadUncheckedCreateNestedManyWithoutServicioInput
    serviciosEmprendedores?: ServicioEmprendedorUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioCreateOrConnectWithoutTipoServicioInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutTipoServicioInput, ServicioUncheckedCreateWithoutTipoServicioInput>
  }

  export type ServicioCreateManyTipoServicioInputEnvelope = {
    data: ServicioCreateManyTipoServicioInput | ServicioCreateManyTipoServicioInput[]
    skipDuplicates?: boolean
  }

  export type ServicioUpsertWithWhereUniqueWithoutTipoServicioInput = {
    where: ServicioWhereUniqueInput
    update: XOR<ServicioUpdateWithoutTipoServicioInput, ServicioUncheckedUpdateWithoutTipoServicioInput>
    create: XOR<ServicioCreateWithoutTipoServicioInput, ServicioUncheckedCreateWithoutTipoServicioInput>
  }

  export type ServicioUpdateWithWhereUniqueWithoutTipoServicioInput = {
    where: ServicioWhereUniqueInput
    data: XOR<ServicioUpdateWithoutTipoServicioInput, ServicioUncheckedUpdateWithoutTipoServicioInput>
  }

  export type ServicioUpdateManyWithWhereWithoutTipoServicioInput = {
    where: ServicioScalarWhereInput
    data: XOR<ServicioUpdateManyMutationInput, ServicioUncheckedUpdateManyWithoutTipoServicioInput>
  }

  export type ServicioScalarWhereInput = {
    AND?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
    OR?: ServicioScalarWhereInput[]
    NOT?: ServicioScalarWhereInput | ServicioScalarWhereInput[]
    id?: IntFilter<"Servicio"> | number
    tipoServicioId?: IntFilter<"Servicio"> | number
    nombre?: StringFilter<"Servicio"> | string
    descripcion?: StringNullableFilter<"Servicio"> | string | null
    precioBase?: DecimalFilter<"Servicio"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Servicio"> | string
    estado?: StringFilter<"Servicio"> | string
    imagenUrl?: StringFilter<"Servicio"> | string
    detallesServicio?: JsonFilter<"Servicio">
    createdAt?: DateTimeFilter<"Servicio"> | Date | string
    updatedAt?: DateTimeFilter<"Servicio"> | Date | string
  }

  export type ServicioCreateWithoutDisponibilidadInput = {
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerariosReserva?: ItinerarioReservaCreateNestedManyWithoutServicioInput
    paquetesServicios?: PaqueteTuristicoServicioCreateNestedManyWithoutServicioInput
    tipoServicio: TipoServicioCreateNestedOneWithoutServiciosInput
    serviciosEmprendedores?: ServicioEmprendedorCreateNestedManyWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutDisponibilidadInput = {
    id?: number
    tipoServicioId: number
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerariosReserva?: ItinerarioReservaUncheckedCreateNestedManyWithoutServicioInput
    paquetesServicios?: PaqueteTuristicoServicioUncheckedCreateNestedManyWithoutServicioInput
    serviciosEmprendedores?: ServicioEmprendedorUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioCreateOrConnectWithoutDisponibilidadInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutDisponibilidadInput, ServicioUncheckedCreateWithoutDisponibilidadInput>
  }

  export type ServicioUpsertWithoutDisponibilidadInput = {
    update: XOR<ServicioUpdateWithoutDisponibilidadInput, ServicioUncheckedUpdateWithoutDisponibilidadInput>
    create: XOR<ServicioCreateWithoutDisponibilidadInput, ServicioUncheckedCreateWithoutDisponibilidadInput>
    where?: ServicioWhereInput
  }

  export type ServicioUpdateToOneWithWhereWithoutDisponibilidadInput = {
    where?: ServicioWhereInput
    data: XOR<ServicioUpdateWithoutDisponibilidadInput, ServicioUncheckedUpdateWithoutDisponibilidadInput>
  }

  export type ServicioUpdateWithoutDisponibilidadInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerariosReserva?: ItinerarioReservaUpdateManyWithoutServicioNestedInput
    paquetesServicios?: PaqueteTuristicoServicioUpdateManyWithoutServicioNestedInput
    tipoServicio?: TipoServicioUpdateOneRequiredWithoutServiciosNestedInput
    serviciosEmprendedores?: ServicioEmprendedorUpdateManyWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutDisponibilidadInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoServicioId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerariosReserva?: ItinerarioReservaUncheckedUpdateManyWithoutServicioNestedInput
    paquetesServicios?: PaqueteTuristicoServicioUncheckedUpdateManyWithoutServicioNestedInput
    serviciosEmprendedores?: ServicioEmprendedorUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type UsuarioCreateWithoutResenasInput = {
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoCreateNestedManyWithoutUsuarioInput
    favoritos?: FavoritoCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoCreateNestedManyWithoutUsuarioInput
    persona: PersonaCreateNestedOneWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutResenasInput = {
    id?: number
    personaId: number
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput
    favoritos?: FavoritoUncheckedCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoUncheckedCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoUncheckedCreateNestedManyWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutResenasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutResenasInput, UsuarioUncheckedCreateWithoutResenasInput>
  }

  export type UsuarioUpsertWithoutResenasInput = {
    update: XOR<UsuarioUpdateWithoutResenasInput, UsuarioUncheckedUpdateWithoutResenasInput>
    create: XOR<UsuarioCreateWithoutResenasInput, UsuarioUncheckedCreateWithoutResenasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutResenasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutResenasInput, UsuarioUncheckedUpdateWithoutResenasInput>
  }

  export type UsuarioUpdateWithoutResenasInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUpdateManyWithoutUsuarioNestedInput
    favoritos?: FavoritoUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUpdateManyWithoutUsuarioNestedInput
    persona?: PersonaUpdateOneRequiredWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutResenasInput = {
    id?: IntFieldUpdateOperationsInput | number
    personaId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput
    favoritos?: FavoritoUncheckedUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUncheckedUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUncheckedUpdateManyWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type EmprendimientoCreateWithoutFavoritosInput = {
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subdivision?: SubdivisionCreateNestedOneWithoutEmprendimientosInput
    usuario: UsuarioCreateNestedOneWithoutEmprendimientosInput
    paquetesTuristicos?: PaqueteTuristicoCreateNestedManyWithoutEmprendimientoInput
    servicios?: ServicioEmprendedorCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateWithoutFavoritosInput = {
    id?: number
    usuarioId: number
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    subdivisionId?: number | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paquetesTuristicos?: PaqueteTuristicoUncheckedCreateNestedManyWithoutEmprendimientoInput
    servicios?: ServicioEmprendedorUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoCreateOrConnectWithoutFavoritosInput = {
    where: EmprendimientoWhereUniqueInput
    create: XOR<EmprendimientoCreateWithoutFavoritosInput, EmprendimientoUncheckedCreateWithoutFavoritosInput>
  }

  export type UsuarioCreateWithoutFavoritosInput = {
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoCreateNestedManyWithoutUsuarioInput
    persona: PersonaCreateNestedOneWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutFavoritosInput = {
    id?: number
    personaId: number
    email: string
    passwordHash: string
    recoveryToken?: string | null
    recoveryTokenExpiresAt?: Date | string | null
    emailVerificationToken?: string | null
    emailVerified?: boolean
    estaActivo?: boolean
    ultimoAcceso?: Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput
    registroAccesos?: RegistroAccesoUncheckedCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
    tokensInvalidados?: TokenInvalidadoUncheckedCreateNestedManyWithoutUsuarioInput
    usuariosRoles?: UsuariosRolesUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutFavoritosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutFavoritosInput, UsuarioUncheckedCreateWithoutFavoritosInput>
  }

  export type EmprendimientoUpsertWithoutFavoritosInput = {
    update: XOR<EmprendimientoUpdateWithoutFavoritosInput, EmprendimientoUncheckedUpdateWithoutFavoritosInput>
    create: XOR<EmprendimientoCreateWithoutFavoritosInput, EmprendimientoUncheckedCreateWithoutFavoritosInput>
    where?: EmprendimientoWhereInput
  }

  export type EmprendimientoUpdateToOneWithWhereWithoutFavoritosInput = {
    where?: EmprendimientoWhereInput
    data: XOR<EmprendimientoUpdateWithoutFavoritosInput, EmprendimientoUncheckedUpdateWithoutFavoritosInput>
  }

  export type EmprendimientoUpdateWithoutFavoritosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subdivision?: SubdivisionUpdateOneWithoutEmprendimientosNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput
    paquetesTuristicos?: PaqueteTuristicoUpdateManyWithoutEmprendimientoNestedInput
    servicios?: ServicioEmprendedorUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateWithoutFavoritosInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    subdivisionId?: NullableIntFieldUpdateOperationsInput | number | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paquetesTuristicos?: PaqueteTuristicoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    servicios?: ServicioEmprendedorUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type UsuarioUpsertWithoutFavoritosInput = {
    update: XOR<UsuarioUpdateWithoutFavoritosInput, UsuarioUncheckedUpdateWithoutFavoritosInput>
    create: XOR<UsuarioCreateWithoutFavoritosInput, UsuarioUncheckedCreateWithoutFavoritosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutFavoritosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutFavoritosInput, UsuarioUncheckedUpdateWithoutFavoritosInput>
  }

  export type UsuarioUpdateWithoutFavoritosInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUpdateManyWithoutUsuarioNestedInput
    persona?: PersonaUpdateOneRequiredWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutFavoritosInput = {
    id?: IntFieldUpdateOperationsInput | number
    personaId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    recoveryToken?: NullableStringFieldUpdateOperationsInput | string | null
    recoveryTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    estaActivo?: BoolFieldUpdateOperationsInput | boolean
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    preferencias?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput
    registroAccesos?: RegistroAccesoUncheckedUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
    tokensInvalidados?: TokenInvalidadoUncheckedUpdateManyWithoutUsuarioNestedInput
    usuariosRoles?: UsuariosRolesUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type ItinerarioReservaCreateWithoutReservaInput = {
    fecha: Date | string
    hora?: Date | string | null
    tipoEvento: string
    descripcion: string
    notas?: string | null
    duracion?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarioLugares?: ItinerarioLugarCreateNestedManyWithoutItinerarioReservaInput
    servicio?: ServicioCreateNestedOneWithoutItinerariosReservaInput
  }

  export type ItinerarioReservaUncheckedCreateWithoutReservaInput = {
    id?: number
    fecha: Date | string
    hora?: Date | string | null
    tipoEvento: string
    descripcion: string
    notas?: string | null
    duracion?: number | null
    servicioId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarioLugares?: ItinerarioLugarUncheckedCreateNestedManyWithoutItinerarioReservaInput
  }

  export type ItinerarioReservaCreateOrConnectWithoutReservaInput = {
    where: ItinerarioReservaWhereUniqueInput
    create: XOR<ItinerarioReservaCreateWithoutReservaInput, ItinerarioReservaUncheckedCreateWithoutReservaInput>
  }

  export type ItinerarioReservaCreateManyReservaInputEnvelope = {
    data: ItinerarioReservaCreateManyReservaInput | ItinerarioReservaCreateManyReservaInput[]
    skipDuplicates?: boolean
  }

  export type PagoCreateWithoutReservaInput = {
    codigoTransaccion?: string | null
    montoTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    fechaPago?: Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comprobante?: ComprobanteCreateNestedOneWithoutPagoInput
    detalles?: PagoDetalleCreateNestedManyWithoutPagoInput
  }

  export type PagoUncheckedCreateWithoutReservaInput = {
    id?: number
    codigoTransaccion?: string | null
    montoTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    fechaPago?: Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comprobante?: ComprobanteUncheckedCreateNestedOneWithoutPagoInput
    detalles?: PagoDetalleUncheckedCreateNestedManyWithoutPagoInput
  }

  export type PagoCreateOrConnectWithoutReservaInput = {
    where: PagoWhereUniqueInput
    create: XOR<PagoCreateWithoutReservaInput, PagoUncheckedCreateWithoutReservaInput>
  }

  export type PagoCreateManyReservaInputEnvelope = {
    data: PagoCreateManyReservaInput | PagoCreateManyReservaInput[]
    skipDuplicates?: boolean
  }

  export type TuristaCreateWithoutReservasInput = {
    nombre: string
    apellidos: string
    telefono: string
    direccion: string
    edad: Decimal | DecimalJsLike | number | string
    sexo: string
    pais: string
    peticionesEspeciales?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TuristaUncheckedCreateWithoutReservasInput = {
    id?: number
    nombre: string
    apellidos: string
    telefono: string
    direccion: string
    edad: Decimal | DecimalJsLike | number | string
    sexo: string
    pais: string
    peticionesEspeciales?: string | null
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TuristaCreateOrConnectWithoutReservasInput = {
    where: TuristaWhereUniqueInput
    create: XOR<TuristaCreateWithoutReservasInput, TuristaUncheckedCreateWithoutReservasInput>
  }

  export type ItinerarioReservaUpsertWithWhereUniqueWithoutReservaInput = {
    where: ItinerarioReservaWhereUniqueInput
    update: XOR<ItinerarioReservaUpdateWithoutReservaInput, ItinerarioReservaUncheckedUpdateWithoutReservaInput>
    create: XOR<ItinerarioReservaCreateWithoutReservaInput, ItinerarioReservaUncheckedCreateWithoutReservaInput>
  }

  export type ItinerarioReservaUpdateWithWhereUniqueWithoutReservaInput = {
    where: ItinerarioReservaWhereUniqueInput
    data: XOR<ItinerarioReservaUpdateWithoutReservaInput, ItinerarioReservaUncheckedUpdateWithoutReservaInput>
  }

  export type ItinerarioReservaUpdateManyWithWhereWithoutReservaInput = {
    where: ItinerarioReservaScalarWhereInput
    data: XOR<ItinerarioReservaUpdateManyMutationInput, ItinerarioReservaUncheckedUpdateManyWithoutReservaInput>
  }

  export type PagoUpsertWithWhereUniqueWithoutReservaInput = {
    where: PagoWhereUniqueInput
    update: XOR<PagoUpdateWithoutReservaInput, PagoUncheckedUpdateWithoutReservaInput>
    create: XOR<PagoCreateWithoutReservaInput, PagoUncheckedCreateWithoutReservaInput>
  }

  export type PagoUpdateWithWhereUniqueWithoutReservaInput = {
    where: PagoWhereUniqueInput
    data: XOR<PagoUpdateWithoutReservaInput, PagoUncheckedUpdateWithoutReservaInput>
  }

  export type PagoUpdateManyWithWhereWithoutReservaInput = {
    where: PagoScalarWhereInput
    data: XOR<PagoUpdateManyMutationInput, PagoUncheckedUpdateManyWithoutReservaInput>
  }

  export type PagoScalarWhereInput = {
    AND?: PagoScalarWhereInput | PagoScalarWhereInput[]
    OR?: PagoScalarWhereInput[]
    NOT?: PagoScalarWhereInput | PagoScalarWhereInput[]
    id?: IntFilter<"Pago"> | number
    reservaId?: IntFilter<"Pago"> | number
    codigoTransaccion?: StringNullableFilter<"Pago"> | string | null
    montoTotal?: DecimalFilter<"Pago"> | Decimal | DecimalJsLike | number | string
    moneda?: StringFilter<"Pago"> | string
    estado?: StringFilter<"Pago"> | string
    fechaPago?: DateTimeNullableFilter<"Pago"> | Date | string | null
    datosMetodoPago?: JsonNullableFilter<"Pago">
    metadata?: JsonFilter<"Pago">
    createdAt?: DateTimeFilter<"Pago"> | Date | string
    updatedAt?: DateTimeFilter<"Pago"> | Date | string
  }

  export type TuristaUpsertWithoutReservasInput = {
    update: XOR<TuristaUpdateWithoutReservasInput, TuristaUncheckedUpdateWithoutReservasInput>
    create: XOR<TuristaCreateWithoutReservasInput, TuristaUncheckedCreateWithoutReservasInput>
    where?: TuristaWhereInput
  }

  export type TuristaUpdateToOneWithWhereWithoutReservasInput = {
    where?: TuristaWhereInput
    data: XOR<TuristaUpdateWithoutReservasInput, TuristaUncheckedUpdateWithoutReservasInput>
  }

  export type TuristaUpdateWithoutReservasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    edad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sexo?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    peticionesEspeciales?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TuristaUncheckedUpdateWithoutReservasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    edad?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sexo?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    peticionesEspeciales?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItinerarioLugarCreateWithoutItinerarioReservaInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    lugarTuristico: LugarTuristicoCreateNestedOneWithoutItinerarioLugaresInput
  }

  export type ItinerarioLugarUncheckedCreateWithoutItinerarioReservaInput = {
    id?: number
    lugarTuristicoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItinerarioLugarCreateOrConnectWithoutItinerarioReservaInput = {
    where: ItinerarioLugarWhereUniqueInput
    create: XOR<ItinerarioLugarCreateWithoutItinerarioReservaInput, ItinerarioLugarUncheckedCreateWithoutItinerarioReservaInput>
  }

  export type ItinerarioLugarCreateManyItinerarioReservaInputEnvelope = {
    data: ItinerarioLugarCreateManyItinerarioReservaInput | ItinerarioLugarCreateManyItinerarioReservaInput[]
    skipDuplicates?: boolean
  }

  export type ReservaCreateWithoutItinerariosInput = {
    codigoReserva: string
    tipoReserva: string
    fechaReserva?: Date | string
    fechaInicio: Date | string
    hora?: string | null
    fechaFin?: Date | string | null
    cantidadPersonas?: number
    precioTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    metodoPago?: string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: string | null
    motivoCancelacion?: string | null
    fechaCancelacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pagos?: PagoCreateNestedManyWithoutReservaInput
    turista: TuristaCreateNestedOneWithoutReservasInput
  }

  export type ReservaUncheckedCreateWithoutItinerariosInput = {
    id?: number
    codigoReserva: string
    turistaId: number
    tipoReserva: string
    fechaReserva?: Date | string
    fechaInicio: Date | string
    hora?: string | null
    fechaFin?: Date | string | null
    cantidadPersonas?: number
    precioTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    metodoPago?: string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: string | null
    motivoCancelacion?: string | null
    fechaCancelacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pagos?: PagoUncheckedCreateNestedManyWithoutReservaInput
  }

  export type ReservaCreateOrConnectWithoutItinerariosInput = {
    where: ReservaWhereUniqueInput
    create: XOR<ReservaCreateWithoutItinerariosInput, ReservaUncheckedCreateWithoutItinerariosInput>
  }

  export type ServicioCreateWithoutItinerariosReservaInput = {
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paquetesServicios?: PaqueteTuristicoServicioCreateNestedManyWithoutServicioInput
    tipoServicio: TipoServicioCreateNestedOneWithoutServiciosInput
    disponibilidad?: ServicioDisponibilidadCreateNestedManyWithoutServicioInput
    serviciosEmprendedores?: ServicioEmprendedorCreateNestedManyWithoutServicioInput
  }

  export type ServicioUncheckedCreateWithoutItinerariosReservaInput = {
    id?: number
    tipoServicioId: number
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    paquetesServicios?: PaqueteTuristicoServicioUncheckedCreateNestedManyWithoutServicioInput
    disponibilidad?: ServicioDisponibilidadUncheckedCreateNestedManyWithoutServicioInput
    serviciosEmprendedores?: ServicioEmprendedorUncheckedCreateNestedManyWithoutServicioInput
  }

  export type ServicioCreateOrConnectWithoutItinerariosReservaInput = {
    where: ServicioWhereUniqueInput
    create: XOR<ServicioCreateWithoutItinerariosReservaInput, ServicioUncheckedCreateWithoutItinerariosReservaInput>
  }

  export type ItinerarioLugarUpsertWithWhereUniqueWithoutItinerarioReservaInput = {
    where: ItinerarioLugarWhereUniqueInput
    update: XOR<ItinerarioLugarUpdateWithoutItinerarioReservaInput, ItinerarioLugarUncheckedUpdateWithoutItinerarioReservaInput>
    create: XOR<ItinerarioLugarCreateWithoutItinerarioReservaInput, ItinerarioLugarUncheckedCreateWithoutItinerarioReservaInput>
  }

  export type ItinerarioLugarUpdateWithWhereUniqueWithoutItinerarioReservaInput = {
    where: ItinerarioLugarWhereUniqueInput
    data: XOR<ItinerarioLugarUpdateWithoutItinerarioReservaInput, ItinerarioLugarUncheckedUpdateWithoutItinerarioReservaInput>
  }

  export type ItinerarioLugarUpdateManyWithWhereWithoutItinerarioReservaInput = {
    where: ItinerarioLugarScalarWhereInput
    data: XOR<ItinerarioLugarUpdateManyMutationInput, ItinerarioLugarUncheckedUpdateManyWithoutItinerarioReservaInput>
  }

  export type ReservaUpsertWithoutItinerariosInput = {
    update: XOR<ReservaUpdateWithoutItinerariosInput, ReservaUncheckedUpdateWithoutItinerariosInput>
    create: XOR<ReservaCreateWithoutItinerariosInput, ReservaUncheckedCreateWithoutItinerariosInput>
    where?: ReservaWhereInput
  }

  export type ReservaUpdateToOneWithWhereWithoutItinerariosInput = {
    where?: ReservaWhereInput
    data: XOR<ReservaUpdateWithoutItinerariosInput, ReservaUncheckedUpdateWithoutItinerariosInput>
  }

  export type ReservaUpdateWithoutItinerariosInput = {
    codigoReserva?: StringFieldUpdateOperationsInput | string
    tipoReserva?: StringFieldUpdateOperationsInput | string
    fechaReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableStringFieldUpdateOperationsInput | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidadPersonas?: IntFieldUpdateOperationsInput | number
    precioTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    motivoCancelacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCancelacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagos?: PagoUpdateManyWithoutReservaNestedInput
    turista?: TuristaUpdateOneRequiredWithoutReservasNestedInput
  }

  export type ReservaUncheckedUpdateWithoutItinerariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoReserva?: StringFieldUpdateOperationsInput | string
    turistaId?: IntFieldUpdateOperationsInput | number
    tipoReserva?: StringFieldUpdateOperationsInput | string
    fechaReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableStringFieldUpdateOperationsInput | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidadPersonas?: IntFieldUpdateOperationsInput | number
    precioTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    motivoCancelacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCancelacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagos?: PagoUncheckedUpdateManyWithoutReservaNestedInput
  }

  export type ServicioUpsertWithoutItinerariosReservaInput = {
    update: XOR<ServicioUpdateWithoutItinerariosReservaInput, ServicioUncheckedUpdateWithoutItinerariosReservaInput>
    create: XOR<ServicioCreateWithoutItinerariosReservaInput, ServicioUncheckedCreateWithoutItinerariosReservaInput>
    where?: ServicioWhereInput
  }

  export type ServicioUpdateToOneWithWhereWithoutItinerariosReservaInput = {
    where?: ServicioWhereInput
    data: XOR<ServicioUpdateWithoutItinerariosReservaInput, ServicioUncheckedUpdateWithoutItinerariosReservaInput>
  }

  export type ServicioUpdateWithoutItinerariosReservaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paquetesServicios?: PaqueteTuristicoServicioUpdateManyWithoutServicioNestedInput
    tipoServicio?: TipoServicioUpdateOneRequiredWithoutServiciosNestedInput
    disponibilidad?: ServicioDisponibilidadUpdateManyWithoutServicioNestedInput
    serviciosEmprendedores?: ServicioEmprendedorUpdateManyWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutItinerariosReservaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoServicioId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paquetesServicios?: PaqueteTuristicoServicioUncheckedUpdateManyWithoutServicioNestedInput
    disponibilidad?: ServicioDisponibilidadUncheckedUpdateManyWithoutServicioNestedInput
    serviciosEmprendedores?: ServicioEmprendedorUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type ItinerarioReservaCreateWithoutItinerarioLugaresInput = {
    fecha: Date | string
    hora?: Date | string | null
    tipoEvento: string
    descripcion: string
    notas?: string | null
    duracion?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reserva: ReservaCreateNestedOneWithoutItinerariosInput
    servicio?: ServicioCreateNestedOneWithoutItinerariosReservaInput
  }

  export type ItinerarioReservaUncheckedCreateWithoutItinerarioLugaresInput = {
    id?: number
    fecha: Date | string
    hora?: Date | string | null
    tipoEvento: string
    descripcion: string
    notas?: string | null
    duracion?: number | null
    reservaId: number
    servicioId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItinerarioReservaCreateOrConnectWithoutItinerarioLugaresInput = {
    where: ItinerarioReservaWhereUniqueInput
    create: XOR<ItinerarioReservaCreateWithoutItinerarioLugaresInput, ItinerarioReservaUncheckedCreateWithoutItinerarioLugaresInput>
  }

  export type LugarTuristicoCreateWithoutItinerarioLugaresInput = {
    nombre: string
    descripcion: string
    direccion: string
    coordenadas: string
    horarioApertura?: Date | string | null
    horarioCierre?: Date | string | null
    costoEntrada?: Decimal | DecimalJsLike | number | string | null
    recomendaciones?: string | null
    restricciones?: string | null
    esDestacado?: boolean
    estado?: string
    imagenUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LugarTuristicoUncheckedCreateWithoutItinerarioLugaresInput = {
    id?: number
    nombre: string
    descripcion: string
    direccion: string
    coordenadas: string
    horarioApertura?: Date | string | null
    horarioCierre?: Date | string | null
    costoEntrada?: Decimal | DecimalJsLike | number | string | null
    recomendaciones?: string | null
    restricciones?: string | null
    esDestacado?: boolean
    estado?: string
    imagenUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LugarTuristicoCreateOrConnectWithoutItinerarioLugaresInput = {
    where: LugarTuristicoWhereUniqueInput
    create: XOR<LugarTuristicoCreateWithoutItinerarioLugaresInput, LugarTuristicoUncheckedCreateWithoutItinerarioLugaresInput>
  }

  export type ItinerarioReservaUpsertWithoutItinerarioLugaresInput = {
    update: XOR<ItinerarioReservaUpdateWithoutItinerarioLugaresInput, ItinerarioReservaUncheckedUpdateWithoutItinerarioLugaresInput>
    create: XOR<ItinerarioReservaCreateWithoutItinerarioLugaresInput, ItinerarioReservaUncheckedCreateWithoutItinerarioLugaresInput>
    where?: ItinerarioReservaWhereInput
  }

  export type ItinerarioReservaUpdateToOneWithWhereWithoutItinerarioLugaresInput = {
    where?: ItinerarioReservaWhereInput
    data: XOR<ItinerarioReservaUpdateWithoutItinerarioLugaresInput, ItinerarioReservaUncheckedUpdateWithoutItinerarioLugaresInput>
  }

  export type ItinerarioReservaUpdateWithoutItinerarioLugaresInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reserva?: ReservaUpdateOneRequiredWithoutItinerariosNestedInput
    servicio?: ServicioUpdateOneWithoutItinerariosReservaNestedInput
  }

  export type ItinerarioReservaUncheckedUpdateWithoutItinerarioLugaresInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    reservaId?: IntFieldUpdateOperationsInput | number
    servicioId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LugarTuristicoUpsertWithoutItinerarioLugaresInput = {
    update: XOR<LugarTuristicoUpdateWithoutItinerarioLugaresInput, LugarTuristicoUncheckedUpdateWithoutItinerarioLugaresInput>
    create: XOR<LugarTuristicoCreateWithoutItinerarioLugaresInput, LugarTuristicoUncheckedCreateWithoutItinerarioLugaresInput>
    where?: LugarTuristicoWhereInput
  }

  export type LugarTuristicoUpdateToOneWithWhereWithoutItinerarioLugaresInput = {
    where?: LugarTuristicoWhereInput
    data: XOR<LugarTuristicoUpdateWithoutItinerarioLugaresInput, LugarTuristicoUncheckedUpdateWithoutItinerarioLugaresInput>
  }

  export type LugarTuristicoUpdateWithoutItinerarioLugaresInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    coordenadas?: StringFieldUpdateOperationsInput | string
    horarioApertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioCierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costoEntrada?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recomendaciones?: NullableStringFieldUpdateOperationsInput | string | null
    restricciones?: NullableStringFieldUpdateOperationsInput | string | null
    esDestacado?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LugarTuristicoUncheckedUpdateWithoutItinerarioLugaresInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    direccion?: StringFieldUpdateOperationsInput | string
    coordenadas?: StringFieldUpdateOperationsInput | string
    horarioApertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    horarioCierre?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costoEntrada?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    recomendaciones?: NullableStringFieldUpdateOperationsInput | string | null
    restricciones?: NullableStringFieldUpdateOperationsInput | string | null
    esDestacado?: BoolFieldUpdateOperationsInput | boolean
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComprobanteCreateWithoutPagoInput = {
    tipoComprobante: string
    serie: string
    numero: number
    fechaEmision?: Date | string
    rucCliente?: string | null
    razonSocial?: string | null
    direccionCliente?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    igv?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    codigoSunat?: string | null
    codigoHash?: string | null
    xmlUrl?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComprobanteUncheckedCreateWithoutPagoInput = {
    id?: number
    tipoComprobante: string
    serie: string
    numero: number
    fechaEmision?: Date | string
    rucCliente?: string | null
    razonSocial?: string | null
    direccionCliente?: string | null
    subtotal: Decimal | DecimalJsLike | number | string
    igv?: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    codigoSunat?: string | null
    codigoHash?: string | null
    xmlUrl?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComprobanteCreateOrConnectWithoutPagoInput = {
    where: ComprobanteWhereUniqueInput
    create: XOR<ComprobanteCreateWithoutPagoInput, ComprobanteUncheckedCreateWithoutPagoInput>
  }

  export type ReservaCreateWithoutPagosInput = {
    codigoReserva: string
    tipoReserva: string
    fechaReserva?: Date | string
    fechaInicio: Date | string
    hora?: string | null
    fechaFin?: Date | string | null
    cantidadPersonas?: number
    precioTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    metodoPago?: string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: string | null
    motivoCancelacion?: string | null
    fechaCancelacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarios?: ItinerarioReservaCreateNestedManyWithoutReservaInput
    turista: TuristaCreateNestedOneWithoutReservasInput
  }

  export type ReservaUncheckedCreateWithoutPagosInput = {
    id?: number
    codigoReserva: string
    turistaId: number
    tipoReserva: string
    fechaReserva?: Date | string
    fechaInicio: Date | string
    hora?: string | null
    fechaFin?: Date | string | null
    cantidadPersonas?: number
    precioTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    metodoPago?: string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: string | null
    motivoCancelacion?: string | null
    fechaCancelacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    itinerarios?: ItinerarioReservaUncheckedCreateNestedManyWithoutReservaInput
  }

  export type ReservaCreateOrConnectWithoutPagosInput = {
    where: ReservaWhereUniqueInput
    create: XOR<ReservaCreateWithoutPagosInput, ReservaUncheckedCreateWithoutPagosInput>
  }

  export type PagoDetalleCreateWithoutPagoInput = {
    concepto: string
    monto: Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: Decimal | DecimalJsLike | number | string
    cantidad?: number
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tipoPago: TipoPagoCreateNestedOneWithoutPagoDetallesInput
  }

  export type PagoDetalleUncheckedCreateWithoutPagoInput = {
    id?: number
    tipoPagoId: number
    concepto: string
    monto: Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: Decimal | DecimalJsLike | number | string
    cantidad?: number
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoDetalleCreateOrConnectWithoutPagoInput = {
    where: PagoDetalleWhereUniqueInput
    create: XOR<PagoDetalleCreateWithoutPagoInput, PagoDetalleUncheckedCreateWithoutPagoInput>
  }

  export type PagoDetalleCreateManyPagoInputEnvelope = {
    data: PagoDetalleCreateManyPagoInput | PagoDetalleCreateManyPagoInput[]
    skipDuplicates?: boolean
  }

  export type ComprobanteUpsertWithoutPagoInput = {
    update: XOR<ComprobanteUpdateWithoutPagoInput, ComprobanteUncheckedUpdateWithoutPagoInput>
    create: XOR<ComprobanteCreateWithoutPagoInput, ComprobanteUncheckedCreateWithoutPagoInput>
    where?: ComprobanteWhereInput
  }

  export type ComprobanteUpdateToOneWithWhereWithoutPagoInput = {
    where?: ComprobanteWhereInput
    data: XOR<ComprobanteUpdateWithoutPagoInput, ComprobanteUncheckedUpdateWithoutPagoInput>
  }

  export type ComprobanteUpdateWithoutPagoInput = {
    tipoComprobante?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    rucCliente?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    direccionCliente?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    codigoSunat?: NullableStringFieldUpdateOperationsInput | string | null
    codigoHash?: NullableStringFieldUpdateOperationsInput | string | null
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComprobanteUncheckedUpdateWithoutPagoInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoComprobante?: StringFieldUpdateOperationsInput | string
    serie?: StringFieldUpdateOperationsInput | string
    numero?: IntFieldUpdateOperationsInput | number
    fechaEmision?: DateTimeFieldUpdateOperationsInput | Date | string
    rucCliente?: NullableStringFieldUpdateOperationsInput | string | null
    razonSocial?: NullableStringFieldUpdateOperationsInput | string | null
    direccionCliente?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    igv?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    codigoSunat?: NullableStringFieldUpdateOperationsInput | string | null
    codigoHash?: NullableStringFieldUpdateOperationsInput | string | null
    xmlUrl?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservaUpsertWithoutPagosInput = {
    update: XOR<ReservaUpdateWithoutPagosInput, ReservaUncheckedUpdateWithoutPagosInput>
    create: XOR<ReservaCreateWithoutPagosInput, ReservaUncheckedCreateWithoutPagosInput>
    where?: ReservaWhereInput
  }

  export type ReservaUpdateToOneWithWhereWithoutPagosInput = {
    where?: ReservaWhereInput
    data: XOR<ReservaUpdateWithoutPagosInput, ReservaUncheckedUpdateWithoutPagosInput>
  }

  export type ReservaUpdateWithoutPagosInput = {
    codigoReserva?: StringFieldUpdateOperationsInput | string
    tipoReserva?: StringFieldUpdateOperationsInput | string
    fechaReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableStringFieldUpdateOperationsInput | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidadPersonas?: IntFieldUpdateOperationsInput | number
    precioTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    motivoCancelacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCancelacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarios?: ItinerarioReservaUpdateManyWithoutReservaNestedInput
    turista?: TuristaUpdateOneRequiredWithoutReservasNestedInput
  }

  export type ReservaUncheckedUpdateWithoutPagosInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoReserva?: StringFieldUpdateOperationsInput | string
    turistaId?: IntFieldUpdateOperationsInput | number
    tipoReserva?: StringFieldUpdateOperationsInput | string
    fechaReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableStringFieldUpdateOperationsInput | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidadPersonas?: IntFieldUpdateOperationsInput | number
    precioTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    motivoCancelacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCancelacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarios?: ItinerarioReservaUncheckedUpdateManyWithoutReservaNestedInput
  }

  export type PagoDetalleUpsertWithWhereUniqueWithoutPagoInput = {
    where: PagoDetalleWhereUniqueInput
    update: XOR<PagoDetalleUpdateWithoutPagoInput, PagoDetalleUncheckedUpdateWithoutPagoInput>
    create: XOR<PagoDetalleCreateWithoutPagoInput, PagoDetalleUncheckedCreateWithoutPagoInput>
  }

  export type PagoDetalleUpdateWithWhereUniqueWithoutPagoInput = {
    where: PagoDetalleWhereUniqueInput
    data: XOR<PagoDetalleUpdateWithoutPagoInput, PagoDetalleUncheckedUpdateWithoutPagoInput>
  }

  export type PagoDetalleUpdateManyWithWhereWithoutPagoInput = {
    where: PagoDetalleScalarWhereInput
    data: XOR<PagoDetalleUpdateManyMutationInput, PagoDetalleUncheckedUpdateManyWithoutPagoInput>
  }

  export type PagoDetalleScalarWhereInput = {
    AND?: PagoDetalleScalarWhereInput | PagoDetalleScalarWhereInput[]
    OR?: PagoDetalleScalarWhereInput[]
    NOT?: PagoDetalleScalarWhereInput | PagoDetalleScalarWhereInput[]
    id?: IntFilter<"PagoDetalle"> | number
    pagoId?: IntFilter<"PagoDetalle"> | number
    tipoPagoId?: IntFilter<"PagoDetalle"> | number
    concepto?: StringFilter<"PagoDetalle"> | string
    monto?: DecimalFilter<"PagoDetalle"> | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalFilter<"PagoDetalle"> | Decimal | DecimalJsLike | number | string
    cantidad?: IntFilter<"PagoDetalle"> | number
    descripcion?: StringNullableFilter<"PagoDetalle"> | string | null
    createdAt?: DateTimeFilter<"PagoDetalle"> | Date | string
    updatedAt?: DateTimeFilter<"PagoDetalle"> | Date | string
  }

  export type PagoCreateWithoutDetallesInput = {
    codigoTransaccion?: string | null
    montoTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    fechaPago?: Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comprobante?: ComprobanteCreateNestedOneWithoutPagoInput
    reserva: ReservaCreateNestedOneWithoutPagosInput
  }

  export type PagoUncheckedCreateWithoutDetallesInput = {
    id?: number
    reservaId: number
    codigoTransaccion?: string | null
    montoTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    fechaPago?: Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comprobante?: ComprobanteUncheckedCreateNestedOneWithoutPagoInput
  }

  export type PagoCreateOrConnectWithoutDetallesInput = {
    where: PagoWhereUniqueInput
    create: XOR<PagoCreateWithoutDetallesInput, PagoUncheckedCreateWithoutDetallesInput>
  }

  export type TipoPagoCreateWithoutPagoDetallesInput = {
    nombre: string
    descripcion?: string | null
    requiereVerificacion?: boolean
    comisionPorcentaje?: Decimal | DecimalJsLike | number | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TipoPagoUncheckedCreateWithoutPagoDetallesInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    requiereVerificacion?: boolean
    comisionPorcentaje?: Decimal | DecimalJsLike | number | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TipoPagoCreateOrConnectWithoutPagoDetallesInput = {
    where: TipoPagoWhereUniqueInput
    create: XOR<TipoPagoCreateWithoutPagoDetallesInput, TipoPagoUncheckedCreateWithoutPagoDetallesInput>
  }

  export type PagoUpsertWithoutDetallesInput = {
    update: XOR<PagoUpdateWithoutDetallesInput, PagoUncheckedUpdateWithoutDetallesInput>
    create: XOR<PagoCreateWithoutDetallesInput, PagoUncheckedCreateWithoutDetallesInput>
    where?: PagoWhereInput
  }

  export type PagoUpdateToOneWithWhereWithoutDetallesInput = {
    where?: PagoWhereInput
    data: XOR<PagoUpdateWithoutDetallesInput, PagoUncheckedUpdateWithoutDetallesInput>
  }

  export type PagoUpdateWithoutDetallesInput = {
    codigoTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    montoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comprobante?: ComprobanteUpdateOneWithoutPagoNestedInput
    reserva?: ReservaUpdateOneRequiredWithoutPagosNestedInput
  }

  export type PagoUncheckedUpdateWithoutDetallesInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservaId?: IntFieldUpdateOperationsInput | number
    codigoTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    montoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comprobante?: ComprobanteUncheckedUpdateOneWithoutPagoNestedInput
  }

  export type TipoPagoUpsertWithoutPagoDetallesInput = {
    update: XOR<TipoPagoUpdateWithoutPagoDetallesInput, TipoPagoUncheckedUpdateWithoutPagoDetallesInput>
    create: XOR<TipoPagoCreateWithoutPagoDetallesInput, TipoPagoUncheckedCreateWithoutPagoDetallesInput>
    where?: TipoPagoWhereInput
  }

  export type TipoPagoUpdateToOneWithWhereWithoutPagoDetallesInput = {
    where?: TipoPagoWhereInput
    data: XOR<TipoPagoUpdateWithoutPagoDetallesInput, TipoPagoUncheckedUpdateWithoutPagoDetallesInput>
  }

  export type TipoPagoUpdateWithoutPagoDetallesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    requiereVerificacion?: BoolFieldUpdateOperationsInput | boolean
    comisionPorcentaje?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoPagoUncheckedUpdateWithoutPagoDetallesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    requiereVerificacion?: BoolFieldUpdateOperationsInput | boolean
    comisionPorcentaje?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDetalleCreateWithoutTipoPagoInput = {
    concepto: string
    monto: Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: Decimal | DecimalJsLike | number | string
    cantidad?: number
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pago: PagoCreateNestedOneWithoutDetallesInput
  }

  export type PagoDetalleUncheckedCreateWithoutTipoPagoInput = {
    id?: number
    pagoId: number
    concepto: string
    monto: Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: Decimal | DecimalJsLike | number | string
    cantidad?: number
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoDetalleCreateOrConnectWithoutTipoPagoInput = {
    where: PagoDetalleWhereUniqueInput
    create: XOR<PagoDetalleCreateWithoutTipoPagoInput, PagoDetalleUncheckedCreateWithoutTipoPagoInput>
  }

  export type PagoDetalleCreateManyTipoPagoInputEnvelope = {
    data: PagoDetalleCreateManyTipoPagoInput | PagoDetalleCreateManyTipoPagoInput[]
    skipDuplicates?: boolean
  }

  export type PagoDetalleUpsertWithWhereUniqueWithoutTipoPagoInput = {
    where: PagoDetalleWhereUniqueInput
    update: XOR<PagoDetalleUpdateWithoutTipoPagoInput, PagoDetalleUncheckedUpdateWithoutTipoPagoInput>
    create: XOR<PagoDetalleCreateWithoutTipoPagoInput, PagoDetalleUncheckedCreateWithoutTipoPagoInput>
  }

  export type PagoDetalleUpdateWithWhereUniqueWithoutTipoPagoInput = {
    where: PagoDetalleWhereUniqueInput
    data: XOR<PagoDetalleUpdateWithoutTipoPagoInput, PagoDetalleUncheckedUpdateWithoutTipoPagoInput>
  }

  export type PagoDetalleUpdateManyWithWhereWithoutTipoPagoInput = {
    where: PagoDetalleScalarWhereInput
    data: XOR<PagoDetalleUpdateManyMutationInput, PagoDetalleUncheckedUpdateManyWithoutTipoPagoInput>
  }

  export type PagoCreateWithoutComprobanteInput = {
    codigoTransaccion?: string | null
    montoTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    fechaPago?: Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    reserva: ReservaCreateNestedOneWithoutPagosInput
    detalles?: PagoDetalleCreateNestedManyWithoutPagoInput
  }

  export type PagoUncheckedCreateWithoutComprobanteInput = {
    id?: number
    reservaId: number
    codigoTransaccion?: string | null
    montoTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    fechaPago?: Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    detalles?: PagoDetalleUncheckedCreateNestedManyWithoutPagoInput
  }

  export type PagoCreateOrConnectWithoutComprobanteInput = {
    where: PagoWhereUniqueInput
    create: XOR<PagoCreateWithoutComprobanteInput, PagoUncheckedCreateWithoutComprobanteInput>
  }

  export type PagoUpsertWithoutComprobanteInput = {
    update: XOR<PagoUpdateWithoutComprobanteInput, PagoUncheckedUpdateWithoutComprobanteInput>
    create: XOR<PagoCreateWithoutComprobanteInput, PagoUncheckedCreateWithoutComprobanteInput>
    where?: PagoWhereInput
  }

  export type PagoUpdateToOneWithWhereWithoutComprobanteInput = {
    where?: PagoWhereInput
    data: XOR<PagoUpdateWithoutComprobanteInput, PagoUncheckedUpdateWithoutComprobanteInput>
  }

  export type PagoUpdateWithoutComprobanteInput = {
    codigoTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    montoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reserva?: ReservaUpdateOneRequiredWithoutPagosNestedInput
    detalles?: PagoDetalleUpdateManyWithoutPagoNestedInput
  }

  export type PagoUncheckedUpdateWithoutComprobanteInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservaId?: IntFieldUpdateOperationsInput | number
    codigoTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    montoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detalles?: PagoDetalleUncheckedUpdateManyWithoutPagoNestedInput
  }

  export type RolesPermisosCreateManyRolInput = {
    id?: number
    permisoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuariosRolesCreateManyRolInput = {
    id?: number
    usuarioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolesPermisosUpdateWithoutRolInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permiso?: PermisoUpdateOneRequiredWithoutRolesPermisosNestedInput
  }

  export type RolesPermisosUncheckedUpdateWithoutRolInput = {
    id?: IntFieldUpdateOperationsInput | number
    permisoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolesPermisosUncheckedUpdateManyWithoutRolInput = {
    id?: IntFieldUpdateOperationsInput | number
    permisoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuariosRolesUpdateWithoutRolInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutUsuariosRolesNestedInput
  }

  export type UsuariosRolesUncheckedUpdateWithoutRolInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuariosRolesUncheckedUpdateManyWithoutRolInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolesPermisosCreateManyPermisoInput = {
    id?: number
    rolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolesPermisosUpdateWithoutPermisoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: RoleUpdateOneRequiredWithoutRolesPermisosNestedInput
  }

  export type RolesPermisosUncheckedUpdateWithoutPermisoInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolesPermisosUncheckedUpdateManyWithoutPermisoInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubdivisionCreateManyCountryInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubdivisionUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUpdateManyWithoutSubdivisionNestedInput
    personas?: PersonaUpdateManyWithoutSubdivisionNestedInput
  }

  export type SubdivisionUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutSubdivisionNestedInput
    personas?: PersonaUncheckedUpdateManyWithoutSubdivisionNestedInput
  }

  export type SubdivisionUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprendimientoCreateManySubdivisionInput = {
    id?: number
    usuarioId: number
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonaCreateManySubdivisionInput = {
    id?: number
    nombre: string
    apellidos: string
    telefono?: string | null
    direccion?: string | null
    fotoPerfilUrl?: string | null
    fechaNacimiento?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmprendimientoUpdateWithoutSubdivisionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput
    favoritos?: FavoritoUpdateManyWithoutEmprendimientoNestedInput
    paquetesTuristicos?: PaqueteTuristicoUpdateManyWithoutEmprendimientoNestedInput
    servicios?: ServicioEmprendedorUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateWithoutSubdivisionInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favoritos?: FavoritoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    paquetesTuristicos?: PaqueteTuristicoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    servicios?: ServicioEmprendedorUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateManyWithoutSubdivisionInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonaUpdateWithoutSubdivisionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fotoPerfilUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneWithoutPersonaNestedInput
  }

  export type PersonaUncheckedUpdateWithoutSubdivisionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fotoPerfilUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUncheckedUpdateOneWithoutPersonaNestedInput
  }

  export type PersonaUncheckedUpdateManyWithoutSubdivisionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellidos?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fotoPerfilUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaNacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprendimientoCreateManyUsuarioInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    tipo: string
    direccion?: string | null
    subdivisionId?: number | null
    coordenadas?: string | null
    contactoTelefono?: string | null
    contactoEmail?: string | null
    sitioWeb?: string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: string
    fechaAprobacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoritoCreateManyUsuarioInput = {
    id?: number
    estado?: string
    emprendimientoId: number
    createdAt?: Date | string
  }

  export type RegistroAccesoCreateManyUsuarioInput = {
    id?: number
    ipAddress: string
    userAgent: string
    tipoEvento: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResenaCreateManyUsuarioInput = {
    id?: number
    tipoObjeto: string
    calificacion: number
    comentario?: string | null
    fechaExperiencia?: Date | string | null
    respuestaOwner?: string | null
    fechaRespuesta?: Date | string | null
    estado?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenInvalidadoCreateManyUsuarioInput = {
    id?: number
    tokenHash: string
    invalidadoEn: Date | string
    expiraEn: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsuariosRolesCreateManyUsuarioInput = {
    id?: number
    rolId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmprendimientoUpdateWithoutUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subdivision?: SubdivisionUpdateOneWithoutEmprendimientosNestedInput
    favoritos?: FavoritoUpdateManyWithoutEmprendimientoNestedInput
    paquetesTuristicos?: PaqueteTuristicoUpdateManyWithoutEmprendimientoNestedInput
    servicios?: ServicioEmprendedorUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    subdivisionId?: NullableIntFieldUpdateOperationsInput | number | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    favoritos?: FavoritoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    paquetesTuristicos?: PaqueteTuristicoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    servicios?: ServicioEmprendedorUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: StringFieldUpdateOperationsInput | string
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    subdivisionId?: NullableIntFieldUpdateOperationsInput | number | null
    coordenadas?: NullableStringFieldUpdateOperationsInput | string | null
    contactoTelefono?: NullableStringFieldUpdateOperationsInput | string | null
    contactoEmail?: NullableStringFieldUpdateOperationsInput | string | null
    sitioWeb?: NullableStringFieldUpdateOperationsInput | string | null
    redesSociales?: NullableJsonNullValueInput | InputJsonValue
    estado?: StringFieldUpdateOperationsInput | string
    fechaAprobacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoUpdateWithoutUsuarioInput = {
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimiento?: EmprendimientoUpdateOneRequiredWithoutFavoritosNestedInput
  }

  export type FavoritoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    emprendimientoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    emprendimientoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegistroAccesoUpdateWithoutUsuarioInput = {
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    tipoEvento?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegistroAccesoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    tipoEvento?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegistroAccesoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    tipoEvento?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResenaUpdateWithoutUsuarioInput = {
    tipoObjeto?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fechaExperiencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respuestaOwner?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResenaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoObjeto?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fechaExperiencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respuestaOwner?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResenaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoObjeto?: StringFieldUpdateOperationsInput | string
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fechaExperiencia?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respuestaOwner?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRespuesta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenInvalidadoUpdateWithoutUsuarioInput = {
    tokenHash?: StringFieldUpdateOperationsInput | string
    invalidadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenInvalidadoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    invalidadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenInvalidadoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    tokenHash?: StringFieldUpdateOperationsInput | string
    invalidadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuariosRolesUpdateWithoutUsuarioInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rol?: RoleUpdateOneRequiredWithoutUsuariosRolesNestedInput
  }

  export type UsuariosRolesUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuariosRolesUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoCreateManyEmprendimientoInput = {
    id?: number
    estado?: string
    usuarioId: number
    createdAt?: Date | string
  }

  export type PaqueteTuristicoCreateManyEmprendimientoInput = {
    id?: number
    nombre: string
    descripcion: string
    duracionDias: number
    duracionNoches?: number | null
    precioPorPersona: Decimal | DecimalJsLike | number | string
    moneda?: string
    capacidadMaxima?: number | null
    fechaInicio?: Date | string | null
    fechaFin?: Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: string | null
    incluye?: string | null
    noIncluye?: string | null
    estado?: string
    esPersonalizable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicioEmprendedorCreateManyEmprendimientoInput = {
    id?: number
    servicioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoritoUpdateWithoutEmprendimientoInput = {
    estado?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutFavoritosNestedInput
  }

  export type FavoritoUncheckedUpdateWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoritoUncheckedUpdateManyWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    estado?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTuristicoUpdateWithoutEmprendimientoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracionDias?: IntFieldUpdateOperationsInput | number
    duracionNoches?: NullableIntFieldUpdateOperationsInput | number | null
    precioPorPersona?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    capacidadMaxima?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null
    incluye?: NullableStringFieldUpdateOperationsInput | string | null
    noIncluye?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    esPersonalizable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disponibilidad?: DisponibilidadPaqueteUpdateManyWithoutPaqueteNestedInput
    servicios?: PaqueteTuristicoServicioUpdateManyWithoutPaqueteTuristicoNestedInput
  }

  export type PaqueteTuristicoUncheckedUpdateWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracionDias?: IntFieldUpdateOperationsInput | number
    duracionNoches?: NullableIntFieldUpdateOperationsInput | number | null
    precioPorPersona?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    capacidadMaxima?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null
    incluye?: NullableStringFieldUpdateOperationsInput | string | null
    noIncluye?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    esPersonalizable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    disponibilidad?: DisponibilidadPaqueteUncheckedUpdateManyWithoutPaqueteNestedInput
    servicios?: PaqueteTuristicoServicioUncheckedUpdateManyWithoutPaqueteTuristicoNestedInput
  }

  export type PaqueteTuristicoUncheckedUpdateManyWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    duracionDias?: IntFieldUpdateOperationsInput | number
    duracionNoches?: NullableIntFieldUpdateOperationsInput | number | null
    precioPorPersona?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    capacidadMaxima?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lugaresVisitados?: NullableJsonNullValueInput | InputJsonValue
    requisitos?: NullableStringFieldUpdateOperationsInput | string | null
    incluye?: NullableStringFieldUpdateOperationsInput | string | null
    noIncluye?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: StringFieldUpdateOperationsInput | string
    esPersonalizable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicioEmprendedorUpdateWithoutEmprendimientoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicio?: ServicioUpdateOneRequiredWithoutServiciosEmprendedoresNestedInput
  }

  export type ServicioEmprendedorUncheckedUpdateWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicioEmprendedorUncheckedUpdateManyWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservaCreateManyTuristaInput = {
    id?: number
    codigoReserva: string
    tipoReserva: string
    fechaReserva?: Date | string
    fechaInicio: Date | string
    hora?: string | null
    fechaFin?: Date | string | null
    cantidadPersonas?: number
    precioTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    metodoPago?: string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: string | null
    motivoCancelacion?: string | null
    fechaCancelacion?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservaUpdateWithoutTuristaInput = {
    codigoReserva?: StringFieldUpdateOperationsInput | string
    tipoReserva?: StringFieldUpdateOperationsInput | string
    fechaReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableStringFieldUpdateOperationsInput | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidadPersonas?: IntFieldUpdateOperationsInput | number
    precioTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    motivoCancelacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCancelacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarios?: ItinerarioReservaUpdateManyWithoutReservaNestedInput
    pagos?: PagoUpdateManyWithoutReservaNestedInput
  }

  export type ReservaUncheckedUpdateWithoutTuristaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoReserva?: StringFieldUpdateOperationsInput | string
    tipoReserva?: StringFieldUpdateOperationsInput | string
    fechaReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableStringFieldUpdateOperationsInput | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidadPersonas?: IntFieldUpdateOperationsInput | number
    precioTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    motivoCancelacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCancelacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarios?: ItinerarioReservaUncheckedUpdateManyWithoutReservaNestedInput
    pagos?: PagoUncheckedUpdateManyWithoutReservaNestedInput
  }

  export type ReservaUncheckedUpdateManyWithoutTuristaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoReserva?: StringFieldUpdateOperationsInput | string
    tipoReserva?: StringFieldUpdateOperationsInput | string
    fechaReserva?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableStringFieldUpdateOperationsInput | string | null
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cantidadPersonas?: IntFieldUpdateOperationsInput | number
    precioTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    metodoPago?: NullableStringFieldUpdateOperationsInput | string | null
    datosPago?: NullableJsonNullValueInput | InputJsonValue
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    motivoCancelacion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCancelacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItinerarioLugarCreateManyLugarTuristicoInput = {
    id?: number
    itinerarioReservaId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItinerarioLugarUpdateWithoutLugarTuristicoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarioReserva?: ItinerarioReservaUpdateOneRequiredWithoutItinerarioLugaresNestedInput
  }

  export type ItinerarioLugarUncheckedUpdateWithoutLugarTuristicoInput = {
    id?: IntFieldUpdateOperationsInput | number
    itinerarioReservaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItinerarioLugarUncheckedUpdateManyWithoutLugarTuristicoInput = {
    id?: IntFieldUpdateOperationsInput | number
    itinerarioReservaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItinerarioReservaCreateManyServicioInput = {
    id?: number
    fecha: Date | string
    hora?: Date | string | null
    tipoEvento: string
    descripcion: string
    notas?: string | null
    duracion?: number | null
    reservaId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaqueteTuristicoServicioCreateManyServicioInput = {
    id?: number
    paqueteTuristicoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicioDisponibilidadCreateManyServicioInput = {
    id?: number
    fecha: Date | string
    cuposDisponibles: number
    precioEspecial?: Decimal | DecimalJsLike | number | string | null
  }

  export type ServicioEmprendedorCreateManyServicioInput = {
    id?: number
    emprendimientoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItinerarioReservaUpdateWithoutServicioInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarioLugares?: ItinerarioLugarUpdateManyWithoutItinerarioReservaNestedInput
    reserva?: ReservaUpdateOneRequiredWithoutItinerariosNestedInput
  }

  export type ItinerarioReservaUncheckedUpdateWithoutServicioInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    reservaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarioLugares?: ItinerarioLugarUncheckedUpdateManyWithoutItinerarioReservaNestedInput
  }

  export type ItinerarioReservaUncheckedUpdateManyWithoutServicioInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    reservaId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTuristicoServicioUpdateWithoutServicioInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paqueteTuristico?: PaqueteTuristicoUpdateOneRequiredWithoutServiciosNestedInput
  }

  export type PaqueteTuristicoServicioUncheckedUpdateWithoutServicioInput = {
    id?: IntFieldUpdateOperationsInput | number
    paqueteTuristicoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTuristicoServicioUncheckedUpdateManyWithoutServicioInput = {
    id?: IntFieldUpdateOperationsInput | number
    paqueteTuristicoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicioDisponibilidadUpdateWithoutServicioInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ServicioDisponibilidadUncheckedUpdateWithoutServicioInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ServicioDisponibilidadUncheckedUpdateManyWithoutServicioInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type ServicioEmprendedorUpdateWithoutServicioInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimiento?: EmprendimientoUpdateOneRequiredWithoutServiciosNestedInput
  }

  export type ServicioEmprendedorUncheckedUpdateWithoutServicioInput = {
    id?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicioEmprendedorUncheckedUpdateManyWithoutServicioInput = {
    id?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibilidadPaqueteCreateManyPaqueteInput = {
    id?: number
    fechaInicio: Date | string
    fechaFin: Date | string
    cuposDisponibles: number
    precioEspecial?: Decimal | DecimalJsLike | number | string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaqueteTuristicoServicioCreateManyPaqueteTuristicoInput = {
    id?: number
    servicioId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisponibilidadPaqueteUpdateWithoutPaqueteInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibilidadPaqueteUncheckedUpdateWithoutPaqueteInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibilidadPaqueteUncheckedUpdateManyWithoutPaqueteInput = {
    id?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cuposDisponibles?: IntFieldUpdateOperationsInput | number
    precioEspecial?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTuristicoServicioUpdateWithoutPaqueteTuristicoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    servicio?: ServicioUpdateOneRequiredWithoutPaquetesServiciosNestedInput
  }

  export type PaqueteTuristicoServicioUncheckedUpdateWithoutPaqueteTuristicoInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaqueteTuristicoServicioUncheckedUpdateManyWithoutPaqueteTuristicoInput = {
    id?: IntFieldUpdateOperationsInput | number
    servicioId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicioCreateManyTipoServicioInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    precioBase: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    imagenUrl: string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicioUpdateWithoutTipoServicioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerariosReserva?: ItinerarioReservaUpdateManyWithoutServicioNestedInput
    paquetesServicios?: PaqueteTuristicoServicioUpdateManyWithoutServicioNestedInput
    disponibilidad?: ServicioDisponibilidadUpdateManyWithoutServicioNestedInput
    serviciosEmprendedores?: ServicioEmprendedorUpdateManyWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateWithoutTipoServicioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerariosReserva?: ItinerarioReservaUncheckedUpdateManyWithoutServicioNestedInput
    paquetesServicios?: PaqueteTuristicoServicioUncheckedUpdateManyWithoutServicioNestedInput
    disponibilidad?: ServicioDisponibilidadUncheckedUpdateManyWithoutServicioNestedInput
    serviciosEmprendedores?: ServicioEmprendedorUncheckedUpdateManyWithoutServicioNestedInput
  }

  export type ServicioUncheckedUpdateManyWithoutTipoServicioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precioBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    imagenUrl?: StringFieldUpdateOperationsInput | string
    detallesServicio?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItinerarioReservaCreateManyReservaInput = {
    id?: number
    fecha: Date | string
    hora?: Date | string | null
    tipoEvento: string
    descripcion: string
    notas?: string | null
    duracion?: number | null
    servicioId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoCreateManyReservaInput = {
    id?: number
    codigoTransaccion?: string | null
    montoTotal: Decimal | DecimalJsLike | number | string
    moneda?: string
    estado?: string
    fechaPago?: Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItinerarioReservaUpdateWithoutReservaInput = {
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarioLugares?: ItinerarioLugarUpdateManyWithoutItinerarioReservaNestedInput
    servicio?: ServicioUpdateOneWithoutItinerariosReservaNestedInput
  }

  export type ItinerarioReservaUncheckedUpdateWithoutReservaInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    servicioId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    itinerarioLugares?: ItinerarioLugarUncheckedUpdateManyWithoutItinerarioReservaNestedInput
  }

  export type ItinerarioReservaUncheckedUpdateManyWithoutReservaInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    hora?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoEvento?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    duracion?: NullableIntFieldUpdateOperationsInput | number | null
    servicioId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoUpdateWithoutReservaInput = {
    codigoTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    montoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comprobante?: ComprobanteUpdateOneWithoutPagoNestedInput
    detalles?: PagoDetalleUpdateManyWithoutPagoNestedInput
  }

  export type PagoUncheckedUpdateWithoutReservaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    montoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comprobante?: ComprobanteUncheckedUpdateOneWithoutPagoNestedInput
    detalles?: PagoDetalleUncheckedUpdateManyWithoutPagoNestedInput
  }

  export type PagoUncheckedUpdateManyWithoutReservaInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigoTransaccion?: NullableStringFieldUpdateOperationsInput | string | null
    montoTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    moneda?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaPago?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    datosMetodoPago?: NullableJsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItinerarioLugarCreateManyItinerarioReservaInput = {
    id?: number
    lugarTuristicoId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItinerarioLugarUpdateWithoutItinerarioReservaInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lugarTuristico?: LugarTuristicoUpdateOneRequiredWithoutItinerarioLugaresNestedInput
  }

  export type ItinerarioLugarUncheckedUpdateWithoutItinerarioReservaInput = {
    id?: IntFieldUpdateOperationsInput | number
    lugarTuristicoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItinerarioLugarUncheckedUpdateManyWithoutItinerarioReservaInput = {
    id?: IntFieldUpdateOperationsInput | number
    lugarTuristicoId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDetalleCreateManyPagoInput = {
    id?: number
    tipoPagoId: number
    concepto: string
    monto: Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: Decimal | DecimalJsLike | number | string
    cantidad?: number
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoDetalleUpdateWithoutPagoInput = {
    concepto?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoPago?: TipoPagoUpdateOneRequiredWithoutPagoDetallesNestedInput
  }

  export type PagoDetalleUncheckedUpdateWithoutPagoInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoPagoId?: IntFieldUpdateOperationsInput | number
    concepto?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDetalleUncheckedUpdateManyWithoutPagoInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoPagoId?: IntFieldUpdateOperationsInput | number
    concepto?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDetalleCreateManyTipoPagoInput = {
    id?: number
    pagoId: number
    concepto: string
    monto: Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: Decimal | DecimalJsLike | number | string
    cantidad?: number
    descripcion?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PagoDetalleUpdateWithoutTipoPagoInput = {
    concepto?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pago?: PagoUpdateOneRequiredWithoutDetallesNestedInput
  }

  export type PagoDetalleUncheckedUpdateWithoutTipoPagoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pagoId?: IntFieldUpdateOperationsInput | number
    concepto?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagoDetalleUncheckedUpdateManyWithoutTipoPagoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pagoId?: IntFieldUpdateOperationsInput | number
    concepto?: StringFieldUpdateOperationsInput | string
    monto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    porcentajeImpuesto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cantidad?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}